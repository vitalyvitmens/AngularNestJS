//TODO: Angular + NestJS (Угловой + ГнездышкоJS)
// Погрузитесь в TypeScript, влиятельный язык для веб-разработки. Узнайте, как Angular и NestJS объединяются для создания крупномасштабных приложений JavaScript.

//TODO: SETUP ANGULAR ON YOUR LOCAL SYSTEM:
//TODO: https://www.youtube.com/watch?v=yCIti018Srw
// node -v //чтобы проверить наличие установленного nodeJS
// npm -v //чтобы проверить наличие установленного менеджера пакетов npm

// npm install -g @angular/cli //чтобы УСТАНОВИТЬ Angular CLI
// ng new my-app //создать свой проект с любым названием, в данном случае my-app, на вопрос про routing выбираем Y, выбрать css и нажать enter, на ответы отвечаем: N
// cd my-app //перейдите в папку рабочей области
// ng serve --open //запускаем localhost:4200, на ответы отвечаем: N
//TODO: Если localhost:4200 не запустился:
// Открываем под админом CMD/PowerShell и выполняем две команды:
//   net stop winnat
// а затем:
//   net start winnat

//TODO: SETUP NestJS ON YOUR LOCAL SYSTEM:
//TODO: http://localhost:3000/
// cd cars //перейдите в папку рабочей области
// nest start --watch //после запуска открываем localhost:3000
//TODO: Ещё команды при использовании NestJS:
// nest generate controller bikes // это генерирует новую папку bikes с файлами контроллеров
// nest generate --help // покажет все возможные команды генерации
//TODO: Давайте сделаем Angular-сервис. Angular может сгенерировать сервис для вас с помощью простой команды, поэтому вам не нужно помнить, как построить базовую структуру. Для этого мы используем эту команду в компьютерном терминале:
//    cd my-app
//    ng generate service transportation
// Это создает пустой сервис в приложении Angular.

//TODO: Welcome to Full Stack Web Development (Добро пожаловать в веб-разработку с полным стеком)
// Поздравляем! Вы сделали большой шаг к тому, чтобы стать Full Stack разработчиком!
// В дополнение к прохождению этого курса не забудьте воспользоваться всей поддержкой обучения, доступной вам на SoloLearn, включая ежедневные советы, практики «Попробуйте сами», задачи тренера по коду, игровую площадку для кода и участие в нашем замечательном сообществе учащихся. Мы рады услышать от вас, поэтому, пожалуйста, оставляйте комментарии и отзывы, когда вы учитесь с нами.

//TODO: Overview (Обзор)
// Добро пожаловать на курс Full Stack TypeScript! В этом курсе вы будете создавать динамический интерфейсный веб-сайт и веб-приложения, которые работают вместе, и вы будете создавать все, используя TypeScript! Вы будете создавать вымышленный веб-сайт под названием «TS Flights», который имеет два основных интерфейса: один позволяет вводить рейсы самолетов в панель администратора, а другой позволяет искать рейсы. Мы создали предварительный просмотр, который позволит вам увидеть весь код как на передней, так и на внутренней стороне, а также рабочую модель готового веб-сайта, чтобы вы могли видеть, что вы будете создавать.
// См. Рис: Overview.jpg
// Не пугайтесь! Мы научим вас летать с TypeScript шаг за шагом.

//TODO: The Concept of Web Stacks (Концепция веб-стеков)
// Часто вы услышите, как программисты ссылаются на различные стеки в веб-разработке. За последние несколько лет мы наблюдаем распространение многих стеков, в том числе:
// • MEAN (Mongo, Express, Angular и Node)
// • LAMP (Linux, Apache, MySQL и PHP)
// • Python-Django
// • Ruby on Rails
// • .NET
// и скоро. Важно понимать, что эти стеки постоянно изобретаются, заново изобретаются, повторяются и смешиваются с другими стеками. Стек MEAN превратился в PEAN или NEAP .
// stack, когда некоторые разработчики начали возвращаться к использованию Postgresql вместо Mongo для ресурса базы данных, связанного с этим конкретным стеком. Стек — это не технический термин. Это расплывчатый термин, который может быть очень изменчивым, а иногда даже субъективным. Однако важно уметь сформулировать, с какими стеками вы чувствуете себя наиболее комфортно, когда станете разработчиком полного стека. Этот курс будет сосредоточен на обучении вас общим принципам полной веб-разработки с использованием относительно нового стека: стека на основе TypeScript с использованием Angular и NestJS. Эти навыки можно будет перенести в другие стеки, которые вы изучите в будущем.
// Стек TypeScript с использованием Angular и NestJS — один из новейших стеков в веб-разработке.

//TODO: Front-End vs Back-End (Фронт-энд против бэк-энда)
// Мы будем использовать аналогию с кухней, чтобы проиллюстрировать, как front-end и back-end взаимодействуют друг с другом. Изучите это изображение:
// См. Рис: Front-End vs Back-End_1.png
// В полнофункциональной веб-разработке холодильник можно рассматривать как БАЗУ ДАННЫХ или набор ресурсов данных, кухню — как WEB APPLICATION SERVER (СЕРВЕР ВЕБ-ПРИЛОЖЕНИЙ), а столовую — как набор технологий, который содержит в основном HTML, FRONT-END JAVASCRIPT, CSS и images (изображения).
// См. Рис: Front-End vs Back-End_2.png
// Для нашей аналогии базы данных и сервер веб-приложений являются частью серверной части. HTML CSS и интерфейсный JavaScript являются частью внешнего интерфейса.
// JavaScript и TypeScript можно использовать ОБА в front and the back-end of the stack.

//TODO: The Front-End (Интерфейс)
// В веб-разработке front-end (интерфейс) — это то, что видит пользователь. Экран, на который вы сейчас смотрите, — это внешний интерфейс приложения, будь то на телефоне, планшете или компьютере. Интерфейс в основном состоит из изображений, текста и виджетов, с которыми взаимодействует пользователь. Если для этих элементов требуется база данных, закулисная логика, процесс входа/аутентификации, отслеживание аналитики, общение с другими пользователями и другие подобные вещи, то интерфейсу нужен сервер. Однако не для всех интерфейсных приложений требуется серверная часть. Когда всемирная паутина впервые стала популярной в середине 1990-х годов, многие веб-сайты не имели серверной части. Простая HTML-страница с изображениями, текстом, контактной информацией и ссылкой на электронную почту не обязательно требует серверной части!
// Если вы создадите простой файл HTML на своем компьютере прямо сейчас, вы создадите то, что мы называем static web application (статическим веб-приложением). Это статическое приложение будет интерфейсом. В Интернете есть ресурсы, такие как Firebase, где вы можете разместить свои простые статические HTML-страницы почти мгновенно и бесплатно.
// Мир технологий стал очень специализированным. Многие разработчики специализируются только на front-end или back-end веб-разработке.

//TODO: The Back-End (Бэк-Энд)
// Серверная часть — это место, где живут как сервер веб-приложений, так и база данных. Есть множество других элементов, которые находятся внутри внутреннего пространства, таких как балансировщики нагрузки, сервисные работники, почтовые серверы и так далее. Однако в этом курсе мы сосредоточимся в первую очередь на сервере веб-приложений и базе данных.
// Наш сервер TS Flights будет иметь следующие основные обязанности:
// • Обработка запросов от внешнего интерфейса на информацию
// • Создание, чтение, обновление и удаление полетов самолетов в системе
// • Отправка информации обратно во внешний интерфейс в формате JSON (JavaScript Object Notation) (Java Сценарий Объекта Обозначения).
// Основной обязанностью серверной части является обработка данных, тогда как основной обязанностью внешней части является отображение данных и обработка взаимодействия с пользователем. Внешние интерфейсы также обрабатывают данные, но тяжелые манипуляции с данными, как правило, относятся к области серверных.
// Мы используем аббревиатуру CRUD (Create, Read, Update and Delete) для описания процессов создания, чтения, обновления и удаления данных.

//TODO: JavaScript and TypeScript throughout the Stack (JavaScript и TypeScript во всем стеке)
// JavaScript стал популярным полнофункциональным инструментом в 2009 году после выпуска NodeJS. До выпуска NodeJS JavaScript рассматривался в первую очередь как инструмент только для front-end, используемый для создания виджетов, действий пользователя на странице, манипулирования DOM (структурой веб-страницы) и других задач только для front-end. После выпуска NodeJS JavaScript стал рассматриваться как отличный инструмент для создания как back-ends так и front-ends одинаково. TypeScript был выпущен Microsoft в 2012 году, потому что многие разработчики JavaScript выразили желание иметь более структурированные и четкие типы данных, особенно для использования в крупномасштабных приложениях. TypeScript имеет некоторые функции, такие как статическая типизация переменных и интерфейсы, которые присутствуют в уважаемых устаревших языках, таких как Java и C#.
// TypeScript — это надмножество JavaScript. Это означает, что TypeScript переносится в JavaScript. Он буквально транслируется в код JavaScript при компиляции и перед запуском. TypeScript переводится в JavaScript. Это важная концепция, которую нужно помнить! Таким образом, после выпуска NestJS имело логическое значение, что TypeScript можно было использовать во всем стеке веб-приложений, как это было с JavaScript.
// Одним из создателей Typescript был сотрудник Microsoft Андерс Хейлсберг, создатель C#.

//TODO: XHR (XML/HTTP Request)
// Следующей концепцией, которую необходимо понять, является is the request / response nature of full stack applications (характер запроса/ответа приложений с полным стеком). В ресторане заказ еды исходит из столовой или от front-end. Клиент делает запрос на кухню. В веб-приложениях это обычно происходит в форме  XML/HTTP Request (запроса) или XHR. Давайте разберем этот термин: XML/HTTP Request. Хотя сам термин уже показывает свой возраст (мы не так часто используем XML для отправки данных через Интернет; вместо этого в большинстве случаев теперь используется JSON), вторая часть этого термина, HTTP, является критически важной. HTTP означает HyperTextTransfer Protocol (протокол передачи гипертекста).
// и является основой всего общения в сети. Думайте о HTTP как о способе, с помощью которого все веб-технологии должны взаимодействовать друг с другом.
// Вы можете проанализировать XHR любого веб-сайта на вкладке сети браузера в инструментах разработчика Chrome.

//TODO: The Request / Response Cycle (Цикл запроса/ответа)
// В нашей аналогии после того, как клиент делает запрос, его получает кухня или сервер веб-приложений. Затем сервер веб-приложений анализирует запрос и решает, может ли он выполнить этот заказ. Если заказ может быть выполнен, то кухонный персонал обращается к базе данных (к холодильнику), извлекает данные (еду), подготавливает данные (в формате JSON), а затем отправляет данные обратно клиенту (делает красивым отображение на странице).
// См. Рис: The Request & Response Cycle.png
// Это представляет собой очень простой цикл request/response (запрос/ответ). Запрос отправляется на сервер веб-приложений, анализируется и либо отклоняется NO (error or redirect (ошибка или перенаправление)), либо принимается (YES).

//TODO: HTTP Error Codes (Коды ошибок HTTP)
// Да, XML/HTTP Request (запросы) могут быть отклонены сервером! В случае отклонения сервер веб-приложений отправляет HTTP response (ответ) обратно клиенту (front-end). Возможные коды состояния ошибки HTTP:
// • 404 (не найдено)
// • 403 (запрещено)
// • 401 (не авторизовано)
// • 500 (внутренняя ошибка сервера)
// • 503 (сервис недоступен)
// Существует множество других кодов состояния HTTP, и они обычно делятся на категории. по первой цифре кода состояния.
// Сервер и клиент — очень распространенные термины в вычислительной технике. «server» в разработке полного стека обычно относится к серверу веб-приложений, а клиент — к любому устройству, взаимодействующему с сервером в front-end. Обычными клиентами являются ноутбуки и настольные компьютеры, мобильные телефоны, системы GPS в автомобилях, устройства с голосовым управлением, такие как Amazon Alexa, Siri и Google Home, игровые приставки, смарт-часы и все остальное, что подключается к серверной части.

//TODO: HTTP Success Codes (HTTP-коды успеха)
// Все коды уровня 200, как правило, являются положительными кодами состояния:
// • 200 (ok)
// • 201 (created (создано))
// • 202 (accepted (принято)) и т. д.
// Напротив, коды уровня 400 обычно указывают на проблему с самим запросом, а статус уровня 500 коды обычно указывают на ошибку на сервере. Если первоначальный запрос был принят сервером веб-приложений и необходимо получить данные, связанные с запросом, сервер веб-приложений затем запрашивает базу данных или базы данных, чтобы получить информацию, необходимую для отправки обратно пользователю.
// База данных отправляет результат запроса обратно на сервер веб-приложений, а затем сервер веб-приложений обычно форматирует данные в формат, который будет отправлен обратно в front-end. JSON (JavaScript Object Notation) (Java Сценарий Объекта Обозначения) — это очень распространенный формат, который в настоящее время используется для отправки данных клиентам (front-end).
// Коды уровня 200 — положительные, коды уровня 400 — проблемы, а коды уровня 500 — ошибки.

//TODO: The Angular / NEST flow (Угловой / NEST поток)
// Подводя итог, мы будем использовать TypeScript, надмножество JavaScript, для создания полнофункционального приложения под названием TS Flights, которое позволит пользователям искать рейсы самолетов. В приложении также будет страница, которая позволит вам, как администратору, вводить новые рейсы, чтобы отображаться в будущих поисках.
// На фронтенде мы будем использовать Angular. На бэкенде мы будем использовать NestJS.
// Для чего-то вроде поиска рейса или добавления нового рейса в базу данных наше внешнее приложение Angular будет делать запросы к нашему серверному NestJS, используя XHR. Если запрос отклонен, он вернет отрицательный код состояния HTTP обратно в Angular. Если запрос будет принят, он приступит к выполнению той работы, для которой был отправлен... которая может включать получение всех рейсов из Нью-Йорка в Париж или что-то в этом роде. Если запрос был принят и включает вызов базы данных, NestJS сделает запрос к нашей базе данных, получит результат и, если этот запрос к базе данных будет успешным, вернет ответ JSON нашему приложению Angular с кодом состояния уровня 200.
// Затем наше приложение Angular будет использовать HTML и CSS, чтобы сделать ответ красивым, чтобы наши пользователи могли видеть все рейсы в Париж на своем телефоне или компьютере. С помощью этого потока вы должны увидеть, что пользователь инициирует процесс на клиенте, запрос возвращается на сервер, выполняет свою работу, а затем возвращается обратно к клиенту для завершения процесса.
// Request/response cycles (Циклы запроса/ответа) могут быть невероятно сложными, но этот очень простой flow (поток) — начало понимания залпов между front and the back end.

//TODO: Introduction to Angular (Введение в Ангуляр)
// Angular — это front-end (интерфейсный) JavaScript-фреймворк.
// Фреймворк — это набор связанных библиотек, разработанных для определенного языка программирования. Фреймворки provide (предоставляют) conventions (соглашения), которые поддерживают определенные действия. Front-end (интерфейсная) среда обычно имеет определенные соглашения относительно того, как обрабатывается HTML, как создаются формы, как обрабатываются интерактивные элементы на веб-странице, как переменные интерполируются внутри HTML-представлений и т.д. AngularJS или Angular 1.x были первыми. итерация фреймворка Angular. С выходом Angular 2, Angular был полностью переработан с использованием TypeScript и компонентной архитектуры. Хотя архитектура на основе компонентов была доступна в более поздних выпусках Angular 1.x, компоненты теперь являются самой основой Angular 2 и всех последующих выпусков после версии 2 . вариант 3). Angular 8 был выпущен в 2019 году, и этому посвящен этот курс.
// Важно знать, что когда разработчики говорят Angular, они имеют в виду Angular версии 2 и выше. AngularJS относится только к версии 1 Angular.

//TODO: Strings in TypeScript (Строки в TypeScript)
// AngularJS использовал Javascript в качестве основного языка. Angular начал использовать TypeScript, начиная с Angular 2. С тех пор TypeScript стал основным языком Angular. Давайте рассмотрим некоторые основы TypeScript. Переменные в TypeScript могут быть statically typed (статически типизированы). Статически типизированные переменные всегда должны сохранять тип данных, с которого они начинаются. Например, когда переменная статически типизирована как строка, эта переменная не может содержать данные какого-либо другого типа. TypeScript использует ключевые слова JavaScript var, let и const для инициализации переменных. Он также использует двоеточие после имени переменной для обозначения типа.
// Javascript (JS):
// let name = 'Fred'
// TypeScript (TS):
// let name: string = 'Fred'
// Основываясь на этом соглашении, мы могли бы инициализировать строку shoesColor в TypeScript как таковую:
// TypeScript (TS):
// let shoeColor: string = 'blue'
// console.log(shoeColor)
// Возможно изменение значений переменных с течением времени:
// shoeColor = 'red'
// console.log(shoeColor)
// Теперь "shoeColor" имеет значение красного цвета. Обратите внимание, что после того, как переменная была введена, вам не нужно снова объявлять тип при изменении значения переменной.
// TypeScript не требует от вас статической типизации ввода переменных. Обычный синтаксис Javascript БУДЕТ работать в TypeScript. Однако по соглашению большинство программистов вводят статическую типизацию переменных в TypeScript, потому что это помогает обеспечить структуру и предотвратить ошибки программиста.

//TODO: Numbers in TypeScript (Числа в TypeScript)
// Другой тип данных TypeScript — числовой тип данных. Мы можем инициализировать числовую переменную seatCount в TypeScript следующим образом:
// TypeScript (TS):
// let seatCount: number = 42
// TypeScript не определяет между целыми числами и числами с плавающей запятой или десятичными числами, как другие языки, когда дело доходит до набора текста. Инициализация десятичного числа аналогична инициализации целого числа:
// TypeScript (TS):
// let registrationPercentage: number = 92.87
// Обратите внимание, что RegistrationPercentage всегда должен иметь числовой тип. Если бы вы попытались переназначить RegistrationPercentage строковому значению в другой строке этой программы, программа не скомпилировалась бы, и ваш текстовый редактор, скорее всего, выдал бы ошибку.
// TypeScript (TS):
// registrationPercentage = 'Ninety Two'
// ВЫЗЫВАЕТ ОШИБКУ, потому что RegistrationPercentage статически типизирован как число.
// Typescript включает в себя все методы, которые вы привыкли использовать в JavaScript. Например, строковые методы, такие как parseInt() и parseFloat(), которые возвращают числа, также будут работать в TypeScript.

//TODO: Booleans in TypeScript (Логические значения в TypeScript)
// Логические значения либо истинны, либо ложны. В TypeScript вы можете объявить и статически ввести переменную, не инициализируя ее значением. Например:
// TypeScript (TS):
// let isRegistered: boolean
// Однако если вы попытаетесь использовать isRegistered на этом этапе программы, вы получите сообщение об ошибке. Некоторые программисты объявляют переменные и вводят их без инициализации, потому что значение переменной в начале программы совершенно неизвестно. Позже вы можете назначить его.
// TypeScript (TS):
// isRegistered = false;
// console.log(isRegistered); // false
// Логические значения всегда возвращают истинные или ложные значения. Эти значения не являются строками, на самом деле они являются собственным типом данных.

//TODO: Enums in TypeScript (Перечисления в TypeScript)
// Значения Enum в Typescript представляют собой наборы констант. Думайте об Enum как о типе фиксированного массива вещей, которые вы используете в качестве ссылки, например, дни недели, штаты в США и т.д. Количество элементов никогда не меняется во время выполнения программы и порядок элементов. тоже не меняется. Давайте создадим перечисление с именем spiceLevel:
// TypeScript (TS):
// enum spiceLevel {
//   NONE = "no spice",
//   LOW = "barely spicy",
//   MEDIUM = "medium spicy",
//   HIGH = "hot"
// }

// console.log(spiceLevel.MEDIUM) // outputs "medium spicy"
// Современные интегрированные среды разработки (IDE), такие как Visual Studio Code, помогают заполнять значения перечисления и другие конструкции кода с помощью автозаполнения. Перечисления помогают гарантировать согласованность всех часто используемых констант в вашей программе. Это помогает избежать опечаток и общих ошибок.

//TODO: The 'any' Type in TypeScript (Тип «любой» в TypeScript)
// Наконец, мы рассмотрим any (любой) тип данных.
// Тип any (любой) по сути является подстановочным знаком. Он может держать что угодно. Мы можем объявить any тип данных в TypeScript следующим образом:
// TypeScript (TS):
// let userData: any
// userData теперь будет контейнером, который может содержать данные любого типа. Однако после инициализации userData он выводит тип из переданного ему значения.
// let userData: any
// TypeScript (TS):
// userData = 22
// console.log(userData + 2) // logs 24

// userData = "free";
// console.log(userData + "man") // logs "freeman"
// Обратите внимание, что с любым типом данных, даже если тип выводится при присвоении, вы можете повторно присвоить переменной другой тип данных, и он все равно будет работать. С какой стати вам вообще нужен тип any? Что ж, в определенных ситуациях, например при получении пользовательских данных с сервера, вы можете принимать переменные данные, которые предположительно могут относиться к любому типу данных.
// Любые типы не только вмещают данные из любого источника, но и сигнализируют другим разработчикам о том, что эта конкретная переменная имеет неизвестный тип и что с данными следует обращаться осторожно.

//TODO: Custom Types (Пользовательские типы)
// Если вы на минуту подумали, что TypeScript ограничен числовыми, строковыми, логическими и другими знакомыми типами, то у нас есть для вас приятный сюрприз! В TypeScript вы можете создавать свои СОБСТВЕННЫЕ типы и использовать их так же, как и примитивные типы, такие как числа и строки. Один из способов сделать это — создать interface. Interface в TypeScript — это структура данных, которая определяет форму данных. Давайте посмотрим на это в действии:
// TypeScript (TS):
// interface Order {
//   customerName: string,
//   itemNumbers: number[],
//   isComplete: boolean
// }
// Ключевое слово interface используется для инициализации интерфейса, который показывает нам ФОРМУ поступающих данных. Думайте об интерфейсе как о фабричной пресс-форме. Этот интерфейс используется для штамповки типов Order для store (хранилища). Теперь давайте воспользуемся интерфейсом Order для ввода переменной:
// TypeScript (TS):
// let order1: Order;
// order1 = {
//   customerName: "Abiye",
//   itemNumbers: [123, 44, 232],
//   isComplete: false
// }
// Проанализируем переменную order1 (заказ1). Он имеет тип Order (Заказ), поэтому он должен иметь 3 поля:
// - первое поле: строка "Abiye"
// - второе поле: массив целых чисел [123, 44, 232]
// - третье поле — логическое значение false
// Он ДОЛЖЕН иметь каждое из этих полей для выполнения контракта интерфейса. Попробуйте опустить одно из полей в order1 (например, удалите имя клиента). Вы получите ошибку, потому что контракт не выполнен.
// Контракт интерфейса — это просто список полей в этом интерфейсе, которые нужны любой переменной, если она хочет использовать этот тип. Все обычные поля в интерфейсе должны быть реализованы в любой переменной, которая использует этот тип.

//TODO: Optional Fields in Interfaces (Необязательные поля в интерфейсах)
// Мы можем использовать необязательные поля в интерфейсе в TypeScript. Необязательные поля не являются частью строгого контракта интерфейса. Вы можете опустить их при создании экземпляра этого интерфейса.
// TypeScript (TS):
// interface Order {
//   customerName: string,
//   itemNumbers: number[],
//   isComplete?: boolean
// }
// Обратите внимание на вопросительный знак после isComplete? (завершено?) означает, что мы можем опустить это значение, и код все равно скомпилируется. Это полезно для полей в интерфейсе, которые не являются обязательными.
// TypeScript (TS):
// let order1: Order;
// order1 = {
//   customerName: "Abiye",
//   itemNumbers: [123, 44, 232]
// }
// Order1 (заказ1) теперь имеет только 2 поля, и он все еще компилируется, потому что isComplete является необязательным полем.
// Необязательные поля полезны при получении данных из базы данных или вызове API, когда некоторые поля могут отсутствовать или быть неполными.

//TODO: Angular Files (Угловые файлы)
// До этого момента мы создавали простые файлы TypeScript, которые запускаются в любой среде, в которой работает TypeScript. Однако с этого момента мы будем писать ВЕСЬ наш TypeScript на Angular! В Angular каждый component имеет как минимум 4 файла, которые гармонично работают вместе. Эти файлы внутри папки выглядят примерно так:
// См. Рис: AngularFiles_1.png
// Здесь нас будут интересовать только два файла:
// - файл app.component.ts, который мы назовем component
// - файл app.component.html, который мы назовем component view (вид).
// component - это место, где объявляются и изменяются переменные.
// view (вид) - HTML-файл, который получает переменные от компонента и отображает их. Мы создали пример «hello world», чтобы показать вам, как эти файлы взаимодействуют друг с другом.
// COMPONENT (СОСТАВНАЯ ЧАСТЬ):
// TypeScript (TS):
// name = "Star student";
// VIEW (ВИД):
// HTML:
// Hello, {{name}}!
// Result (Результат):
// См. Рис: AngularFiles_2.png
// мы установили этот код в StackBlitz, онлайн-редакторе Angular, который позволяет запускать код на вашем телефоне! В StackBlitz файлы находятся слева, код — посередине, а небольшой браузер — справа. Вы можете просмотреть и/или отредактировать код и увидеть результат в течение нескольких секунд. Попробуйте на StackBlitz
// https://stackblitz.com/edit/angular-starter-example?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-starter-example
// Двойные фигурные скобки вокруг {{name}} демонстрируют то, что мы называем интерполяцией. Интерполяция — это вставка переменного содержимого из компонента в представление.

//TODO: SETUP ANGULAR ON YOUR LOCAL SYSTEM:
// node -v //чтобы проверить наличие установленного nodeJS
// npm -v //чтобы проверить наличие установленного менеджера пакетов npm

// npm install -g @angular/cli //чтобы УСТАНОВИТЬ Angular CLI
// ng new my-app //создать свой проект с любым названием, в данном случае my-app, выбрать css и нажать enter, на ответы отвечаем: N
// cd my-app //перейдите в папку рабочей области
// ng serve --open //запускаем localhost:4200, на ответы отвечаем: N
//TODO: Если localhost:4200 не запустился:
// Открываем под админом CMD/PowerShell и выполняем две команды:
//   net stop winnat
// а затем:
//   net start winnat
//TODO: Давайте сделаем Angular-сервис. Angular может сгенерировать сервис для вас с помощью простой команды, поэтому вам не нужно помнить, как построить базовую структуру. Для этого мы используем эту команду в компьютерном терминале:
//    cd my-app
//    ng generate service transportation
// Это создает пустой сервис в приложении Angular.

//TODO: Parts of a Component (Части компонента)
// См. Рис: Parts of a Component.png
// На нашей диаграмме ниже у нас есть 4 части компонента, представленные четырьмя разноцветными стрелками. Красный раздел — это раздел импорта. Оранжевая стрелка указывает на код, автоматически сгенерированный Angular; нам не нужно трогать эту часть, если мы не хотим ее изменить. Синяя стрелка указывает на то, где объявлены переменные класса. Наконец, зеленая стрелка указывает на то, где объявлены переменные метода. Переменные класса принадлежат всему классу, но переменные метода применяются только в каждом методе (или «функции»), в котором они находятся.
// Попробуйте в StackBlitz View:
// https://stackblitz.com/edit/angular-class-vs-method-variables-intro?file=README.md
// на GitHub:
// https://github.com/SoloLearn-Courses/angular-class-vs-method-variables-intro
// Совет для профессионалов: в объектно-ориентированном программировании функции которые является частью класса называются методы. Компоненты — это классы, поэтому мы называем функции внутри них тоже методами.

//TODO: Class vs Method Variables (Класс против переменных метода)
// Давайте добавим некоторый код в наш метод speak(), чтобы увидеть, как переменные экземпляра и переменные метода выглядят на практике:
// См. Рис: Class vs Method Variables.png
// префикс и имя переменных являются переменными класса. Они принадлежат классу. Внутри метода speak(), если мы хотим вызвать членов класса, мы должны использовать ключевое слово (this). Также обратите внимание, что внутри метода speak() мы используем ключевое слово const для объявления переменной sentence (предложение). Внутри методов вы должны использовать ключевое слово, такое как var, let или const, для объявления переменных. Мы выбрали const, потому что ключевые слова const объявляют значение, которое является константой и не изменится.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-class-vs-method-variables?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-class-vs-method-variables

//TODO: Iterating through String Arrays (Итерация по массивам строк)
// С Angular, отмеченным в коде как ng, мы можем использовать команду *ngFor в файле HTML (представление) для перебора массивов, объявленных в компоненте. Учитывая этот массив в компоненте Angular:
// TypeScript (TS):
// colors: string[] = ['red', 'blue', 'green', 'purple'];
// Мы можем перебирать цвета в сопроводительном HTML-файле в Angular следующим образом:
// HTML:
{
  /* <div *ngFor='let color of colors'> 
  {{ color }} 
</div> */
}
// Результат в вашем браузере будет выглядеть следующим образом:
// red (красный)
// blue (синий)
// green (зеленый)
// purple (фиолетовый)
// Где каждый из цветов, красный, синий, зеленый и т.д. заключен в div. *ngFor по существу создает цикл, в котором html-тег, объявленный внутри циклов, повторяется столько раз, сколько элементов в вызываемом массиве.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-ngfor-looping?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-ngfor-looping
// *ngFor — это структурная директива. Структурные директивы изменяют HTML в соответствии с переменными данными, с которыми они связаны.

//TODO: Iterating with Indices (Итерация с индексами)
// Иногда полезно при переборе массива иметь доступ к индексу в каждой итерации цикла. Вот как мы это делаем в Angular:
// HTML:
{
  /* <div *ngFor='let fruit of fruits; let i=index'>
   Fruit {{ i }} is {{ fruit }} 
</div> */
}
// Результат в вашем браузере будет выглядеть следующим образом:
// Fruit 0 is apple
// Fruit 1 is orange
// Fruit 2 is pear (груша)
// Fruit 3 is peach (персик)
// Обратите внимание, что наша переменная-итератор называется i. Эта переменная может называться как угодно; мы просто использовали букву i из-за условности. Ключевое слово index нельзя изменить. Angular знает, что index — это индекс каждой итерации, когда мы перебираем массив.
// Попробуйте на StackBlitzL:
// https://stackblitz.com/edit/angular-indices?file
// Посмотреть на Github:
// https://github.com/SoloLearn-Courses/angular-indices
// Индексы во время итерации полезны при повторении списков вещей, таких как элементы корзины покупок, которые связаны с идентификаторами базы данных из серверной части. Мы вернемся к этому позже в курсе! Подожди!

//TODO: Iterating through Custom Types (Перебор пользовательских типов)
// Теперь мы соединим то, что вы узнали об интерфейсах, с нашим механизмом циклов *ngFor. Давайте создадим интерфейс для автомобиля и поместим его в отдельный файл с именем car.ts ( .ts — это расширение файлов TypeScript) .
// TypeScript (TS):
// export interface Car {
//   make: string;
//   model: string;
//   miles: number;
// }
// Теперь, когда у нас есть интерфейс Car, мы можем импортировать этот интерфейс в наш компонент как таковой:
// TypeScript (TS):
// import { Car } from './car';
// Теперь мы можем создать 3 объекта типа Car:
// TypeScript (TS):
// subaru: Car = {make: 'Subaru', model: 'Outback', miles: 58232};
// honda: Car = {make: 'Honda', model: 'Accord', miles: 39393};
// bmw: Car = {make: 'BMW', model: 'X3', miles: 4400};
// cars:Car[ ] = [this.subaru, this.honda, this.bmw];
// И, наконец, мы можем просмотреть все наши автомобили в файле HTML:
{
  /* <div *ngFor="let car of cars">
   {{car.make}} {{car.model}}  with a mileage of {{car.miles}}
</div> */
}
// Вот наш вывод:
// Subaru Outback with a mileage of 58232
// Honda Accord with a mileage of 39393
// BMW X3 with a mileage of 4400
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-loop-thru-custom-type?file=src%2Fapp%2Fapp.component.ts
// Когда вы перебираете пользовательский тип, например Car в данном случае, вы должны использовать точечную нотацию (car.make, car.model, car.miles и т.д.) для доступа к элементам этого объекта, поскольку интерфейсы состоят из различных полей, похожие на объект JavaScript.

//TODO: Data's Long Journey (Долгий путь данных)
// На предыдущем уроке мы создали список типов автомобилей в компоненте для циклического просмотра. Это нормально для локальных данных, которые жестко закодированы в компоненте, но в реальных бизнес-примерах данные проходят очень долгий путь, прежде чем они, наконец, достигают нашего представления. Используя нашу предыдущую аналогию с рестораном из Модуля 1, давайте посмотрим на долгий путь, который данные проделывают в реальном мире, прежде чем они попадут к нам:
// См. Рис: Data's Long Journey.png
// по мере того, как мы углубляемся в стек в этом курсе, мы будем продолжать перемещать данные возвращаться все дальше и дальше в стеке, пока мы, наконец, не получим его из базы данных. Наш следующий шаг — переместить данные из компонента в нечто, называемое сервисом, которые мы рассмотрим очень скоро в следующих частях этого урока. Упрощенный типичный поток данных от конца к началу будет выглядеть следующим образом:
// 1. Data retrieved from database query (Данные, полученные из запроса к базе данных)
// 2. Data routed through server (Данные, маршрутизируемые через сервер)
// 3. Data reaches service (Данные достигают сервиса)
// 4. Data reaches component (Данные достигают компонента)
// 5. Data reaches view (Данные достигают представления)
// Базы данных чаще всего являются местом, где хранятся данные для веб-приложений. Мы в конце концов доберемся туда. Оставайтесь вовлеченными!

//TODO: Introduction to Angular Services (Введение в сервисы Angular)
// Сервисы — это специальные файлы в Angular, которые используются для управления данными. Обычно они извлекают данные из XHR (помните запросы XML/HTTP из Модуля 1?), но они также могут хранить данные самостоятельно. Помните нашу диаграмму о долгом путешествии данных? На данный момент мы не проходим весь путь до базы данных, чтобы получить данные. Мы собираемся просто отправить данные обратно в сервис и оставить их там на данный момент. На этой диаграмме показан простой поток между компонентом, сервисом с данными и представлением HTML.
// См. Рис: Introduction to Angular Services.png
// 1. Компонент cars вызывает транспортный сервис (service), которая содержит список автомобилей
// 2. Транспортный сервис (service) возвращает список автомобилей компоненту cars
// 3. Представление (view) cars получает список автомобилей и перебирает их, используя *ngFor
// Сервис похож на brain (мозг) в приложении Angular, который либо возвращает данные из самого сервиса, либо данные, полученные из внешнего источника (external source). Его можно рассматривать как «data manager».

//TODO: Generating an Angular Service (Создание сервиса Angular)
// Давайте сделаем Angular-сервис. Angular может сгенерировать сервис для вас с помощью простой команды, поэтому вам не нужно помнить, как построить базовую структуру. Для этого мы используем эту команду в компьютерном терминале:
//TODO:    cd my-app
//TODO:    ng generate service transportation
// Это создает пустой сервис в приложении Angular.
// TypeScript (TS):
// import { Injectable } from '@angular/core';
// @Injectable({
//   providedIn: 'root'
// })
// export class TransportationService {
//   constructor() { }
// }
// Нас будут интересовать только две части этого сервиса:
// 1. Верхняя часть файла, в которой находятся импортированные данные. Сюда мы будем импортировать файлы, которые будет использовать сервис.
// 2. Тело класса, где говорится об экспорте класса TransportationService.
// Тело класса заключено в фигурные скобки после слова TransportationService.
// Методы в теле класса сервиса используются для экспорта данных из сервиса.

//TODO: Import Interface into a Service (Импорт интерфейса в сервис)
// Наш транспортный сервис будет содержать множество типов автомобилей. Для этого нам нужно импортировать наш автомобильный интерфейс, который мы создали ранее. Мы узнали, что верхняя часть файла — это место, куда мы импортируем вещи. Мы можем добавить эту строку в верхнюю часть транспортного сервиса:
// TypeScript (TS):
// import { Car } from './car';
// Это позволяет нам использовать тип Car для создания массива Cars. Наш транспортный сервис теперь ИМПОРТИРУЕТ интерфейс из файла car.ts. Вот связь между этими двумя файлами:
// См. Рис: Import Interface into a Service.png
// файл car.ts ЭКСПОРТИРУЕТ интерфейс, а транспортный сервис ИМПОРТИРУЕТ тот же самый интерфейс для использования. Теперь это позволит нам создать массив типов автомобилей в нашем сервисе.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-service-imports-interface?file
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-service-imports-interface
// Функциональность импорта/экспорта, которую мы видим в Angular, получена из NodeJS. Эта же система импорта/экспорта встречается почти во всех интерфейсных JavaScript-фреймворках, поскольку большинство этих фреймворков построены с использованием Node.

//TODO: Recreating Car Array in a Service (Воссоздание массива автомобилей в сервисе)
// Теперь, когда мы импортировали ресурс автомобиля, мы можем создать массив типов автомобилей в нашем транспортном сервисе. Последнее, что нам нужно сделать после этого, — это создать метод getCars() для экспорта данных об автомобиле из сервиса. Вот готовый service:
// TypeScript (TS):
// import { Injectable } from '@angular/core';
// import { Car } from './car';

//  @Injectable({
//   providedIn: 'root'
//  })
//  export class TransportationService {
//   // NEW CODE
//   subaru: Car = {make: 'Subaru', model: 'Outback', miles: 58232};
//   honda: Car = {make: 'Honda', model: 'Accord', miles: 39393};
//   bmw: Car = {make: 'BMW', model: 'X3', miles: 4400};

//   cars:Car[] = [this.subaru, this.honda, this.bmw];

//   constructor() { }

//   // NEW CODE
//   getCars() {
//     return this.cars;
//   }
//  }
// Теперь этот сервис готов к использованию нашим компонентом.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-service-completed?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-service-completed
// Сервисы экспортируют методы, которые позже будут вызываться компонентами Angular, использующими сервис. Один сервис может использоваться несколькими компонентами.

//TODO: Dependency Injection (Внедрение зависимости)
// Теперь, когда наш сервис фактически экспортирует данные, наш компонент должен их загрузить. В Angular мы используем нечто, называемое внедрением зависимостей, для переноса сервиса в компонент. Теперь этот сервис готов к использованию нашим компонентом. Вот как это выглядит:
// См. Рис: Dependency Injection.png
// Dependency injection (Внедрение зависимостей) — распространенный шаблон проектирования в объектно-ориентированном программировании.
// Думайте о внедрении зависимостей, как об установке погодного приложения на свой телефон. Каждый телефон, на котором установлено приложение погоды, получает одно и то же приложение. Его можно установить на несколько телефонов, и каждый телефон, который нажимает кнопку «получить погоду» для города, получит одну и ту же погоду. Сервис погоды является центральным сервисом, предоставляющим данные всем, кто на него подписан. Это то, что сервис делает посредством внедрения зависимостей. Обычно он предоставляет данные всем своим подписчикам вместе с другими функциями.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-service-dependency-injection?file
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-service-dependency-injection
// Обратите внимание, как мы создаем частную переменную с именем transportService, имеющую тип TransportationService. transportService (со строчной буквой t) — это переменная, а TransportationService (с прописной буквой T) — это тип. Эти два соглашения об именах называются camelCase и PascalCase соответственно. Использование camelCase для переменных класса и PascalCase для имен классов и интерфейсов является соглашением, встречающимся во всем Angular.

//TODO: Event Binding (Привязка событий)
// До этого момента мы в основном считывали данные в Angular и выводили их на экран. Что, если бы мы действительно захотели изменить какие-то данные или отреагировать на пользовательские события? Вот где в игру вступает привязка событий Angular. События на основе браузера в Angular обычно привязаны к методам в соответствующих компонентах. Вот пример кнопки, которая вызывает оповещение.
// HTML: app.component.html
{
  /* <button (click)="saySomething()"> Say Something </button> */
}
// TypeScript (TS): app.component.ts
// saySomething() {
//   alert('good day.');
// }
// Давайте разберем этот код.
// HTML:
{
  /* <button (click) = "saySomething()" > Say Something </button> */
}
// Здесь мы вставили обработчик нажатия на кнопку, который срабатывает всякий раз, когда происходит событие нажатия. Это запускает метод "saySomething()" в компоненте. В Angular скобки вокруг обработчика событий в теге html обозначают то, что мы называем event binding (привязкой события). В этом случае «click» заключен в круглые скобки (click), что связывает это событие с методом, переданным в кавычках, то есть «saySomething()». В Интернете происходит много других типов событий: click (щелчок), change (изменение), mouseover (наведение мыши), hover (наведение), dragover (перетаскивание), etc (и т.д.) — все это примеры событий, которые являются результатом действий пользователя. Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-simple-event?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-simple-event
// Обратите внимание, что вы должны использовать () после saySomething() для запуска метода в соответствующем файле app.component.ts. Это связано с тем, что Angular не только привязывает действие к событию, но и запускает событие при нажатии, аналогично в контексте выполнения собственному методу вызова JavaScript. () после метода символизирует запуск события после нажатия этой кнопки.

//TODO: Making a Counter (Создание счетчика)
// Наше следующее упражнение — это пример использования событий щелчка для увеличения счетчика. Когда вы нажимаете на кнопку, счетчик увеличивается.
// Как вы понимаете, нам нужна кнопка с событием клика в представлении, которое привязано к соответствующему методу в компоненте: app.component.html.
// HTML: app.component.html
{
  /* <div class="container">
  <div class="number-display">
    {{counter}}
  </div>
    <button (click)="increment()"> increment </button>
 </div> 
</div> */
}
// TypeScript (TS): app.component.ts
// counter = 0;
// increment() {
//   this.counter++;
// }
// В представлении HTML внутри тега <button> находится метод (щелчок). Это отправляет команду компоненту для запуска метода increment(). Центром функциональности здесь является переменная counter. При нажатии кнопки counter увеличивается. Результат отображается в представлении, потому что {{ counter }} всегда будет содержать обновленное значение переменной counter по мере его увеличения с помощью кликов.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-counter-increment?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-counter-increment
// События дополнительно демонстрируют тесную связь между файлами представления и компонентами.

//TODO: Event Updating a String (Событие, обновляющее строку)
// Попробуем другое упражнение: мы хотим обновить строку событием. В этом примере каждый раз, когда мы нажимаем кнопку, к существующей строке будет добавляться еще несколько слов. Строка будет начинаться со слов «Please», и каждый раз, когда мы нажимаем на кнопку, в конец строки будут добавляться слова «...Пошёл Ты»:
// HTML: app.component.html
{
  /* <div class="display">
  {{phrase}}
</div>
<button (click)="update()"> click me </button> */
}
// TypeScript (TS): app.component.ts
// phrase = "Please";
// update() {
//   this.phrase+=" ...Пошёл Ты";
// }
// Опять же, у нас есть кнопка, связанная с методом, который срабатывает в компоненте. Компонент имеет переменную под названием «phrase», которая начинается всего с двух слов: «Please». Однако каждый раз, когда вы нажимаете кнопку, запускается метод update(), и знак += в этом выражении заставляет компонент добавлять « ...Пошёл Ты» в конец предыдущей фразы. В результате фраза становится все длиннее, длиннее и длиннее каждый раз, когда мы нажимаем кнопку. Это лучше видно в действии! Либо посетите код StackBlitz в режиме онлайн, либо просмотрите на GitHub, чтобы увидеть, как это работает. Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-event-update-string?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-counter-increment
// События являются основной частью любого проекта Angular. На самом деле, события действительно являются ключевыми для всех фреймворков TypeScript и JavaScript и большинства приложений, использующих JavaScript в целом.
//TODO: TASK: Кнопка будет удваивать целое число при каждом нажатии кнопки.
// TypeScript (TS): app.component.ts   COMPONENT:
// counter = 1;
// double() {
// this.counter*=2;
// }
// HTML: app.component.html   VIEW:
// {{counter}}
// <button (click) = "double()" > double the number </button>

//TODO: One Way Data Binding (Односторонняя привязка данных)
// Вы часто будете слышать, как разработчики говорят об «one way data binding» и «two way data binding», когда речь идет о  front-end JavaScript-фреймворках. Что такое привязка данных? Привязка данных описывает поток данных от component (компонента) к view (представлению). Во всех примерах привязки событий в предыдущем уроке использовалась односторонняя привязка данных.
// Давайте посмотрим на поток данных счетчика, чтобы проанализировать, как работает односторонняя привязка данных:
// См. Рис: One Way Data Binding.png
// 1. Пользователь нажимает кнопку в view (представлении). Событие (щелчок) связано с методом "increment()", запрашивая у компонента запуск метода с тем же именем increment() {this.counter++}.
// 2. Компонент получает событие click и запускает метод increment() {this.counter++}, который обновляет counter (счетчик).
// 3. Переменная counter (счетчика) в компоненте обновляется, а затем отправляет это обновленное значение в view (представление).
// 4. view (представление) получает обновленную переменную {{counter}} (счетчика), а затем обновляет отображение, чтобы пользователь увидел появление нового числа.
// При односторонней привязке данные передаются в одном направлении. Представьте себе потолочный вентилятор. Несмотря на то, что лопасти движутся по кругу, движение по-прежнему происходит только в одном направлении.

//TODO: Two Way Data Binding (Двусторонняя привязка данных)
// Двусторонняя привязка данных — это когда поток данных между view (представлением) и component (компонентом) идет в обоих направлениях. Есть центральная «model» или variable container (переменный контейнер). Если он обновляется в view (представлении), компонент получает изменение. Если он обновляется в component (компоненте), то view (представление) получает изменение. Поток данных может идти в любом направлении. Когда был выпущен Angular 1 (AngularJS), одним из его ключевых преимуществ была врожденная способность выполнять двустороннюю привязку данных. С тех пор разработчики пришли к единому мнению, что двухстороннюю привязку данных следует использовать с осторожностью из-за высоких требований к системным ресурсам. При этом двусторонняя привязка данных по-прежнему возможна в Angular 8. Есть определенные ситуации, когда она может быть полезна при разумном использовании.
// В этом уроке мы реализуем простой виджет, который позволит вам видеть, что вы печатаете, отражаясь в представлении, когда вы печатаете это в режиме реального времени. Конечная цель состоит в том, что вы можете вводить текст в текстовое поле и видеть, что результат того, что вы набрали, сохраняется в модели, которая отображается в представлении.
// Модель — это контейнер, который содержит значение переменной. Модель доступна в component (компоненте) и связанном с ним view (представлении).

//TODO: Banana in a Box (Банан в коробке)
// Конструкция, допускающая двустороннюю привязку данных, выглядит так:
// HTML: app.component.html
{
  /* <input [(ngModel)] = "username"> */
}
// Конструкция [()] в Angular обеспечивает двустороннюю привязку данных. Некоторые разработчики называют это «бананом в коробке». На самом деле это комбинация квадратных скобок [ ], которые указывают на привязку данных из component (компонента) к view (представлению) («прямоугольник»), и круглых скобок ( ), которые включают привязку данных из view (представления) к component (компоненту) («банан»). Мы уже видели скобки в view (представлении) ранее:
// TypeScript (TS): app.component.ts
// button (click) = "increment()"
// В нашем примере <button (click) = "increment()"> (click) был примером односторонней привязки данных из view (представления) к component (компоненту). Квадратные скобки, с другой стороны, представляют поток данных от component (компонента) обратно в view (представление). Соединяя их вместе, Angular дает нам двунаправленный поток данных. «Банан в коробке».
// Модели Angular, реализованные через ngModel, не имеют ничего общего с базами данных или хранилищем на сервере. Модель в Angular временно хранит данные во внешнем приложении.

//TODO: ngModel (Angular Модель)
// Давайте посмотрим на схему двухсторонней привязки данных. Данные идут в двух направлениях. Когда вы вводите что-то в поле ввода в VIEW, он обновляет model  в COMPONENT, который затем отправляет обновленное значение model обратно в VIEW. Все это происходит почти мгновенно. Это возможно благодаря особому типу модели под названием ngModel. ngModel позволяет вам вводить поле и наблюдать, как значение этой переменной обновляется мгновенно по мере ввода.
// Вот код, который заставляет ngModel работать в view (представлении):
// HTML: app.component.html
{
  /* <input [(ngModel)]="username" placeholder="enter a username"> */
}
// См. Рис: ngModel.png
// В некотором смысле этот поток данных немного проще, чем диаграмма для односторонней привязки данных. Поиграйте с этим примером двусторонней привязки данных по предоставленной ссылке.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-two-way-data?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-two-way-data
// Angular использует конструкцию ngModel для хранения переменных, которые будут использоваться в двустороннем контексте привязки.

//TODO: ngModel Deconstructed (ngModel деконструированная)
// Давайте разберем, как на самом деле работает ngModel.
// 1. Пользователь вводит текст в поле, а затем содержимое этого поля сохраняется НЕПОСРЕДСТВЕННО в ngModel под названием «username».
// 2. Переменная «username», которая хранится в ngModel, хранится в компоненте.
// 3. view (представление), которое постоянно отслеживает изменения в ngModel, обновляет {{ username }}, чтобы оно соответствовало введенному пользователем. Все это происходит мгновенно. Модель можно рассматривать как просто контейнер, в котором хранится информация. Существует значительное количество теории о том, что это влечет за собой. О шаблонах MVC (model-view-controller) и MVVM (Model-View ViewModel) написано много. Не слишком углубляясь в теорию, мы можем просто сказать, что модель — это представление данных домена. Другими словами, во front-end модель представляет собой контейнер, в котором хранятся переменные. Когда мы печатали в поле ввода, содержимое поля ввода немедленно сохранялось в переменной username.
// Еще раз просмотрите StackBlitz:
// https://stackblitz.com/edit/angular-two-way-data?file=README.md
// View на GitHub:
// https://github.com/SoloLearn-Courses/angular-two-way-data
// ngModel содержит информацию, которую можно изменить и получить к ней доступ как в компоненте, так и в представлении.

//TODO: Two Way Data Bind Setup (Настройка двусторонней привязки данных)
// В этом разделе приведены инструкции по настройке двусторонней привязки данных на компьютере. Для целей этого курса FormsModule уже импортирован в примеры StackBlitz и GitHub. [(ngModel)] не будет работать из коробки в компоненте Angular. Чтобы это работало, мы должны предоставить поддержку для этого в компоненте. По умолчанию приложения относительно тонкие. Они включают только базовые функции, необходимые для большинства приложений. Двусторонняя привязка данных не потребуется в каждом отдельном приложении, поэтому по умолчанию ее нет в вашем проекте. Вы можете дать ему эту функциональность, импортировав модуль форм в ваш файл app.module.ts (или в любой другой модуль, в котором вы работаете). В вашем файле app.module.ts вы должны импортировать:
// TypeScript (TS): app.component.ts
// import { FormsModule } from '@angular/forms'
// А затем добавьте FormsModule к вашему импорту в app.module.ts. На приведенном ниже рисунке показано, как решаются эти две задачи.
// См. Рис: Two Way Data Bind Setup.png
// В примерах StackBlitz и GitHub мы импортировали для вас FormsModule, поэтому он уже настроен.

//TODO: Sending Hard Coded Data to a Service (Отправка жестко закодированных данных в сервис)
// Теперь, когда у нас есть представление о том, как мы можем вводить данные в текстовое поле и хранить их в модели, мы почти готовы отправить новые данные в наш массив cars. Для этого нам сначала нужно изучить, как сервис может получать данные, а не просто экспортировать данные. Давайте сделаем это сейчас. В нашем компоненте давайте добавим метод addCar(), который добавляет новый автомобиль в транспортный сервис. Этот метод может выглядеть так:
// TypeScript (TS): transport.service.ts
// addCar(car: Car){
//   this.cars.push(car);
// }
// Здесь наш метод addCar принимает автомобиль типа Car в качестве единственного аргумента. Затем он добавляет его к существующему массиву автомобилей. В нашем компоненте мы сделаем метод, который отправляет заранее собранный автомобиль в массив каждый раз, когда метод срабатывает:
// TypeScript (TS): app.component.ts
// addCar( ) {
//   const newCar: Car = {make: "Tesla", model: "X", miles: 100 };
//   this.transportationService.addCar(newCar);
// }
// Наконец, мы создадим кнопку в view (представлении), которая будет вызывать метод addCar():
// HTML: app.component.html
{
  /* <button (click)="addCar()">add Car</button> */
}
// Если вы когда-нибудь хотели новую Tesla, это ваш шанс! Мы написали код, чтобы мгновенно доставить новый к вашей двери! Вы получите автомобиль! И ВЫ получите машину!!!.... и т.д. Каждый раз, когда мы нажимаем кнопку, появляется новая Тесла.
// См. Рис: Sending Hard Coded Data to a Service.gif
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-send-static-data-to-service?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-send-static-data-to-service
// Сервисы могут отправлять и получать данные от компонентов.

//TODO: Sending Dynamic Data to a Service (Отправка динамических данных в сервис)
// Теперь мы собираемся сделать последний шаг, чтобы связать все воедино с точки зрения добавления автомобилей в наш сервис данных. В реальном мире мы редко отправляем «жестко закодированные» данные в ресурс данных! Нам нужен механизм, который позволит нам вводить ЛЮБУЮ информацию об автомобиле и обновлять ее в нашем массиве автомобилей. Мы добьемся этого сейчас. Мы можем сохранить соответствующие методы addCar как в транспортном сервисе, так и в компоненте. Единственным изменением будет сбор данных о марке, модели и пробеге нового автомобиля в 3 новых ngModels, а затем замена жестко закодированных данных нашими реальными данными. Вот и все! Начнем с компонента:
// TypeScript (TS): app.component.ts
// мы бы добавили эти переменные в наши объявления переменных:
// declarations:
// make: string;
// model: string;
// miles: number;
// А затем измените назначение переменной newCar в нашем методе addCar в компоненте, чтобы он использовал наши новые динамические переменные (марка, модель и мили)…
// TypeScript (TS): app.component.ts
// const newCar: Car = {make: this.make, model: this.model, miles: this.miles };
// Наконец, мы добавим в представление поля ввода для марки, модели и пробега.
// HTML: app.component.html
{
  /* <input [(ngModel)]="make" placeholder="make">
<input [(ngModel)]="model" placeholder="model">
<input type="number" [(ngModel)]="miles" placeholder="miles"> */
}
//И теперь код должен просто работать! Когда вы вводите марку, модель и пробег нового автомобиля и нажимаете кнопку, он отправляется в наш поток данных и обновляется в сервисе, который затем обновляет view (представление), и все наши новые автомобили появляются по мере их создания. Попробуй сам! Поэкспериментируйте с кодом и даже удалите некоторые из них и попытайтесь перестроить его самостоятельно, чтобы получить представление об этом потоке данных. Наш следующий шаг — узнать, как подключить приложение Angular к реальному BACK-END, чтобы данные могли сохраняться в базе данных! Оставайтесь в курсе.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-send-dynamic-data-to-svs?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-send-dynamic-data-to-svs
// На странице может быть сколько угодно ngModels. Это быстрый и простой способ сбора данных для отправки в наш сервер.

//TODO: Introduction (Вступление)
// Добро пожаловать в модуль Базы данных. В этом модуле мы рассмотрим причины, по которым мы используем базы данных, а также продемонстрируем два наиболее распространенных типа баз данных. Мы рассмотрим relational database (реляционную базу данных) (PostgreSQL) и non-relational database (нереляционную базу данных) (MongoDB). Реляционные базы данных хранят данные в таблицах и строках, а нереляционные базы данных хранят данные в коллекциях. В этом модуле мы будем сравнивать эти два типа баз данных. Каждый тип базы данных служит различным вариантам использования. Мы собираемся пройтись по каждому и выделить преимущества использования того или другого. Давайте начнем с вопроса, на который мы надеемся получить ответ к концу этого урока. Если бы вам нужно было хранить информацию для приложения, как бы вы это сделали?
// Существует два распространенных типа баз данных: реляционные и нереляционные.

//TODO: Volatile vs Non-volatile Storage (Энергозависимое и энергонезависимое хранилище)
// «Если бы вам нужно было хранить информацию для приложения, как бы вы это сделали?» Первым вашим побуждением здесь может быть использование переменной. Вы уже использовали переменные для хранения информации для приложения, так что это кажется логичным выбором! Однако есть одно место, где переменные терпят неудачу. Когда мы создаем приложение, мы хотим, чтобы наша информация сохранялась, то есть мы хотим, чтобы она оставалась там после перезапуска нашего приложения. При повторном запуске приложения все переменные сбрасываются. Это означает, что мы не можем использовать переменные как способ долгосрочного хранения информации. Мы можем использовать их только для временного удержания ценностей. Переменные хранятся в Volatile storage (энергозависимом хранилище) (или памяти). Нам нужно хранить нашу важную информацию в Non-volatile storage (энергонезависимом хранилище), чтобы он сохранялся даже при перезапусках или сбоях. Это дыра, которую заполняют базы данных. Они хранят информацию в Non-volatile storage (энергонезависимом хранилище), поэтому она сохраняется при перезапусках или сбоях.
// Volatile storage (Энергозависимое хранилище) не сохраняется при перезапуске (например, переменные), тогда как non-volatile storage (энергонезависимое хранилище) сохраняется при перезапуске (например, файлы, хранящиеся на жестком диске).

//TODO: Other Benefits of Modern Databases (Другие преимущества современных баз данных)
//   Скорость поиска:
// Базы данных способны очень быстро выполнять поиск в больших объемах информации. Это еще одна причина, по которой мы используем их, а не просто помещаем все наши данные в один большой файл.
//   Согласованность данных:
// Реляционные базы данных также дают нам преимущество хранения информации в согласованных форматах, что упрощает написание программ. Например, при хранении информации о пользователе в реляционной базе данных мы всегда можем хранить одни и те же значения, такие как «имя» или «электронная почта», что позволяет очень легко писать логику позже. Нереляционные базы данных позволяют вставлять любую информацию без строгого форматирования, что отлично подходит для быстрого прототипирования.
// Двумя преимуществами баз данных являются точность и совместная работа. Данные сохраняются только один раз, что исключает дублирование данных, и несколько пользователей могут одновременно обращаться к базе данных, что делает ее инструментом для совместной работы.

//TODO: Storing a User (Сохранение пользователя)
// Представьте, что мы хотим хранить информацию о пользователе. Мы хотим сохранить их имя, адрес электронной почты и возраст. Учитывая то, что вы знаете сейчас, как бы вы это сохранили? Если вы использовали какое-либо программное обеспечение для работы с электронными таблицами, вы можете подумать о сохранении информации в какой-либо электронной таблице. Где у вас есть столбцы для имени, электронной почты и возраста, а затем в каждой строке вы храните другого пользователя. Вы также можете рассмотреть объекты JavaScript как хороший способ их хранения. Хранение каждого пользователя в виде отдельного объекта с парами ключ/значение для имени, электронной почты и возраста также кажется хорошим подходом. Оказывается, эти подходы — отличный способ подумать о наших двух разных типах баз данных. Реляционные базы данных хранят информацию в виде таблицы со столбцами и строками, аналогичной электронной таблице.
// нереляционные базы данных хранят информацию в формате JSON, как показано ниже, который очень похож на объект JavaScript.
// JSON:
// {
//   "name": "dave",
//   "email": "dave@sololearn.com",
//   "age": 25
// }
// Реляционные базы данных хранят информацию в столбцах и строках, где каждая строка представляет запись. Нереляционные базы данных хранят информацию в парах key value (ключ-значение).

//TODO: The SQL (relational) Approach (SQL (реляционный) подход)
//  Tables (Таблицы):
// В реляционной базе данных, такой как postgreSQL, мы храним нашу информацию в таблицах. Каждый ресурс (или часть данных для вашего приложения, таких как пользователи, сообщения, комментарии и т.д.) обычно получает свою собственную таблицу. Например, если мы создаем приложение для социальных сетей, у нас, вероятно, будет таблица для пользователей, таблица для сообщений и таблица для комментариев.
//  Columns (Столбцы):
// В таблице есть столбцы для каждого поля информации, которую нам нужно сохранить. Для нашего пользовательского примера у нас будет столбец имени, столбец электронной почты и столбец возраста.
//  Rows (Строки):
// Каждая строка в таблице представляет одну запись в этой таблице. Например, каждая строка в нашей пользовательской таблице будет другим пользователем, содержащим имя этого пользователя, адрес электронной почты и возраст.
// См. Рис: The SQL (relational) Approach
// Реляционные базы данных состоят из таблиц, в которых столбцы определяют, какую информацию мы храним, а строки хранят эту информацию для каждой записи.

//TODO: The noSQL (non-relational) Approach (NoSQL (нереляционный) подход)
//  collections (Коллекции):
// В нереляционной базе данных мы храним нашу информацию в коллекциях. Каждый ресурс обычно получает свою собственную коллекцию. Основное различие между коллекцией и таблицей заключается в отсутствии понятия столбцов. Мы можем хранить любую информацию, которую захотим, в коллекции. Мы могли бы сохранить одного пользователя с именем и фамилией, а другого только с именем.
// { name: "james smith" }
// // or
// { firstName: "james", lastName: "smith" }
//  documents (Документы):
// Документы — это JSON-подобные объекты. Каждый документ может содержать несколько полей (пары ключ/значение), а значением поля может быть практически любой тип данных JavaScript. Ниже вы можете увидеть пример документа из документации mongoDB (база данных noSQL, на которой мы сосредоточимся).
// См. Рис: The noSQL (non-relational) Approach.png
// Каждый документ может содержать несколько полей (пары ключ/значение), а значением поля может быть практически любой тип данных JavaScript.

//TODO: Example Use Cases (Примеры использования)
// Когда использовать реляционную базу данных
// Реляционные базы данных проверены временем. SQL 48 лет! Они обеспечивают очень строгую структуру для ваших данных. Это делает их очень хорошими для больших приложений, которым необходимо масштабировать и поддерживать большой объем данных или пользователей. Строгая структура ваших данных позволяет легко поддерживать согласованность и значительно упрощает написание кода для ваших приложений. Когда использовать нереляционную базу данных Нереляционные базы данных относительно новы на сцене баз данных. Они не применяют строгую структуру к вашим данным, что может затруднить масштабирование и работу с более крупными проектами. Однако гибкость и более быстрое время настройки позволяют очень быстро повторять идеи. Нереляционные базы данных идеально подходят для небольших проектов или проверки концепций.
// Реляционные базы данных отлично подходят для больших сложных приложений, тогда как нереляционные базы данных отлично подходят для небольших проектов проверки концепции.

//TODO: What is SQL (Что такое SQL)
// В этом модуле мы обсуждали реляционные и нереляционные базы данных и то, что делает их уникальными. Вы также можете услышать, как они называются базами данных SQL и NoSQL. Но что такое SQL? SQL означает Structured Query Language (язык структурированных запросов), и это язык программирования, который мы используем для связи с базами данных SQL. Это язык запросов, состоящий из множества ключевых слов, которые позволяют нам указывать нашей базе данных, что делать с данными.
// В этом модуле мы рассмотрим PostgreSQL. Если вы хотите узнать больше о другой реляционной базе данных, посмотрите наш курс по MySQL.

//TODO: Creating Tables (Создание таблиц)
// База данных SQL состоит из нескольких таблиц. Каждая таблица должна содержать данные для одного ресурса вашей программы. Мы хотим создать таблицу для хранения наших пользовательских данных (имя, адрес электронной почты и возраст). Давайте посмотрим, как мы могли бы сделать это в SQL.
// SQL:
// CREATE TABLE users (id SERIAL, name TEXT, email VARCHAR(255), age INT);
// Давайте начнем с рассмотрения нескольких основных принципов SQL. Во-первых, каждое выражение в SQL должно заканчиваться точкой с запятой. Во-вторых, по соглашению весь синтаксис SQL должен быть прописным, а любой определяемый вами синтаксис — строчным. Это означает, что CREATE TABLE является частью языка SQL, а users — это имя, которое мы определяем.
// Как и в JavaScript, в SQL есть типы данных, которые позволяют нам определять, какие типы информации мы будем хранить в каждом столбце.

//TODO: Data Types (Типы данных)
// Давайте продолжим рассмотрение нашего примера CREATE TABLE из предыдущей части.
// SQL:
// CREATE TABLE users (id SERIAL, name TEXT, email VARCHAR(255), age INT);
// Как и в JavaScript, в SQL есть типы данных. В нашем примере создания таблицы выше мы создаем 4 столбца с типами данных SERIAL, TEXT, VARCHAR(255), INT.
// 1). Тип данных SERIAL — это целое число, которое будет автоматически увеличиваться для каждой новой добавляемой строки. Это означает, что у нас будет уникальный идентификатор для каждой строки в нашей таблице!
// 2). Тип данных TEXT просто означает, что мы храним текстовые данные или строки в этом столбце.
// 3). Тип данных VARCHAR(255) означает переменный символ и также используется для хранения текстовых данных или строк. Основное отличие состоит в том, что мы можем определить ограничение на количество сохраняемых символов (в нашем случае мы ограничиваем его до 255 символов VARCHAR (255) ).
// 4). Наконец, тип данных INT позволяет хранить целые числа. Есть много других типов данных SQL, которые мы не собираемся здесь рассматривать. Если вам нужно сохранить определенный тип информации, посмотрите, какой тип данных лучше всего подходит для вашего случая использования.
// Как и в JavaScript, в SQL есть типы данных, которые позволяют нам определять, какие типы информации мы будем хранить в каждом столбце.

//TODO: Inserting Entries (Вставка записей)
// Теперь, когда у нас есть таблица, мы хотим вставить в нее пользователя. Давайте посмотрим на фрагмент кода, который позволит нам это сделать.
// SQL:
// INSERT INTO users (name, email, age) VALUES ("james", "james@sololearn.com", 30);
// Помните, что любой синтаксис SQL написан в верхнем регистре. Здесь мы начинаем с INSERT INTO (ВСТАВИТЬ В), за которым следует users - имя таблицы, в которую мы хотим вставить. Затем мы указываем столбцы в этой таблице, которые мы хотим вставить (name, email, age). Затем мы указываем VALUES (ЗНАЧЕНИЯ), которые хотим вставить в эти столбцы. Важно отметить, что порядок здесь имеет значение. Мы указываем значения в том же порядке, в котором мы перечисляли столбцы. Вот почему мы видим сначала «james», так как мы хотим, чтобы оно было вставлено в столбец имени. После вставки записи наша таблица будет выглядеть примерно так:
// См. Рис: Inserting Entries.png
// В операторе Insert мы должны указать значения в том же порядке, в котором мы перечислили столбцы.

//TODO: Selecting Data (Выбор данных)
// Теперь, когда мы вставили строку, мы хотим иметь возможность выбирать наши строки из нашей таблицы, чтобы мы могли просматривать наши данные.
// SQL:
// SELECT id, name, email, age FROM users;
// В операторе SELECT мы сначала указываем нужные столбцы (id, name, email, age). Затем мы указываем, из какой таблицы мы хотим их получить, используя FROM. Поскольку на самом деле мы запрашиваем каждый столбец в таблице, мы можем использовать:
// SQL:
// SELECT * FROM users;
// вместо того, чтобы явно запрашивать идентификатор, имя, адрес электронной почты, возраст! Вот как могут выглядеть результаты:
// См. Рис: Selecting Data.png
// В операторе SELECT мы сначала указываем нужные столбцы (id, name, email, age). Затем мы указываем, из какой таблицы мы хотим их получить, используя FROM.

//TODO: Where Clauses (WHERE (где) пункты)
// Заявление, которое мы рассматривали ранее, собирает данные обо всех пользователях. Если мы хотим указать конкретное условие, мы можем использовать пункт WHERE!
// SQL:
// SELECT * FROM users WHERE id = 1;
// Это вернет нам данные о нашем пользователе с идентификатором 1. Мы также можем использовать пункт WHERE, чтобы указать более надежные условия. Например, если бы мы хотели получить всех пользователей старше 25 лет, мы могли бы сделать:
// SQL:
// SELECT * FROM users WHERE age > 25;
// Мы также можем связать несколько условий вместе, используя оператор AND:
// SQL:
// SELECT * FROM users WHERE age > 25 AND name = 'david';
// Предложения WHERE позволяют нам указать определенные условия, которым должны соответствовать наши строки, чтобы быть возвращенными.

//TODO: Updating Data (Обновление данных)
// Часто нам нужно изменить информацию в наших программах. Давайте посмотрим, как обновлять данные в SQL.
// SQL:
// UPDATE users SET name = 'troy', age = 35 WHERE id = 3;
// В нашем операторе обновления мы сначала указываем, какую таблицу мы хотим обновить. В нашем случае мы хотим обновить таблицу «users», поэтому мы говорим «UPDATE users». Далее мы указываем, какие столбцы мы хотели бы обновить и что мы хотим установить для них SET name = 'troy', age = 35. Наконец, мы указываем предложение WHERE, которое сообщает SQL, какую строку следует обновить. Без этого он обновит все записи. Так что будьте осторожны! Если мы хотим обновить несколько записей, мы можем сделать это, используя другое предложение WHERE:
// SQL:
// UPDATE users SET age = 42 WHERE age = 24;
// Это обновит ВСЕХ пользователей в возрасте 24 до 42 лет.
// Операторы UPDATE в SQL позволяют нам обновлять одну или несколько строк в зависимости от условия.

//TODO: Deleting Data (Удаление данных)
// Иногда данные необходимо удалить. Пользователь может их удалить, если мы можем счесть их бесполезным! Давайте посмотрим на пример.
// SQL:
// DELETE FROM users WHERE id = 3;
// Мы начинаем оператор удаления с DELETE FROM, за которым следует имя нашей таблицы (в нашем случае users). Далее очень важно указать пункт WHERE. Без указания пункта WHERE мы удалим каждую строку в нашей таблице. Если мы хотим удалить несколько записей, мы можем сделать это, используя другое предложение WHERE.
// SQL:
// DELETE FROM users WHERE name = 'david';
// Это удалит ВСЕХ пользователей с именем david. Будьте очень осторожны при использовании операторов удаления с пунктом WHERE, которые не нацелены на один конкретный идентификатор.
// Операторы DELETE позволяют нам удалить одну или несколько строк в таблице.

//TODO: noSQL (не только SQL)
//  Differences from SQL (Отличия от SQL):
// noSQL означает «не только SQL», что означает, что вы можете запрашивать его, используя несколько языков. На рынке есть несколько вариантов noSQL, но мы сосредоточимся на mongoDB. mongoDB не имеет концепции таблиц/столбцов/строк. Вместо этого мы создаем коллекции для хранения наших данных и документов внутри них.
//  Collections (Коллекции):
// Коллекции — это mongoDB, эквивалентные таблицам. Именно в них мы храним наши данные. Ключевое различие между таблицей и коллекцией заключается в том, что таблицы принудительно заполняют определенные столбцы для каждой строки. Коллекции не заботятся о том, что вы храните внутри них.
//  Documents (Документы):
// Документы выполняют ту же работу, что и строки в SQL. Например, если бы у нас была коллекция пользователей, у нас был бы один документ для каждого пользователя.
//  Fields (Поля):
// Думайте о полях как о парах ключ-значение в объекте JavaScript. Они похожи на столбцы в SQL, но основное отличие состоит в том, что поля не обязательно должны быть одинаковыми в коллекции.
// База данных NoSQL — это база данных, которая не использует SQL в качестве языка для запроса данных. У него нет понятия таблиц/столбцов/строк. Вместо этого мы создаем коллекции для хранения наших данных и документов внутри них.

//TODO: Creating & Inserting into Collections (Создание и вставка в коллекции)
// Когда мы использовали SQL, мы создавали таблицы, написав запрос CREATE TABLE. Причина, по которой мы это сделали, заключается в том, что нам нужно было определить столбцы и типы данных, которые будут содержаться в таблице. Однако в mongoDB коллекции могут содержать любые данные! В результате нам не нужно явно создавать их. Вместо этого они будут созданы автоматически. Давайте начнем с рассмотрения объекта JavaScript, который мы хотим вставить в коллекцию пользователей.
// { name: "james", email: "james@sololearn.com", age: 28 }
// Мы можем вставить объект в коллекцию с помощью оператора insertOne() .
// db.usersCollection.insertOne()
// Здесь наш оператор начинается с db.usersCollection. Вы можете спросить себя… Откуда это взялось?! Это часть магии mongoDB. Если коллекция не существует, она будет автоматически создана при первой вставке в нее. Мы следуем за нашей коллекцией пользователей с помощью .insertOne(), куда мы помещаем объект, который хотим вставить!
// db.usersCollection.insertOne({
//   name: "james",
//   email: "james@sololearn.com",
//   age: 28,
// })
// Это вставит наш исходный объект в usersCollection. Этот исходный объект теперь является документом mongoDB! Mongo также позволяет нам вставлять другие типы данных, такие как массивы! Например, мы можем вставить список любимых фруктов наших пользователей!
// db.usersCollection.insertOne({
//   name: "james",
//   email: "james@sololearn.com",
//   age: 28,
//   favoriteFruits: [ "apples", "grapes"]
// });
// В mongoDB, если коллекция не существует, она будет автоматически создана при первой вставке в нее. Мы можем вставить любой документ в коллекцию.

//TODO: Selecting Documents (Выбор документов)
// Мы только что вставили пользователя в нашу коллекцию пользователей. Как нам вернуть эти данные?
// db.usersCollection.find({ name: "james"})
// Подобно синтаксису вставки, мы начинаем с db.usersCollection, чтобы сообщить mongoDB, какую коллекцию мы запрашиваем. После этого мы делаем .find() и указываем запрос, который мы хотим найти в mongoDB. В нашем случае мы хотим найти документ с именем «james». Это вернет нам документ, который выглядит примерно так:
// {
//   _id: ObjectId("5099803df3f4948bd2f98391"),
//   name: "james",
//   email: "james@sololearn.com",
//   age: 28
// }
// Вероятно, это похоже на то, что вы ожидаете от документа, за исключением одного… Что такое _id ? Мы никогда не вставляли это?! Как мы обсуждали на уроке SQL, наличие уникального идентификатора для записей очень полезно. Настолько полезно, что mongoDB будет автоматически генерировать один для каждого документа.
// Если вы запрашиваете коллекцию MongoDB и вам нужно указать несколько условий, вы можете передать несколько пар ключ-значение в метод поиска. .find() будет использовать каждую пару ключ-значение как условие, которое должно соответствовать запросу.
// db.collectionName.find({name: "james", age: 23})

//TODO: Updating Documents (Обновление документов)
// Обновление документов в mongoDB начинается очень похоже на выбор документов. Нам нужно указать запрос, чтобы мы не обновляли все подряд. Давайте углубимся в пример:
// db.usersCollection.update(
//   { name: 'james' },
//   {
//     $set: {
//       age: 45,
//     },
//   }
// )
// Оператор обновления начинается с того, что мы указываем, какую коллекцию мы хотели бы обновить. Затем мы запускаем наш .update(). Первое, что мы должны определить, это параметр запроса. Вот как мы говорим монго, что нужно найти и обновить. В нашем случае это { name: "james" }. Далее мы говорим mongo, что нужно обновить. Мы делаем это с помощью операторов mongoDB. В mongoDB много операторов, но мы сосредоточимся только на том, который используем здесь. Мы используем $set, чтобы сообщить mongoDB, какие поля необходимо обновить и какое значение для них установить (в нашем случае возраст установлен на 45).
// При обновлении документа мы используем $set, чтобы сообщить MongoDB, какие поля необходимо обновить и какое значение для них установить.

//TODO: Deleting Documents (Удаление документов)
// Удаление документов в mongoDB просто требует условия для запроса. Мы рассмотрим пример .deleteOne(), но есть и .deleteMany(), если вам нужно удалить несколько документов.
// db.usersCollection.deleteOne({ _id: ObjectId('5099803df3f4948bd2f98391') })
// Здесь мы говорим mongoDB удалить документ с _id, который мы нашли при запросе нашего пользователя в предыдущей части. Вообще говоря, вы хотите использовать _id при удалении документов. Это делается для того, чтобы вы могли избежать случайного удаления информации. Вы можете удалить не того Джеймса!
// При удалении документа в mongoDB мы можем вызвать .deleteOne() для удаления одного документа или .deleteMany() для удаления нескольких.

//TODO: What is an ORM (Object Relational Mapping) (Что такое ОРМ (объектно-реляционное отображение))
//  ORMs:
// ORM (Object Relational Mapping) (объектно-реляционное отображение) — это метод, который позволяет вам взаимодействовать с базой данных, используя объектно-ориентированный шаблон. Часто, когда мы говорим об ORM, мы используем этот термин для описания библиотеки, реализующей объектно-реляционное отображение (отсюда и «ORM»).
//  Advantages of ORMs (Преимущества ORMs):
// ORMs сопоставляют наши записи базы данных с объектами, которые мы определяем. Это позволяет нам написать много повторно используемой логики для нашей базы данных. Это также упрощает многие наши более сложные запросы и может уменьшить раздувание нашей кодовой базы. Большинство ORM также имеют встроенную защиту от SQL-инъекций.
//  Disadvantages of ORMs (Недостатки ORMs):
// ORMs не идеальны для каждого проекта. Часто у вас не будет прямого контроля над SQL, который ORM использует под капотом. Иногда это может сделать запросы медленнее, чем если бы вы писали их вручную. ORM также более подвержены ошибкам, чем SQL. Легче случайно создать функцию, которая запрашивает базу данных 200 раз в ORM по сравнению с SQL, поскольку вы не всегда можете понять, когда функция запускает запрос. Хотя в этом модуле мы не обсуждаем NoSQL, существует множество доступных ORM NoSQL!
// ORM (Object Relational Mapping) — это метод, который позволяет вам взаимодействовать с базой данных, используя объектно-ориентированный шаблон.

//TODO: Communicating with a Database (Взаимодействие с базой данных)
// Чтобы наши программы могли хранить данные, нам нужна база данных. Это означает, что нам также нужен способ связи с этой базой данных. Если бы мы хотели обмениваться данными из TypeScript с базой данных PostgreSQL, как бы мы это сделали? Вашим первым побуждением может быть использование SQL. Что, если бы существовал способ написать SQL для запросов к базе данных на TypeScript?
// TypeScript (TS):
// db.query("SELECT * FROM users");
// Это сработает, но приведет к множеству неудобных результатов. Во-первых, любые сложные запросы будут очень длинными и раздуют нашу кодовую базу. Во-вторых, при таком подходе сложно повторно использовать код, скорее всего, мы будем писать одни и те же запросы во многих местах. Наконец, написание необработанных запросов делает нас уязвимыми для атаки SQL Injection. Мы не будем вдаваться в подробности, что это влечет за собой, но это атака, нацеленная на необработанные SQL-запросы.
// Пример атаки с внедрением SQL включает в себя поиск скрытых данных, которые затем возвращают дополнительные результаты в запрос SQL.

//TODO: Choosing an ORM (Выбор объектно-реляционного отображения)
// Большинство современных объектно-ориентированных языков имеют несколько вариантов ORM для вашего проекта. Однако в любом языке, как вы решаете, какой ORM использовать? Самое важное, на что следует обратить внимание, — какую базу данных вы используете. Не каждая ORM поддерживает все типы баз данных. Некоторые ORM также поддерживают только один конкретный экземпляр базы данных! Например, ORM может поддерживать PostgreSQL, но не может поддерживать SQLite (это другая реляционная база данных). Также важно учитывать статус ORM. Важно знать, ведется ли над ним активная работа или он устарел. Для нашего проекта нам нужен ORM TypeScript, поддерживающий Postgres. TypeORM — это ORM, который мы решили использовать, поскольку у него отличная документация и он постоянно обновляется.
// При выборе ORM для вашего проекта важно найти ту, которая поддерживает вашу базу данных и активно обновляется.

//TODO: Introduction to TypeORM (Введение в TypeORM)
// В этом модуле мы будем использовать TypeORM, чтобы продемонстрировать множество ключевых концепций ORM. Это ORM TypeScript, который часто используется в NestJS, что делает его идеальным для нашего стека. TypeORM поддерживает как SQL, так и NoSQL, но мы собираемся использовать его с PostgreSQL. TypeORM позволяет нам писать код в нескольких парадигмах, что означает, что вы можете очень легко адаптировать его для разных стилей кодирования. TypeORM имеет множество функций, и мы собираемся обсудить здесь основы. Если вы хотите погрузиться глубже после этого модуля, у них есть замечательная документация, которую можно найти на typeorm.io .
// https://typeorm.io/
// TypeORM — это ORM для TypeScript, который поддерживает как SQL, так и NoSQL.

//TODO: Installing TypeORM (Установка TypeORM)
//TypeORM  — это модуль NPM, поэтому мы можем установить его с помощью интерфейса командной строки NPM. Сначала мы устанавливаем базовый модуль TypeORM:
// npm install typeorm
// Далее нам нужно установить отражающие метаданные и импортировать их в наш основной файл. Метаданные Reflect требуются TypeORM, чтобы мы могли использовать его декораторы.
// npm install reflect-metadata
// // Где-то в нашем основном файле
// import "reflect-metadata";
// Наконец, установите драйвер базы данных для любого экземпляра базы данных, который вы используете. В нашем случае мы используем PostgreSQL (pg), поэтому нам нужно установить модуль pg.
// npm install pg
// Теперь все установлено, и мы готовы к погружению!
// TypeORM — это модуль npm, поэтому мы можем установить его с помощью интерфейса командной строки npm. Мы также можем установить его с помощью пряжи!

//TODO: Creating a Connection (Создание соединения)
// Теперь, когда у нас установлен TypeORM, нам нужно создать объект подключения для связи с нашей базой данных. Давайте посмотрим на шаблонный код, который позволит нам это сделать.
// TypeScript (TS):
// import { createConnection, Connection } from "typeorm";

// const connection = await createConnection({
//   type: "postgres",
//   host: "localhost",
//   port: 5432,
//   username: "your-db-username",
//   password: "your-password",
//   database: "your-db"
// });
// Здесь мы вызываем createConnection, который поступает из модуля TypeORM. Мы передаем функции объект с параметрами конфигурации, чтобы сообщить ей, как подключиться к нашей базе данных. Вам нужно будет заменить свое имя пользователя, пароль и базу данных на те, которые вы настроили, когда установили postgres/настроили базу данных для своего проекта.
// Если вы выбрали параметры установки по умолчанию для PostgreSQL, вы должны оставить хост и порт такими же, как в этом примере.

//TODO: Creating an Entity (Создание Сущности)
// Сущности (часто называемые моделями в других ORM) — это то, где мы определяем содержимое нашей таблицы для системы типов. Вот как мы сообщаем TypeORM, какие столбцы существуют в таблице и что мы можем запрашивать. Давайте рассмотрим пример сущности.
// TypeScript (TS):
// @Entity()
// export class User {
//   @PrimaryGeneratedColumn()
//   id: number;

//   @Column()
//   name: string;

//   @Column()
//   email: string;

//   @Column()
//   age: number;
// }
// Мы начинаем с того, что сообщаем TypeORM, что мы определяем сущность, предваряя наш класс декоратором @Entity. Далее мы назовем наш класс (в нашем случае User). Затем мы можем определить столбцы, которые существуют в нашей таблице, и типы данных, с которыми мы хотим, чтобы они были связаны в TypeScript. Мы используем @Column для аннотирования каждого создаваемого нами столбца. Для нашего идентификатора мы указываем, что это первичный ключ, который автоматически генерируется для нас с помощью @PrimaryGeneratedColumn() .
// Нам не нужно беспокоиться о типах данных SQL при использовании TypeORM. Он автоматически преобразует тип данных TypeScript в тип данных SQL. Однако, если мы хотим больше контролировать, какой тип данных он использует в SQL, вы можете передать дополнительные параметры декоратору @Column.

//TODO: TypeORM Repositories (Репозитории TypeORM)
// В TypeORM репозитории позволяют нам создавать объект, который позволяет нам запрашивать сущность. Рассмотрим пример создания репозитория.
// TypeScript (TS):
// const repository = getRepository(User);
// Здесь мы вызываем getRepository(), который исходит от TypeORM. Затем мы передаем объект, для которого мы хотели бы использовать репозиторий, в функцию getRepository(). В нашем случае мы хотим, чтобы репозиторий был для сущности пользователя. Мы присваиваем это переменной для будущего использования.
// Репозитории позволяют нам запрашивать одну конкретную сущность. Мы не можем запрашивать другие сущности, кроме той, которая связана с репозиторием.

//TODO: Inserting Data (Вставка данных)
// В SQL вы, вероятно, использовали оператор INSERT для вставки данных в нашу таблицу. При использовании TypeORM мы можем вставлять информацию другим способом. Мы вставляем информацию, создавая экземпляр объекта, обновляя поля, которые мы хотим установить, и сохраняя их.
// TypeScript (TS):
// const user = new User();
// user.name = "Troy";
// user.email = "troy@sololearn.com";
// user.age = 25;
// await repository.save(user);
// Здесь мы создаем экземпляр нового пользователя, как и в любом другом классе TypeScript! Затем мы меняем атрибуты пользователя на то, что мы хотим сохранить (например, user.age = 25 ). Наконец, мы ожидаем репозиторий.save(user); Это сохранит пользователя и не будет запускать код после этой строки, пока этот пользователь не будет сохранен!
// Чтобы вставить данные в TypeORM, мы создаем экземпляр объекта из нашего класса сущностей, затем устанавливаем атрибуты для наших желаемых данных и, наконец, сохраняем их с помощью репозитория.save().

//TODO: Selecting Data (Выбор данных)
// TypeORM дает нам надежный метод find(), который мы можем использовать для выбора данных на основе условий.
// TypeScript (TS):
// const results = await repository.find({where: {name: "Troy"}});
// Здесь мы вызываем метод find() в нашем пользовательском репозитории. Мы даем find() объект, указывающий, какие параметры мы хотим использовать при выборе. В нашем случае мы сообщаем find(), что хотим использовать пункт where для поиска пользователей по имени Трой. Это приведет к запуску следующего SQL.
// SQL:
// SELECT * FROM users WHERE name = "Troy";
// Это даст нам ВСЕХ пользователей с именем Троя. TypeORM предоставит нам это как массив объектов сущностей пользователя. Если нам нужен только один пользователь, мы можем вместо этого использовать findOne.
// TypeScript (TS):
// const result = await repository.findOne({where: {name: "Troy"}});
// В TypeORM мы можем вызвать метод find() в репозитории, чтобы выбрать данные из сущности.

//TODO: Updating Data (Обновление данных)
// Теперь, когда мы знаем, как вставлять и выбирать данные. Мы объединяем эти две концепции для обновления данных. Если мы используем .save() и строка уже существует, она обновит строку вместо вставки новой.
// TypeScript (TS):
// const myUser = await repository.findOne({where: {name: "Troy"}});
// myUser.email = "t@sololearn.com";
// await repository.save(myUser);
// Мы используем findOne, чтобы найти пользователя, которого хотим обновить. Затем мы меняем атрибуты объекта, который хотим обновить (в нашем случае мы обновляем электронную почту). Наконец, мы сохраняем пользователя так же, как мы сохраняем нового пользователя! TypeORM обновит его для нас!
// В TypeORM мы можем обновлять строки, используя .find() или .findOne(), чтобы найти строки, которые мы хотим обновить, затем изменить атрибуты в TypeScript, а затем сохранить запись с помощью .save().

//TODO: Deleting Data (Удаление данных)
// Чтобы удалить строку в TypeORM, нам нужно сначала использовать .find() или .findOne(), чтобы найти строку, которую мы хотим удалить. Далее мы можем передать идентификатор в .delete()
// TypeScript (TS):
// const myUser = await repository.findOne({where: {name: "Troy"}});
// await repository.delete(myUser.id);
// Мы используем findOne, чтобы найти пользователя, которого хотим удалить. Затем мы передаем атрибут идентификатора пользователя в .delete(). Мы можем передать .delete() один идентификатор или массив идентификаторов, если мы хотим удалить нескольких пользователей. Мы также можем передать ему другие условия, если мы хотим удалить всех пользователей с именем «Troy», например, мы могли бы это сделать.
// TypeScript (TS):
// await repository.delete({name: "Troy"});
// Мы можем использовать .delete() для удаления строк в TypeORM. Мы передаем ему идентификатор, массив идентификаторов или объект, указывающий, по каким условиям удалять.

//TODO: Reviewing Data's Long Journey (Обзор долгого пути данных)
// NestJS — это тип сервера веб-приложений. Этот модуль расскажет вам, что такое NestJS и как он работает. Когда вы закончите, вы поймете, как работают серверы веб-приложений и как вы можете создать их, не выходя из собственного дома! В Модуле 2 мы говорили о долгом пути, который данные проходят от back-end (серверной части) к front-end. В реальной жизни эти данные часто перемещаются из серверной части в течение секунд или даже миллисекунд. Однако в нашем исследовании данных мы медленно движемся к back-end (серверной части), которая будет в центре внимания этого модуля. К тому времени, когда вы закончите с этим модулем, вы поймете, как данные передаются из базы данных через сервер NestJS, а затем передаются в наш front-end Angular.
// На приведенной ниже диаграмме back-end (серверная часть) состоит из сервер веб-приложений и базы данных.
// Нашей базой данных в этом курсе будет база данных PostgreSQL, а нашим сервером веб-приложений будет NestJS. Мы объясним, как работает NestJS, по мере развития уроков в этом модуле.
// См. Рис: Reviewing Data's Long Journey.png
// NestJS — это сервер веб-приложений. Его работа заключается в обработке запросов от front-end и доставке ответов на основе доступных инструментов.

//TODO: Handling Requests (Обработка запросов)
// В первом модуле мы использовали аналогию с кухней, чтобы показать, как работают полностековые приложения. Давайте расширим эту аналогию и визуализируем, что происходит внутри контроллера веб-приложения. В нашей аналогии с кухней от front-end поступает запрос на еду. Сервер веб-приложений получает запрос. Если запрос действителен, сервер отправляет ответ обратно во front-end. Предположим, что внутри сервера есть повара быстрого приготовления, которые получают запросы на еду. Эти повара быстрого приготовления в контексте сервера называются контроллерами.
// задача Контроллера состоит в том, чтобы получить request (запрос) и response (отправить) ответ. Контроллеры могут обращаться к холодильнику для получения данных (базы данных), но на фундаментальном уровне простейшие контроллеры могут отправлять базовый ответ прямо из контроллера, не касаясь базы данных. Сначала мы изучим простой контроллер, а затем постепенно создадим контроллеры, которые будут делать больше, чем просто выдавать текст. На данный момент мы хотим попасть по веб-адресу, полученному нашим сервером, и вывести HELLO WORLD! Как только мы это сделаем, мы создадим наш первый ответ сервера. Это захватывающе, так что пристегнитесь. Мы погружаемся в back-end сейчас.
// Контроллер внутри сервера веб-приложений подобен повару на кухне. Когда он получает запрос, его задача состоит в том, чтобы доставить ответ на этот запрос, подобно повару, отвечающему «спагетти», когда его просят приготовить макароны.

//TODO: Routes (Маршруты)
// Чтобы лучше понять, как наши контроллеры выполняют свою работу, мы рассмотрим routes (маршруты), requests (запросы) и ответы (responses). Когда вы посещаете https://www.sololearn.com, вы делаете запрос к ROOT route (корневому маршруту) этого веб-сайта. Что такое root (корень)? Root (Корень) — это, по сути, домашняя страница. Он представлен простой косой чертой в URL-адресе.
// См. Рис: Routes.png
// Destination (Целевые) URL-адреса на веб-сайтах называются ROUTES (МАРШРУТЫ). Route (Маршрут) — это просто URL-адрес, который вы посещаете в определенном домене. Здесь sololearn — это домен, а маршрут, который мы посещаем, — это корневой маршрут. Думайте о домене как о всей кухне, и каждый маршрут ведет вас к другому повару. Вы ходите к разным поварам за разными вещами. В этом случае корень маршрут будет служить домашней страницей. Но такой маршрут, как https://www.sololearn.com/fries, доставит нам картофель фри. Это другой маршрут. https://www.sololearn.com/soup доставил бы нам суп. Мы идем разными путями с разными целями. Однако, пожалуйста, не пытайтесь заказать картофель фри или суп по любому из этих адресов. Эта информация просто для демонстрационных целей.
// Корневой маршрут веб-сайта обычно является домашней страницей.

//TODO: Routes Continued (Маршруты Продолжение)
// Веб-сайты обычно имеют несколько маршрутов, предназначенных для разных страниц и действий пользователя. На некоторых сайтах десятки и даже сотни маршрутов. Маршрутизация может быть сложной, но в этих примерах мы будем использовать один маршрут для обработки каждого типа запроса. Когда мы говорим о маршрутах на каком-либо веб-сайте, мы обычно имеем в виду ту часть, которая следует за доменом.
// Примеры:
// https://www.sololearn.com/cats …..будет называться маршрутом «/ cats».
// https://www.sololearn.com/dogs …..будет называться маршрутом «/ dogs».
// https://www.sololearn.com/stores/manage ….. будет называться маршрутом « /stores/manage».
// Маршрут — это набор слов, часто разделенных косой чертой, который указывает на определенный контроллер на сервере веб-приложений. Этот контроллер обработает этот запрос соответствующим образом.

//TODO: GET vs POST (ПОЛУЧИТЬ против ОТПРАВИТЬ)
// В этом модуле мы узнаем о двух разных типах веб-маршрутов:
// маршрутах GET и маршрутах POST.
// - Маршруты GET обычно предназначены для получения данных с сервера.
// - Маршруты POST обычно предназначены для ОТПРАВКИ данных на сервер.
// В нашей аналогии с кухней ПОЛУЧЕНИЕ рамена (японское блюдо с пшеничной лапшой) отличается от ОТПРАВКИ партии рамена на кухню, чтобы они могли расширить свое меню. Проще говоря, маршрут GET получает данные для вас, а маршрут POST отправляет данные для вас.
// Эта диаграмма иллюстрирует концепцию.
// См. Рис: GET vs POST.png
// Подумайте о GET как о fetching (получении) чего-либо, а о POST как о sending (отправке) чего-либо.

//TODO: Get vs Post Requests (Получить и отправить запросы)
// front-end может отправить запрос GET на сервер, который подключается к GET route (маршруту).
// front-end также может отправить запрос POST на сервер, который подключается к POST route (маршруту).
// На сервере мы собираемся настроить различные routes (маршруты). Некоторые routes (маршруты) будут GET routes (маршрутами), а другие routes (маршруты) будут POST routes (маршрутами). GET и POST — это разные типы маршрутов, поэтому они могут иметь одно и то же имя, но сервер будет распознавать их как разные, потому что это разные типы.
// См. Рис: Get vs Post Requests.png
// HTTP-глаголы «GET» и «POST» являются производными от соответствующих английских глаголов, от которых они были получены. «Получить» связано с извлечением чего-либо из ресурса, а «Отправить» — с размещением чего-либо на месте. Когда вы «отправляете» посылку, вы отправляете ее получателю, где «получение» посылки означает, что вы получаете посылку.

//TODO: What is NestJS (Что такое NestJS)
//TODO: https://www.youtube.com/watch?v=abdgy72csaA
// Теперь, когда мы понимаем основы GET, POST и маршрутов, мы можем поговорить о приложении, которое позволит нам применить все эти знания. Дамы и господа, представляем NestJS. NestJS — это тип сервера веб-приложений, созданный с помощью Node.js, который использует TypeScript в качестве основного языка.
// Node.js — это технология, позволяющая запускать JavaScript вне браузера, что дает ему возможность создавать серверы и интерфейсы командной строки. Node.js можно установить, посетив этот веб-сайт: https://nodejs.org/en/.
// Запустите установщики, чтобы установить Node.js на свой компьютер. Теперь нам нужно установить NestJS. Посетите https://docs.nestjs.com/
// и следуйте инструкциям на странице. Теперь, когда Node.js и NestJS установлены, вы можете запустить в своем терминале команду создания шаблонов, подобную следующей.
// nest new cars
// Скаффолдинг в разработке программного обеспечения — это процесс запуска команды, которая очень быстро создает для вас целую кучу вещей, которые сразу же готовы к использованию. Приведенная выше команда создает совершенно новый сервер веб-приложений с именем «cars», а затем, набрав в терминале yarn start или npm run start , вы получите сервер, работающий на порту localhost:3000 на вашем компьютере. Мы рассмотрим localhost в следующей части этого урока. Мы выполнили всю эту подготовительную работу, создав для вас сервер и зафиксировав код на GitHub. Если вы просмотрите этот код, вы увидите базовую настройку проекта простейшего из возможных серверов NestJS, и он работает. Посмотреть проект на GitHub
// Скаффолдинг — это термин, используемый для описания процесса, в котором вы можете ввести одну строку кода, а интерфейс командной строки создаст для вас целый шаблонный проект или функцию. Это как блины "просто добавь воды". Вам не нужно знать, как это работает, и команда поможет вам быстро начать работу. Angular также использует строительные леса.

//TODO: Running a Server Locally (Локальный запуск сервера)
// Когда вы устанавливаете сервер веб-приложений локально, например NestJS, он будет работать на порту 3000 на вашем компьютере. Это означает, что на вашем компьютере есть место, называемое портом, которое вы можете посетить, чтобы увидеть, как работает сервер. Когда вы заходите на такой веб-сайт, как       www.sololearn.com, вы посещаете сервер SoloLearn. Вы можете запустить «сервер» прямо на своем ноутбуке, который в чем-то похож. Сервер, который вы запускаете на своем ноутбуке, предназначен только для тестирования ваших приложений. Для просмотра внешним миром на ваш компьютер необходимо установить специальное программное обеспечение, чтобы сделать его общедоступным сервером. Это не относится к вам; как новичок, сервер, который вы создадите на своем компьютере, будет именно для вас.
// Когда вы посещаете локальный сервер NestJS на своем компьютере, вы посещаете адрес, который выглядит следующим образом: http://localhost:3000/ Не пытайтесь попасть по этому адресу со своего телефона; это применимо только тогда, когда вы находитесь на своем компьютере и у вас работает локальный сервер. Разработчики используют подобные локальные серверы для проверки своей работы перед ее загрузкой или развертыванием в Интернете. Таким образом, вы можете тестировать вещи и вносить изменения во время строительства, не выполняя все эти строительные работы в общественном месте.
// Когда вы запускаете сервер локально, большую часть времени вы запускаете этот сервер в пространстве под названием «localhost», которое просто относится к адресу вашего персонального компьютера.

//TODO: Anatomy of a NestJS Server (Анатомия сервера NestJS)
// Прежде чем мы углубимся в наше приложение NestJS и начнем что-то делать, давайте посмотрим на нашу файловую структуру NestJS. Когда мы построили наш сервер, мы получили базовый сервер веб-приложений, готовый к использованию. Он имеет контроллер, модуль и службу. Подождите... это выглядит почти так же, как файловая структура Angular. Что ж, это не случайно. NestJS использует TypeScript, и команда NestJS приняла решение сделать файловую структуру похожей на Angular, чтобы разработчики Angular могли ее легко понять.
// Так рождаются «стеки»: набор инструментов, которые легко взаимодействуют друг с другом, неизбежно будет называться «стеком» сообществом разработчиков. Следовательно, стек TypeScript с Angular и NestJS теперь кажется вещью, даже если только косвенно.
// См. Рис: Anatomy of a NestJS Server.jpg
// Глядя на эту файловую структуру, мы видим контроллер, который обрабатывает веб-трафик, службу для предоставления данных этому контроллеру и модуль, который работает за кулисами, чтобы убедиться, что служба и контроллер имеют необходимые вспомогательные элементы, чтобы работать.
// Давайте быстро посмотрим, что делает контроллер. Мы видим некоторый код, который выглядит так:
// TypeScript (TS):
// @Get()

// getHello(): string {

//     return this.appService.getHello();
// }
// По сути, это дает запрос «GET» по умолчанию (когда кто-то посещает домашнюю страницу веб-сайта) и возвращает результат функции getHello appService, которая просто возвращает строку «Hello». Итак, у нас есть контроллер, вызывающий службу для получения данных, как в Angular. Не стесняйтесь просматривать файлы в репозитории GitHub, чтобы увидеть, как работает пример NestJS «Hello World»: Посмотреть проект на GitHub:
// https://github.com/SoloLearn-Courses/nest_init
// NestJS и Angular используют сервисы практически одинаково, и файловая структура в целом очень похожа. Основное отличие состоит в том, что в Angular компоненты вызывают сервисы, а в NestJS контроллеры вызывают сервисы.

//TODO: How NestJS Responds to Requests (Как NestJS отвечает на запросы)
// Мы собираемся увидеть, как NestJS обрабатывает простой запрос GET к корневому маршруту. Если вы понимаете это последнее предложение, вы должны гордиться собой… это означает, что вы учитесь. Давайте рассмотрим наш код init «инициализации» NestJS отсюда:
// См. Рис: How NestJS Responds to Requests.png
// AppContoller в NestJS похож на файл app.component.ts в Angular. Это код по умолчанию, который запускается в приложении, когда мы запускаем приложение после его формирования. Это наша отправная точка. Где-то в этом коде скрывается маршрут GET. Вы видите это? Быстро, не читайте следующую строку, вернитесь назад и посмотрите на код и посмотрите, сможете ли вы найти маршрут GET и его ответ. ОСТОРОЖНО, СПОЙЛЕРЫ! Итак, вот ответ: маршрут GET начинается в строке 8.
// это то, что мы называем декоратором, что просто означает, что это наш способ сообщить NestJS, что следующая функция должна вернуть ответ на запрос GET. В строке 10 мы выдаем этот ответ. Обратите внимание, что шаблонный код по умолчанию использует службу. Это немного причудливо, для этого нам не нужен сервис, в этом случае для простого ответа мы могли бы просто использовать это как наш код для строки 10:
// TypeScript (TS):
// return "Hello World";
// Суть в том, что этот код запускается, когда мы попадаем на наш сервер. Когда мы нажимаем http://localhost:3000, мы видим ответ «Hello World!».
// См. Рис: How NestJS Responds to Requests_2.png
// Ответы сервера могут быть строками, целыми числами, JSON и всеми основными типами данных TypeScript.

//TODO: Return Types on Routes (Типы возврата на маршрутах)
// Давайте снова посмотрим на наш код из нашего кода инициализации NestJS отсюда:
// https://github.com/SoloLearn-Courses/nest_init/blob/master/src/app.controller.ts
// обратите внимание на строку 9:
// TypeScript (TS):
// getHello( ): string {
// См. Рис: Return Types on Routes.png
// getHello() — это функция. Он имеет возвращаемое значение. Все в этом выглядит как обычная функция JavaScript, за исключением двоеточия после имени метода и строки слова. Вот еще одна особенность TypeScript, которую мы сейчас изучим в процессе изучения NestJS: типы возвращаемых функций. Да, мои дорогие друзья, в Typescript есть возможность статического ввода ТИПА ВОЗВРАТА функции. getHello(): string означает, что функция getHello ДОЛЖНА возвращать строковое значение. Если это не так, код не будет компилироваться. getHello(): number  означает, что метод getHello должен вернуть число. getHello(): boolean  означало бы, что должно быть возвращено логическое значение. Вы получаете картину.
// Добавление возвращаемых типов к маршрутам обеспечивает структуру и согласованность наших маршрутов, чтобы вы, как программист, и другие разработчики, работающие с этой кодовой базой, могли следовать единым шаблонам в отношении обработки данных в приложении.

//TODO: Scaffold Cars Route (Путь строительных лесов)
// Ранее мы рассмотрели этот внутренний код:
// https://github.com/SoloLearn-Courses/nest_init/
// и мы рассмотрели контроллер, который возвращал ответ, когда пользователи посещали root route (корневой маршрут) веб-сайта. Это здорово, но что, если мы захотим создать еще один route (маршрут)? В идеале мы хотели бы создать route (маршрут), по которому вы могли бы GET (ПОЛУЧИТЬ) автомобили, который возвращал бы массив автомобилей в формате JSON, который наш front-end использовал бы для отображения всех автомобилей, поступающих из back-end. У нас есть новый репозиторий кода, который иллюстрирует это:
// https://github.com/SoloLearn-Courses/nest_controller
// В NestJS мы можем построить новый маршрут, просто выполнив это в терминале:
// nest generate route cars
// Это добавляет новую папку:
// См. Рис: Scaffold Cars Route.png
// И вставляет другую поддержку в базу кода, которая позволяет нам теперь иметь доступ к новому маршруту GET с именем /cars.
// Когда вы начинаете работать с NestJS, вы можете использовать скаффолдер для создания своего приложения и создания новых маршрутов, не полностью понимая все детали того, как эти вещи работают под капотом. По мере того, как вы растете как разработчик, любопытство, скорее всего, заставит вас копаться под капотом, чтобы раскрыть множество поддерживающих структур кода, благодаря которым все работает. На данный момент «это просто работает!», и это отличное место для начала. Теперь у нас новый маршрут.

//TODO: View a Scaffolded Route (Просмотр построенного маршрута)
// В предыдущем уроке мы создали новый route cars, выполнив команду Nest generate Route cars, которая создала папку с файлами для поддержки GET - route /cars. Глядя на созданный route GET для cars, он выглядит так:
// См. Рис: View a Scaffolded Route.jpg
// Этот route с именем findAll() является одним из многих routes, созданных генератором Nest. Очень важно понимать контекст работы routes в любой папке веб-приложения на основе Node.js. Внутри ресурса "cars" route @Get() или @Get('/') представляет собой функцию, которая принимает аргумент. Аргумент, который он принимает, становится sub-route (подмаршрутом) того route (маршрута), в котором вы находитесь. Если sub-route (подмаршрут) не указан, по умолчанию используется root route (корневой маршрут) папки, в которой вы находитесь.
// Примеры: простой маршрут @Get() в /students по умолчанию будет иметь адрес http://www.yourserver.com/students простой маршрут @Get() в /buildings по умолчанию будет иметь адрес http://www.yourserver.com/buildings простой маршрут @Get() в /recipes по умолчанию будет http://www.yourserver.com/recipes … и так далее. Имя папки, в которой вы находитесь, является префиксом. Часть внутри круглых скобок @Get() — это то, что нужно добавить в конец этого префикса. Итак: @Get("models") в выделенном контроллере автомобилей приведет вас к http://www.yourserver.com/cars/models.
// То, что возвращается в любом из этих маршрутов, — это то, что будет отображаться в браузере, когда пользователь нажимает на этот маршрут в браузере. Здесь маршрут просто возвращает строку, в которой говорится, что «это в конечном итоге вернет коллекцию автомобилей». Просмотрите маршрут GET для автомобилей по умолчанию на GitHub.
// https://github.com/SoloLearn-Courses/nest_controller/blob/master/src/cars/cars.controller.ts
// Маршрут GET принимает один аргумент: строку, представляющую остальную часть маршрута GET после префикса. Префикс — это имя того контроллера, в котором вы находитесь.

// TODO: Get All Cars (Получить все автомобили)
// /cars route, который просто возвращает простую строку, скучен и совершенно бесполезен. Вернем реальный массив автомобилей в формате JSON! В нашем предыдущем примере кода в предыдущей части урока у нас был маршрут GET cars, который выглядел следующим образом: 
// См. Рис: Get All Cars.png
// декоратор @Req сообщает NestJS, что мы ожидаем объект запроса, который мы называем request (запросом), который имеет тип Request. Давайте изменим тип возвращаемого значения на это:
//TypeScript (TS):
// findAll(@Req() request: Request): object {...
// Обратите внимание, что вместо возвращаемого типа строки у нас есть объект в качестве возвращаемого типа. Это позволит разместить объект или даже массив объектов. Теперь мы можем сделать что-то вроде этого:
//TypeScript (TS):
// @Get()
// findAll(@Req() request: Request): object {
//   return [{make: 'honda', model: 'accord'},
//            {make: 'subaru', model: 'outback'},
//            {make: 'fiat', model: '123 spider'}];
// }
// Если мы выберем наш маршрут /cars сейчас, мы получим это в окне браузера:
// См. Рис: Get All Cars_2.png
// ТИП ОТВЕТА маршрута очень типично JSON в современной архитектуре сервера веб-приложений. Здесь мы просто сделали тип ответа object, но он также может быть object [ ], что буквально обозначает «массив объектов». Помните, мы создавали массивы с помощью TypeScript? Поскольку массив строк имеет такой тип: string[], отсюда следует, что массив объектов может быть типизирован следующим образом: [] object

//TODO: Nested Routes (Вложенные маршруты)
// В Интернете не все маршруты имеют одно слово после домена. В Интернете часто можно увидеть URL -адреса с более чем одним разделом после домена. Например, вы можете увидеть маршрут, который выглядит так:
// https://www.sololearn.com/cars/engines В этом случае двигатели вложены в маршрут автомобилей. Мы называем это (shockingly)… nested route. Вот как в NestJS в файле контроллера, таком как контроллер автомобилей, мы создаем nested route под названием «showcase» (витрина) внутри автомобилей: добавьте еще один раздел в файл маршрута и поместите имя вложенного маршрута в объявление функции для этого маршрута: 
// См. Рис: Nested Routes.png
// Затем, если мы зайдем на наш локальный сервер по этому адресу, http://localhost:3000/cars/showcase, мы увидим маршрут демонстрации автомобилей:
// См. Рис: Nested Routes_2.png
// Вот код на GitHub для изучения. 
// https://github.com/SoloLearn-Courses/cars_sub_route
// Короче говоря, вложенные маршруты создаются путем объединения маршрутов с «/» между каждым словом в маршруте. Такой маршрут: www.sololearn.com/quizzes/english/typescript может выглядеть в контроллере QUIZZES следующим образом: помните, что слово 'quizzes' неявно присутствует в этом маршруте, потому что этот маршрут находится в контроллере тестов:
// TypeScript (TS):
// @Get('/english/typescript') 
// Думайте о вложенном маршруте как о «подмаршруте», который находится под родителем. Вложенные маршруты могут идти глубоко. У вас может быть такой маршрут:
// http://www.mydomain.com/countries/usa/states/colorado/cities/denver .
// Вложенные маршруты очень распространены в Интернете.
