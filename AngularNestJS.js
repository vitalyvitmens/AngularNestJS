//TODO: Angular + NestJS (Угловой + ГнездышкоJS)
// Погрузитесь в TypeScript, влиятельный язык для веб-разработки. Узнайте, как Angular и NestJS объединяются для создания крупномасштабных приложений JavaScript.

//TODO: SETUP ANGULAR ON YOUR LOCAL SYSTEM:
//TODO: https://www.youtube.com/watch?v=yCIti018Srw
//TODO: https://www.youtube.com/watch?v=msVhfCzFWvY
//TODO: https://www.youtube.com/watch?v=gfTFSeAKzEk
// node -v //чтобы проверить наличие установленного nodeJS
// npm -v //чтобы проверить наличие установленного менеджера пакетов npm

// npm install -g @angular/cli //чтобы УСТАНОВИТЬ Angular CLI
// ng new my-app //создать свой проект с любым названием, в данном случае my-app, на вопрос про routing выбираем Y, выбрать css и нажать enter, на ответы отвечаем: N
// cd my-app //перейдите в папку рабочей области
// ng serve --open //запускаем localhost:4200, на ответы отвечаем: N
//TODO: Если localhost:4200 не запустился:
// Открываем под админом CMD/PowerShell и выполняем две команды:
//   net stop winnat
// а затем:
//   net start winnat

//TODO: SETUP NestJS ON YOUR LOCAL SYSTEM:
//TODO: http://localhost:3000/
// cd cars //перейдите в папку рабочей области
// npm start --watch //после запуска открываем localhost:3000
//  или:
// nest start --watch //после запуска открываем localhost:3000
//TODO: Ещё команды при использовании NestJS:
// nest generate controller bikes // это генерирует новую папку bikes с файлами контроллеров
// nest generate --help // покажет все возможные команды генерации
//TODO: Давайте сделаем Angular-сервис. Angular может сгенерировать сервис для вас с помощью простой команды, поэтому вам не нужно помнить, как построить базовую структуру. Для этого мы используем эту команду в компьютерном терминале:
//    cd my-app
//    ng generate service transportation
// Это создает пустой сервис в приложении Angular.

//TODO: Welcome to Full Stack Web Development (Добро пожаловать в веб-разработку с полным стеком)
// Поздравляем! Вы сделали большой шаг к тому, чтобы стать Full Stack разработчиком!
// В дополнение к прохождению этого курса не забудьте воспользоваться всей поддержкой обучения, доступной вам на SoloLearn, включая ежедневные советы, практики «Попробуйте сами», задачи тренера по коду, игровую площадку для кода и участие в нашем замечательном сообществе учащихся. Мы рады услышать от вас, поэтому, пожалуйста, оставляйте комментарии и отзывы, когда вы учитесь с нами.

//TODO: Overview (Обзор)
// Добро пожаловать на курс Full Stack TypeScript! В этом курсе вы будете создавать динамический интерфейсный веб-сайт и веб-приложения, которые работают вместе, и вы будете создавать все, используя TypeScript! Вы будете создавать вымышленный веб-сайт под названием «TS Flights», который имеет два основных интерфейса: один позволяет вводить рейсы самолетов в панель администратора, а другой позволяет искать рейсы. Мы создали предварительный просмотр, который позволит вам увидеть весь код как на передней, так и на внутренней стороне, а также рабочую модель готового веб-сайта, чтобы вы могли видеть, что вы будете создавать.
// См. Рис: Overview.jpg
// Не пугайтесь! Мы научим вас летать с TypeScript шаг за шагом.

//TODO: The Concept of Web Stacks (Концепция веб-стеков)
// Часто вы услышите, как программисты ссылаются на различные стеки в веб-разработке. За последние несколько лет мы наблюдаем распространение многих стеков, в том числе:
// • MEAN (Mongo, Express, Angular и Node)
// • LAMP (Linux, Apache, MySQL и PHP)
// • Python-Django
// • Ruby on Rails
// • .NET
// и скоро. Важно понимать, что эти стеки постоянно изобретаются, заново изобретаются, повторяются и смешиваются с другими стеками. Стек MEAN превратился в PEAN или NEAP .
// stack, когда некоторые разработчики начали возвращаться к использованию Postgresql вместо Mongo для ресурса базы данных, связанного с этим конкретным стеком. Стек — это не технический термин. Это расплывчатый термин, который может быть очень изменчивым, а иногда даже субъективным. Однако важно уметь сформулировать, с какими стеками вы чувствуете себя наиболее комфортно, когда станете разработчиком полного стека. Этот курс будет сосредоточен на обучении вас общим принципам полной веб-разработки с использованием относительно нового стека: стека на основе TypeScript с использованием Angular и NestJS. Эти навыки можно будет перенести в другие стеки, которые вы изучите в будущем.
// Стек TypeScript с использованием Angular и NestJS — один из новейших стеков в веб-разработке.

//TODO: Front-End vs Back-End (Фронт-энд против бэк-энда)
// Мы будем использовать аналогию с кухней, чтобы проиллюстрировать, как front-end и back-end взаимодействуют друг с другом. Изучите это изображение:
// См. Рис: Front-End vs Back-End_1.png
// В полнофункциональной веб-разработке холодильник можно рассматривать как БАЗУ ДАННЫХ или набор ресурсов данных, кухню — как WEB APPLICATION SERVER (СЕРВЕР ВЕБ-ПРИЛОЖЕНИЙ), а столовую — как набор технологий, который содержит в основном HTML, FRONT-END JAVASCRIPT, CSS и images (изображения).
// См. Рис: Front-End vs Back-End_2.png
// Для нашей аналогии базы данных и сервер веб-приложений являются частью серверной части. HTML CSS и интерфейсный JavaScript являются частью внешнего интерфейса.
// JavaScript и TypeScript можно использовать ОБА в front and the back-end of the stack.

//TODO: The Front-End (Интерфейс)
// В веб-разработке front-end (интерфейс) — это то, что видит пользователь. Экран, на который вы сейчас смотрите, — это внешний интерфейс приложения, будь то на телефоне, планшете или компьютере. Интерфейс в основном состоит из изображений, текста и виджетов, с которыми взаимодействует пользователь. Если для этих элементов требуется база данных, закулисная логика, процесс входа/аутентификации, отслеживание аналитики, общение с другими пользователями и другие подобные вещи, то интерфейсу нужен сервер. Однако не для всех интерфейсных приложений требуется серверная часть. Когда всемирная паутина впервые стала популярной в середине 1990-х годов, многие веб-сайты не имели серверной части. Простая HTML-страница с изображениями, текстом, контактной информацией и ссылкой на электронную почту не обязательно требует серверной части!
// Если вы создадите простой файл HTML на своем компьютере прямо сейчас, вы создадите то, что мы называем static web application (статическим веб-приложением). Это статическое приложение будет интерфейсом. В Интернете есть ресурсы, такие как Firebase, где вы можете разместить свои простые статические HTML-страницы почти мгновенно и бесплатно.
// Мир технологий стал очень специализированным. Многие разработчики специализируются только на front-end или back-end веб-разработке.

//TODO: The Back-End (Бэк-Энд)
// Серверная часть — это место, где живут как сервер веб-приложений, так и база данных. Есть множество других элементов, которые находятся внутри внутреннего пространства, таких как балансировщики нагрузки, сервисные работники, почтовые серверы и так далее. Однако в этом курсе мы сосредоточимся в первую очередь на сервере веб-приложений и базе данных.
// Наш сервер TS Flights будет иметь следующие основные обязанности:
// • Обработка запросов от внешнего интерфейса на информацию
// • Создание, чтение, обновление и удаление полетов самолетов в системе
// • Отправка информации обратно во внешний интерфейс в формате JSON (JavaScript Object Notation) (Java Сценарий Объекта Обозначения).
// Основной обязанностью серверной части является обработка данных, тогда как основной обязанностью внешней части является отображение данных и обработка взаимодействия с пользователем. Внешние интерфейсы также обрабатывают данные, но тяжелые манипуляции с данными, как правило, относятся к области серверных.
// Мы используем аббревиатуру CRUD (Create, Read, Update and Delete) для описания процессов создания, чтения, обновления и удаления данных.

//TODO: JavaScript and TypeScript throughout the Stack (JavaScript и TypeScript во всем стеке)
// JavaScript стал популярным полнофункциональным инструментом в 2009 году после выпуска NodeJS. До выпуска NodeJS JavaScript рассматривался в первую очередь как инструмент только для front-end, используемый для создания виджетов, действий пользователя на странице, манипулирования DOM (структурой веб-страницы) и других задач только для front-end. После выпуска NodeJS JavaScript стал рассматриваться как отличный инструмент для создания как back-ends так и front-ends одинаково. TypeScript был выпущен Microsoft в 2012 году, потому что многие разработчики JavaScript выразили желание иметь более структурированные и четкие типы данных, особенно для использования в крупномасштабных приложениях. TypeScript имеет некоторые функции, такие как статическая типизация переменных и интерфейсы, которые присутствуют в уважаемых устаревших языках, таких как Java и C#.
// TypeScript — это надмножество JavaScript. Это означает, что TypeScript переносится в JavaScript. Он буквально транслируется в код JavaScript при компиляции и перед запуском. TypeScript переводится в JavaScript. Это важная концепция, которую нужно помнить! Таким образом, после выпуска NestJS имело логическое значение, что TypeScript можно было использовать во всем стеке веб-приложений, как это было с JavaScript.
// Одним из создателей Typescript был сотрудник Microsoft Андерс Хейлсберг, создатель C#.

//TODO: XHR (XML/HTTP Request)
// Следующей концепцией, которую необходимо понять, является is the request / response nature of full stack applications (характер запроса/ответа приложений с полным стеком). В ресторане заказ еды исходит из столовой или от front-end. Клиент делает запрос на кухню. В веб-приложениях это обычно происходит в форме  XML/HTTP Request (запроса) или XHR. Давайте разберем этот термин: XML/HTTP Request. Хотя сам термин уже показывает свой возраст (мы не так часто используем XML для отправки данных через Интернет; вместо этого в большинстве случаев теперь используется JSON), вторая часть этого термина, HTTP, является критически важной. HTTP означает HyperTextTransfer Protocol (протокол передачи гипертекста).
// и является основой всего общения в сети. Думайте о HTTP как о способе, с помощью которого все веб-технологии должны взаимодействовать друг с другом.
// Вы можете проанализировать XHR любого веб-сайта на вкладке сети браузера в инструментах разработчика Chrome.

//TODO: The Request / Response Cycle (Цикл запроса/ответа)
// В нашей аналогии после того, как клиент делает запрос, его получает кухня или сервер веб-приложений. Затем сервер веб-приложений анализирует запрос и решает, может ли он выполнить этот заказ. Если заказ может быть выполнен, то кухонный персонал обращается к базе данных (к холодильнику), извлекает данные (еду), подготавливает данные (в формате JSON), а затем отправляет данные обратно клиенту (делает красивым отображение на странице).
// См. Рис: The Request & Response Cycle.png
// Это представляет собой очень простой цикл request/response (запрос/ответ). Запрос отправляется на сервер веб-приложений, анализируется и либо отклоняется NO (error or redirect (ошибка или перенаправление)), либо принимается (YES).

//TODO: HTTP Error Codes (Коды ошибок HTTP)
// Да, XML/HTTP Request (запросы) могут быть отклонены сервером! В случае отклонения сервер веб-приложений отправляет HTTP response (ответ) обратно клиенту (front-end). Возможные коды состояния ошибки HTTP:
// • 404 (не найдено)
// • 403 (запрещено)
// • 401 (не авторизовано)
// • 500 (внутренняя ошибка сервера)
// • 503 (сервис недоступен)
// Существует множество других кодов состояния HTTP, и они обычно делятся на категории. по первой цифре кода состояния.
// Сервер и клиент — очень распространенные термины в вычислительной технике. «server» в разработке полного стека обычно относится к серверу веб-приложений, а клиент — к любому устройству, взаимодействующему с сервером в front-end. Обычными клиентами являются ноутбуки и настольные компьютеры, мобильные телефоны, системы GPS в автомобилях, устройства с голосовым управлением, такие как Amazon Alexa, Siri и Google Home, игровые приставки, смарт-часы и все остальное, что подключается к серверной части.

//TODO: HTTP Success Codes (HTTP-коды успеха)
// Все коды уровня 200, как правило, являются положительными кодами состояния:
// • 200 (ok)
// • 201 (created (создано))
// • 202 (accepted (принято)) и т. д.
// Напротив, коды уровня 400 обычно указывают на проблему с самим запросом, а статус уровня 500 коды обычно указывают на ошибку на сервере. Если первоначальный запрос был принят сервером веб-приложений и необходимо получить данные, связанные с запросом, сервер веб-приложений затем запрашивает базу данных или базы данных, чтобы получить информацию, необходимую для отправки обратно пользователю.
// База данных отправляет результат запроса обратно на сервер веб-приложений, а затем сервер веб-приложений обычно форматирует данные в формат, который будет отправлен обратно в front-end. JSON (JavaScript Object Notation) (Java Сценарий Объекта Обозначения) — это очень распространенный формат, который в настоящее время используется для отправки данных клиентам (front-end).
// Коды уровня 200 — положительные, коды уровня 400 — проблемы, а коды уровня 500 — ошибки.

//TODO: The Angular / NEST flow (Угловой / NEST поток)
// Подводя итог, мы будем использовать TypeScript, надмножество JavaScript, для создания полнофункционального приложения под названием TS Flights, которое позволит пользователям искать рейсы самолетов. В приложении также будет страница, которая позволит вам, как администратору, вводить новые рейсы, чтобы отображаться в будущих поисках.
// На фронтенде мы будем использовать Angular. На бэкенде мы будем использовать NestJS.
// Для чего-то вроде поиска рейса или добавления нового рейса в базу данных наше внешнее приложение Angular будет делать запросы к нашему серверному NestJS, используя XHR. Если запрос отклонен, он вернет отрицательный код состояния HTTP обратно в Angular. Если запрос будет принят, он приступит к выполнению той работы, для которой был отправлен... которая может включать получение всех рейсов из Нью-Йорка в Париж или что-то в этом роде. Если запрос был принят и включает вызов базы данных, NestJS сделает запрос к нашей базе данных, получит результат и, если этот запрос к базе данных будет успешным, вернет ответ JSON нашему приложению Angular с кодом состояния уровня 200.
// Затем наше приложение Angular будет использовать HTML и CSS, чтобы сделать ответ красивым, чтобы наши пользователи могли видеть все рейсы в Париж на своем телефоне или компьютере. С помощью этого потока вы должны увидеть, что пользователь инициирует процесс на клиенте, запрос возвращается на сервер, выполняет свою работу, а затем возвращается обратно к клиенту для завершения процесса.
// Request/response cycles (Циклы запроса/ответа) могут быть невероятно сложными, но этот очень простой flow (поток) — начало понимания залпов между front and the back end.

//TODO: Introduction to Angular (Введение в Ангуляр)
// Angular — это front-end (интерфейсный) JavaScript-фреймворк.
// Фреймворк — это набор связанных библиотек, разработанных для определенного языка программирования. Фреймворки provide (предоставляют) conventions (соглашения), которые поддерживают определенные действия. Front-end (интерфейсная) среда обычно имеет определенные соглашения относительно того, как обрабатывается HTML, как создаются формы, как обрабатываются интерактивные элементы на веб-странице, как переменные интерполируются внутри HTML-представлений и т.д. AngularJS или Angular 1.x были первыми. итерация фреймворка Angular. С выходом Angular 2, Angular был полностью переработан с использованием TypeScript и компонентной архитектуры. Хотя архитектура на основе компонентов была доступна в более поздних выпусках Angular 1.x, компоненты теперь являются самой основой Angular 2 и всех последующих выпусков после версии 2 . вариант 3). Angular 8 был выпущен в 2019 году, и этому посвящен этот курс.
// Важно знать, что когда разработчики говорят Angular, они имеют в виду Angular версии 2 и выше. AngularJS относится только к версии 1 Angular.

//TODO: Strings in TypeScript (Строки в TypeScript)
// AngularJS использовал Javascript в качестве основного языка. Angular начал использовать TypeScript, начиная с Angular 2. С тех пор TypeScript стал основным языком Angular. Давайте рассмотрим некоторые основы TypeScript. Переменные в TypeScript могут быть statically typed (статически типизированы). Статически типизированные переменные всегда должны сохранять тип данных, с которого они начинаются. Например, когда переменная статически типизирована как строка, эта переменная не может содержать данные какого-либо другого типа. TypeScript использует ключевые слова JavaScript var, let и const для инициализации переменных. Он также использует двоеточие после имени переменной для обозначения типа.
// Javascript (JS):
// let name = 'Fred'
// TypeScript (TS):
// let name: string = 'Fred'
// Основываясь на этом соглашении, мы могли бы инициализировать строку shoesColor в TypeScript как таковую:
// TypeScript (TS):
// let shoeColor: string = 'blue'
// console.log(shoeColor)
// Возможно изменение значений переменных с течением времени:
// shoeColor = 'red'
// console.log(shoeColor)
// Теперь "shoeColor" имеет значение красного цвета. Обратите внимание, что после того, как переменная была введена, вам не нужно снова объявлять тип при изменении значения переменной.
// TypeScript не требует от вас статической типизации ввода переменных. Обычный синтаксис Javascript БУДЕТ работать в TypeScript. Однако по соглашению большинство программистов вводят статическую типизацию переменных в TypeScript, потому что это помогает обеспечить структуру и предотвратить ошибки программиста.

//TODO: Numbers in TypeScript (Числа в TypeScript)
// Другой тип данных TypeScript — числовой тип данных. Мы можем инициализировать числовую переменную seatCount в TypeScript следующим образом:
// TypeScript (TS):
// let seatCount: number = 42
// TypeScript не определяет между целыми числами и числами с плавающей запятой или десятичными числами, как другие языки, когда дело доходит до набора текста. Инициализация десятичного числа аналогична инициализации целого числа:
// TypeScript (TS):
// let registrationPercentage: number = 92.87
// Обратите внимание, что RegistrationPercentage всегда должен иметь числовой тип. Если бы вы попытались переназначить RegistrationPercentage строковому значению в другой строке этой программы, программа не скомпилировалась бы, и ваш текстовый редактор, скорее всего, выдал бы ошибку.
// TypeScript (TS):
// registrationPercentage = 'Ninety Two'
// ВЫЗЫВАЕТ ОШИБКУ, потому что RegistrationPercentage статически типизирован как число.
// Typescript включает в себя все методы, которые вы привыкли использовать в JavaScript. Например, строковые методы, такие как parseInt() и parseFloat(), которые возвращают числа, также будут работать в TypeScript.

//TODO: Booleans in TypeScript (Логические значения в TypeScript)
// Логические значения либо истинны, либо ложны. В TypeScript вы можете объявить и статически ввести переменную, не инициализируя ее значением. Например:
// TypeScript (TS):
// let isRegistered: boolean
// Однако если вы попытаетесь использовать isRegistered на этом этапе программы, вы получите сообщение об ошибке. Некоторые программисты объявляют переменные и вводят их без инициализации, потому что значение переменной в начале программы совершенно неизвестно. Позже вы можете назначить его.
// TypeScript (TS):
// isRegistered = false;
// console.log(isRegistered); // false
// Логические значения всегда возвращают истинные или ложные значения. Эти значения не являются строками, на самом деле они являются собственным типом данных.

//TODO: Enums in TypeScript (Перечисления в TypeScript)
// Значения Enum в Typescript представляют собой наборы констант. Думайте об Enum как о типе фиксированного массива вещей, которые вы используете в качестве ссылки, например, дни недели, штаты в США и т.д. Количество элементов никогда не меняется во время выполнения программы и порядок элементов. тоже не меняется. Давайте создадим перечисление с именем spiceLevel:
// TypeScript (TS):
// enum spiceLevel {
//   NONE = "no spice",
//   LOW = "barely spicy",
//   MEDIUM = "medium spicy",
//   HIGH = "hot"
// }

// console.log(spiceLevel.MEDIUM) // outputs "medium spicy"
// Современные интегрированные среды разработки (IDE), такие как Visual Studio Code, помогают заполнять значения перечисления и другие конструкции кода с помощью автозаполнения. Перечисления помогают гарантировать согласованность всех часто используемых констант в вашей программе. Это помогает избежать опечаток и общих ошибок.

//TODO: The 'any' Type in TypeScript (Тип «любой» в TypeScript)
// Наконец, мы рассмотрим any (любой) тип данных.
// Тип any (любой) по сути является подстановочным знаком. Он может держать что угодно. Мы можем объявить any тип данных в TypeScript следующим образом:
// TypeScript (TS):
// let userData: any
// userData теперь будет контейнером, который может содержать данные любого типа. Однако после инициализации userData он выводит тип из переданного ему значения.
// let userData: any
// TypeScript (TS):
// userData = 22
// console.log(userData + 2) // logs 24

// userData = "free";
// console.log(userData + "man") // logs "freeman"
// Обратите внимание, что с любым типом данных, даже если тип выводится при присвоении, вы можете повторно присвоить переменной другой тип данных, и он все равно будет работать. С какой стати вам вообще нужен тип any? Что ж, в определенных ситуациях, например при получении пользовательских данных с сервера, вы можете принимать переменные данные, которые предположительно могут относиться к любому типу данных.
// Любые типы не только вмещают данные из любого источника, но и сигнализируют другим разработчикам о том, что эта конкретная переменная имеет неизвестный тип и что с данными следует обращаться осторожно.

//TODO: Custom Types (Пользовательские типы)
// Если вы на минуту подумали, что TypeScript ограничен числовыми, строковыми, логическими и другими знакомыми типами, то у нас есть для вас приятный сюрприз! В TypeScript вы можете создавать свои СОБСТВЕННЫЕ типы и использовать их так же, как и примитивные типы, такие как числа и строки. Один из способов сделать это — создать interface. Interface в TypeScript — это структура данных, которая определяет форму данных. Давайте посмотрим на это в действии:
// TypeScript (TS):
// interface Order {
//   customerName: string,
//   itemNumbers: number[],
//   isComplete: boolean
// }
// Ключевое слово interface используется для инициализации интерфейса, который показывает нам ФОРМУ поступающих данных. Думайте об интерфейсе как о фабричной пресс-форме. Этот интерфейс используется для штамповки типов Order для store (хранилища). Теперь давайте воспользуемся интерфейсом Order для ввода переменной:
// TypeScript (TS):
// let order1: Order;
// order1 = {
//   customerName: "Abiye",
//   itemNumbers: [123, 44, 232],
//   isComplete: false
// }
// Проанализируем переменную order1 (заказ1). Он имеет тип Order (Заказ), поэтому он должен иметь 3 поля:
// - первое поле: строка "Abiye"
// - второе поле: массив целых чисел [123, 44, 232]
// - третье поле — логическое значение false
// Он ДОЛЖЕН иметь каждое из этих полей для выполнения контракта интерфейса. Попробуйте опустить одно из полей в order1 (например, удалите имя клиента). Вы получите ошибку, потому что контракт не выполнен.
// Контракт интерфейса — это просто список полей в этом интерфейсе, которые нужны любой переменной, если она хочет использовать этот тип. Все обычные поля в интерфейсе должны быть реализованы в любой переменной, которая использует этот тип.

//TODO: Optional Fields in Interfaces (Необязательные поля в интерфейсах)
// Мы можем использовать необязательные поля в интерфейсе в TypeScript. Необязательные поля не являются частью строгого контракта интерфейса. Вы можете опустить их при создании экземпляра этого интерфейса.
// TypeScript (TS):
// interface Order {
//   customerName: string,
//   itemNumbers: number[],
//   isComplete?: boolean
// }
// Обратите внимание на вопросительный знак после isComplete? (завершено?) означает, что мы можем опустить это значение, и код все равно скомпилируется. Это полезно для полей в интерфейсе, которые не являются обязательными.
// TypeScript (TS):
// let order1: Order;
// order1 = {
//   customerName: "Abiye",
//   itemNumbers: [123, 44, 232]
// }
// Order1 (заказ1) теперь имеет только 2 поля, и он все еще компилируется, потому что isComplete является необязательным полем.
// Необязательные поля полезны при получении данных из базы данных или вызове API, когда некоторые поля могут отсутствовать или быть неполными.

//TODO: Angular Files (Угловые файлы)
// До этого момента мы создавали простые файлы TypeScript, которые запускаются в любой среде, в которой работает TypeScript. Однако с этого момента мы будем писать ВЕСЬ наш TypeScript на Angular! В Angular каждый component имеет как минимум 4 файла, которые гармонично работают вместе. Эти файлы внутри папки выглядят примерно так:
// См. Рис: AngularFiles_1.png
// Здесь нас будут интересовать только два файла:
// - файл app.component.ts, который мы назовем component
// - файл app.component.html, который мы назовем component view (вид).
// component - это место, где объявляются и изменяются переменные.
// view (вид) - HTML-файл, который получает переменные от компонента и отображает их. Мы создали пример «hello world», чтобы показать вам, как эти файлы взаимодействуют друг с другом.
// COMPONENT (СОСТАВНАЯ ЧАСТЬ):
// TypeScript (TS):
// name = "Star student";
// VIEW (ВИД):
// HTML:
// Hello, {{name}}!
// Result (Результат):
// См. Рис: AngularFiles_2.png
// мы установили этот код в StackBlitz, онлайн-редакторе Angular, который позволяет запускать код на вашем телефоне! В StackBlitz файлы находятся слева, код — посередине, а небольшой браузер — справа. Вы можете просмотреть и/или отредактировать код и увидеть результат в течение нескольких секунд. Попробуйте на StackBlitz
// https://stackblitz.com/edit/angular-starter-example?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-starter-example
// Двойные фигурные скобки вокруг {{name}} демонстрируют то, что мы называем интерполяцией. Интерполяция — это вставка переменного содержимого из компонента в представление.

//TODO: SETUP ANGULAR ON YOUR LOCAL SYSTEM:
// node -v //чтобы проверить наличие установленного nodeJS
// npm -v //чтобы проверить наличие установленного менеджера пакетов npm

// npm install -g @angular/cli //чтобы УСТАНОВИТЬ Angular CLI
// ng new my-app //создать свой проект с любым названием, в данном случае my-app, выбрать css и нажать enter, на ответы отвечаем: N
// cd my-app //перейдите в папку рабочей области
// ng serve --open //запускаем localhost:4200, на ответы отвечаем: N
//TODO: Если localhost:4200 не запустился:
// Открываем под админом CMD/PowerShell и выполняем две команды:
//   net stop winnat
// а затем:
//   net start winnat
//TODO: Давайте сделаем Angular-сервис. Angular может сгенерировать сервис для вас с помощью простой команды, поэтому вам не нужно помнить, как построить базовую структуру. Для этого мы используем эту команду в компьютерном терминале:
//    cd my-app
//    ng generate service transportation
// Это создает пустой сервис в приложении Angular.

//TODO: Parts of a Component (Части компонента)
// См. Рис: Parts of a Component.png
// На нашей диаграмме ниже у нас есть 4 части компонента, представленные четырьмя разноцветными стрелками. Красный раздел — это раздел импорта. Оранжевая стрелка указывает на код, автоматически сгенерированный Angular; нам не нужно трогать эту часть, если мы не хотим ее изменить. Синяя стрелка указывает на то, где объявлены переменные класса. Наконец, зеленая стрелка указывает на то, где объявлены переменные метода. Переменные класса принадлежат всему классу, но переменные метода применяются только в каждом методе (или «функции»), в котором они находятся.
// Попробуйте в StackBlitz View:
// https://stackblitz.com/edit/angular-class-vs-method-variables-intro?file=README.md
// на GitHub:
// https://github.com/SoloLearn-Courses/angular-class-vs-method-variables-intro
// Совет для профессионалов: в объектно-ориентированном программировании функции которые является частью класса называются методы. Компоненты — это классы, поэтому мы называем функции внутри них тоже методами.

//TODO: Class vs Method Variables (Класс против переменных метода)
// Давайте добавим некоторый код в наш метод speak(), чтобы увидеть, как переменные экземпляра и переменные метода выглядят на практике:
// См. Рис: Class vs Method Variables.png
// префикс и имя переменных являются переменными класса. Они принадлежат классу. Внутри метода speak(), если мы хотим вызвать членов класса, мы должны использовать ключевое слово (this). Также обратите внимание, что внутри метода speak() мы используем ключевое слово const для объявления переменной sentence (предложение). Внутри методов вы должны использовать ключевое слово, такое как var, let или const, для объявления переменных. Мы выбрали const, потому что ключевые слова const объявляют значение, которое является константой и не изменится.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-class-vs-method-variables?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-class-vs-method-variables

//TODO: Iterating through String Arrays (Итерация по массивам строк)
// С Angular, отмеченным в коде как ng, мы можем использовать команду *ngFor в файле HTML (представление) для перебора массивов, объявленных в компоненте. Учитывая этот массив в компоненте Angular:
// TypeScript (TS):
// colors: string[] = ['red', 'blue', 'green', 'purple'];
// Мы можем перебирать цвета в сопроводительном HTML-файле в Angular следующим образом:
// HTML:
{
  /* <div *ngFor='let color of colors'> 
  {{ color }} 
</div> */
}
// Результат в вашем браузере будет выглядеть следующим образом:
// red (красный)
// blue (синий)
// green (зеленый)
// purple (фиолетовый)
// Где каждый из цветов, красный, синий, зеленый и т.д. заключен в div. *ngFor по существу создает цикл, в котором html-тег, объявленный внутри циклов, повторяется столько раз, сколько элементов в вызываемом массиве.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-ngfor-looping?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-ngfor-looping
// *ngFor — это структурная директива. Структурные директивы изменяют HTML в соответствии с переменными данными, с которыми они связаны.

//TODO: Iterating with Indices (Итерация с индексами)
// Иногда полезно при переборе массива иметь доступ к индексу в каждой итерации цикла. Вот как мы это делаем в Angular:
// HTML:
{
  /* <div *ngFor='let fruit of fruits; let i=index'>
   Fruit {{ i }} is {{ fruit }} 
</div> */
}
// Результат в вашем браузере будет выглядеть следующим образом:
// Fruit 0 is apple
// Fruit 1 is orange
// Fruit 2 is pear (груша)
// Fruit 3 is peach (персик)
// Обратите внимание, что наша переменная-итератор называется i. Эта переменная может называться как угодно; мы просто использовали букву i из-за условности. Ключевое слово index нельзя изменить. Angular знает, что index — это индекс каждой итерации, когда мы перебираем массив.
// Попробуйте на StackBlitzL:
// https://stackblitz.com/edit/angular-indices?file
// Посмотреть на Github:
// https://github.com/SoloLearn-Courses/angular-indices
// Индексы во время итерации полезны при повторении списков вещей, таких как элементы корзины покупок, которые связаны с идентификаторами базы данных из серверной части. Мы вернемся к этому позже в курсе! Подожди!

//TODO: Iterating through Custom Types (Перебор пользовательских типов)
// Теперь мы соединим то, что вы узнали об интерфейсах, с нашим механизмом циклов *ngFor. Давайте создадим интерфейс для автомобиля и поместим его в отдельный файл с именем car.ts ( .ts — это расширение файлов TypeScript) .
// TypeScript (TS):
// export interface Car {
//   make: string;
//   model: string;
//   miles: number;
// }
// Теперь, когда у нас есть интерфейс Car, мы можем импортировать этот интерфейс в наш компонент как таковой:
// TypeScript (TS):
// import { Car } from './car';
// Теперь мы можем создать 3 объекта типа Car:
// TypeScript (TS):
// subaru: Car = {make: 'Subaru', model: 'Outback', miles: 58232};
// honda: Car = {make: 'Honda', model: 'Accord', miles: 39393};
// bmw: Car = {make: 'BMW', model: 'X3', miles: 4400};
// cars:Car[ ] = [this.subaru, this.honda, this.bmw];
// И, наконец, мы можем просмотреть все наши автомобили в файле HTML:
{
  /* <div *ngFor="let car of cars">
   {{car.make}} {{car.model}}  with a mileage of {{car.miles}}
</div> */
}
// Вот наш вывод:
// Subaru Outback with a mileage of 58232
// Honda Accord with a mileage of 39393
// BMW X3 with a mileage of 4400
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-loop-thru-custom-type?file=src%2Fapp%2Fapp.component.ts
// Когда вы перебираете пользовательский тип, например Car в данном случае, вы должны использовать точечную нотацию (car.make, car.model, car.miles и т.д.) для доступа к элементам этого объекта, поскольку интерфейсы состоят из различных полей, похожие на объект JavaScript.

//TODO: Data's Long Journey (Долгий путь данных)
// На предыдущем уроке мы создали список типов автомобилей в компоненте для циклического просмотра. Это нормально для локальных данных, которые жестко закодированы в компоненте, но в реальных бизнес-примерах данные проходят очень долгий путь, прежде чем они, наконец, достигают нашего представления. Используя нашу предыдущую аналогию с рестораном из Модуля 1, давайте посмотрим на долгий путь, который данные проделывают в реальном мире, прежде чем они попадут к нам:
// См. Рис: Data's Long Journey.png
// по мере того, как мы углубляемся в стек в этом курсе, мы будем продолжать перемещать данные возвращаться все дальше и дальше в стеке, пока мы, наконец, не получим его из базы данных. Наш следующий шаг — переместить данные из компонента в нечто, называемое сервисом, которые мы рассмотрим очень скоро в следующих частях этого урока. Упрощенный типичный поток данных от конца к началу будет выглядеть следующим образом:
// 1. Data retrieved from database query (Данные, полученные из запроса к базе данных)
// 2. Data routed through server (Данные, маршрутизируемые через сервер)
// 3. Data reaches service (Данные достигают сервиса)
// 4. Data reaches component (Данные достигают компонента)
// 5. Data reaches view (Данные достигают представления)
// Базы данных чаще всего являются местом, где хранятся данные для веб-приложений. Мы в конце концов доберемся туда. Оставайтесь вовлеченными!

//TODO: Introduction to Angular Services (Введение в сервисы Angular)
// Сервисы — это специальные файлы в Angular, которые используются для управления данными. Обычно они извлекают данные из XHR (помните запросы XML/HTTP из Модуля 1?), но они также могут хранить данные самостоятельно. Помните нашу диаграмму о долгом путешествии данных? На данный момент мы не проходим весь путь до базы данных, чтобы получить данные. Мы собираемся просто отправить данные обратно в сервис и оставить их там на данный момент. На этой диаграмме показан простой поток между компонентом, сервисом с данными и представлением HTML.
// См. Рис: Introduction to Angular Services.png
// 1. Компонент cars вызывает транспортный сервис (service), которая содержит список автомобилей
// 2. Транспортный сервис (service) возвращает список автомобилей компоненту cars
// 3. Представление (view) cars получает список автомобилей и перебирает их, используя *ngFor
// Сервис похож на brain (мозг) в приложении Angular, который либо возвращает данные из самого сервиса, либо данные, полученные из внешнего источника (external source). Его можно рассматривать как «data manager».

//TODO: Generating an Angular Service (Создание сервиса Angular)
// Давайте сделаем Angular-сервис. Angular может сгенерировать сервис для вас с помощью простой команды, поэтому вам не нужно помнить, как построить базовую структуру. Для этого мы используем эту команду в компьютерном терминале:
//TODO:    cd my-app
//TODO:    ng generate service transportation
// Это создает пустой сервис в приложении Angular.
// TypeScript (TS):
// import { Injectable } from '@angular/core';
// @Injectable({
//   providedIn: 'root'
// })
// export class TransportationService {
//   constructor() { }
// }
// Нас будут интересовать только две части этого сервиса:
// 1. Верхняя часть файла, в которой находятся импортированные данные. Сюда мы будем импортировать файлы, которые будет использовать сервис.
// 2. Тело класса, где говорится об экспорте класса TransportationService.
// Тело класса заключено в фигурные скобки после слова TransportationService.
// Методы в теле класса сервиса используются для экспорта данных из сервиса.

//TODO: Import Interface into a Service (Импорт интерфейса в сервис)
// Наш транспортный сервис будет содержать множество типов автомобилей. Для этого нам нужно импортировать наш автомобильный интерфейс, который мы создали ранее. Мы узнали, что верхняя часть файла — это место, куда мы импортируем вещи. Мы можем добавить эту строку в верхнюю часть транспортного сервиса:
// TypeScript (TS):
// import { Car } from './car';
// Это позволяет нам использовать тип Car для создания массива Cars. Наш транспортный сервис теперь ИМПОРТИРУЕТ интерфейс из файла car.ts. Вот связь между этими двумя файлами:
// См. Рис: Import Interface into a Service.png
// файл car.ts ЭКСПОРТИРУЕТ интерфейс, а транспортный сервис ИМПОРТИРУЕТ тот же самый интерфейс для использования. Теперь это позволит нам создать массив типов автомобилей в нашем сервисе.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-service-imports-interface?file
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-service-imports-interface
// Функциональность импорта/экспорта, которую мы видим в Angular, получена из NodeJS. Эта же система импорта/экспорта встречается почти во всех интерфейсных JavaScript-фреймворках, поскольку большинство этих фреймворков построены с использованием Node.

//TODO: Recreating Car Array in a Service (Воссоздание массива автомобилей в сервисе)
// Теперь, когда мы импортировали ресурс автомобиля, мы можем создать массив типов автомобилей в нашем транспортном сервисе. Последнее, что нам нужно сделать после этого, — это создать метод getCars() для экспорта данных об автомобиле из сервиса. Вот готовый service:
// TypeScript (TS):
// import { Injectable } from '@angular/core';
// import { Car } from './car';

//  @Injectable({
//   providedIn: 'root'
//  })
//  export class TransportationService {
//   // NEW CODE
//   subaru: Car = {make: 'Subaru', model: 'Outback', miles: 58232};
//   honda: Car = {make: 'Honda', model: 'Accord', miles: 39393};
//   bmw: Car = {make: 'BMW', model: 'X3', miles: 4400};

//   cars:Car[] = [this.subaru, this.honda, this.bmw];

//   constructor() { }

//   // NEW CODE
//   getCars() {
//     return this.cars;
//   }
//  }
// Теперь этот сервис готов к использованию нашим компонентом.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-service-completed?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-service-completed
// Сервисы экспортируют методы, которые позже будут вызываться компонентами Angular, использующими сервис. Один сервис может использоваться несколькими компонентами.

//TODO: Dependency Injection (Внедрение зависимости)
// Теперь, когда наш сервис фактически экспортирует данные, наш компонент должен их загрузить. В Angular мы используем нечто, называемое внедрением зависимостей, для переноса сервиса в компонент. Теперь этот сервис готов к использованию нашим компонентом. Вот как это выглядит:
// См. Рис: Dependency Injection.png
// Dependency injection (Внедрение зависимостей) — распространенный шаблон проектирования в объектно-ориентированном программировании.
// Думайте о внедрении зависимостей, как об установке погодного приложения на свой телефон. Каждый телефон, на котором установлено приложение погоды, получает одно и то же приложение. Его можно установить на несколько телефонов, и каждый телефон, который нажимает кнопку «получить погоду» для города, получит одну и ту же погоду. Сервис погоды является центральным сервисом, предоставляющим данные всем, кто на него подписан. Это то, что сервис делает посредством внедрения зависимостей. Обычно он предоставляет данные всем своим подписчикам вместе с другими функциями.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-service-dependency-injection?file
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-service-dependency-injection
// Обратите внимание, как мы создаем частную переменную с именем transportService, имеющую тип TransportationService. transportService (со строчной буквой t) — это переменная, а TransportationService (с прописной буквой T) — это тип. Эти два соглашения об именах называются camelCase и PascalCase соответственно. Использование camelCase для переменных класса и PascalCase для имен классов и интерфейсов является соглашением, встречающимся во всем Angular.

//TODO: Event Binding (Привязка событий)
// До этого момента мы в основном считывали данные в Angular и выводили их на экран. Что, если бы мы действительно захотели изменить какие-то данные или отреагировать на пользовательские события? Вот где в игру вступает привязка событий Angular. События на основе браузера в Angular обычно привязаны к методам в соответствующих компонентах. Вот пример кнопки, которая вызывает оповещение.
// HTML: app.component.html
{
  /* <button (click)="saySomething()"> Say Something </button> */
}
// TypeScript (TS): app.component.ts
// saySomething() {
//   alert('good day.');
// }
// Давайте разберем этот код.
// HTML:
{
  /* <button (click) = "saySomething()" > Say Something </button> */
}
// Здесь мы вставили обработчик нажатия на кнопку, который срабатывает всякий раз, когда происходит событие нажатия. Это запускает метод "saySomething()" в компоненте. В Angular скобки вокруг обработчика событий в теге html обозначают то, что мы называем event binding (привязкой события). В этом случае «click» заключен в круглые скобки (click), что связывает это событие с методом, переданным в кавычках, то есть «saySomething()». В Интернете происходит много других типов событий: click (щелчок), change (изменение), mouseover (наведение мыши), hover (наведение), dragover (перетаскивание), etc (и т.д.) — все это примеры событий, которые являются результатом действий пользователя. Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-simple-event?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-simple-event
// Обратите внимание, что вы должны использовать () после saySomething() для запуска метода в соответствующем файле app.component.ts. Это связано с тем, что Angular не только привязывает действие к событию, но и запускает событие при нажатии, аналогично в контексте выполнения собственному методу вызова JavaScript. () после метода символизирует запуск события после нажатия этой кнопки.

//TODO: Making a Counter (Создание счетчика)
// Наше следующее упражнение — это пример использования событий щелчка для увеличения счетчика. Когда вы нажимаете на кнопку, счетчик увеличивается.
// Как вы понимаете, нам нужна кнопка с событием клика в представлении, которое привязано к соответствующему методу в компоненте: app.component.html.
// HTML: app.component.html
{
  /* <div class="container">
  <div class="number-display">
    {{counter}}
  </div>
    <button (click)="increment()"> increment </button>
 </div> 
</div> */
}
// TypeScript (TS): app.component.ts
// counter = 0;
// increment() {
//   this.counter++;
// }
// В представлении HTML внутри тега <button> находится метод (щелчок). Это отправляет команду компоненту для запуска метода increment(). Центром функциональности здесь является переменная counter. При нажатии кнопки counter увеличивается. Результат отображается в представлении, потому что {{ counter }} всегда будет содержать обновленное значение переменной counter по мере его увеличения с помощью кликов.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-counter-increment?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-counter-increment
// События дополнительно демонстрируют тесную связь между файлами представления и компонентами.

//TODO: Event Updating a String (Событие, обновляющее строку)
// Попробуем другое упражнение: мы хотим обновить строку событием. В этом примере каждый раз, когда мы нажимаем кнопку, к существующей строке будет добавляться еще несколько слов. Строка будет начинаться со слов «Please», и каждый раз, когда мы нажимаем на кнопку, в конец строки будут добавляться слова «...Пошёл Ты»:
// HTML: app.component.html
{
  /* <div class="display">
  {{phrase}}
</div>
<button (click)="update()"> click me </button> */
}
// TypeScript (TS): app.component.ts
// phrase = "Please";
// update() {
//   this.phrase+=" ...Пошёл Ты";
// }
// Опять же, у нас есть кнопка, связанная с методом, который срабатывает в компоненте. Компонент имеет переменную под названием «phrase», которая начинается всего с двух слов: «Please». Однако каждый раз, когда вы нажимаете кнопку, запускается метод update(), и знак += в этом выражении заставляет компонент добавлять « ...Пошёл Ты» в конец предыдущей фразы. В результате фраза становится все длиннее, длиннее и длиннее каждый раз, когда мы нажимаем кнопку. Это лучше видно в действии! Либо посетите код StackBlitz в режиме онлайн, либо просмотрите на GitHub, чтобы увидеть, как это работает. Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-event-update-string?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-counter-increment
// События являются основной частью любого проекта Angular. На самом деле, события действительно являются ключевыми для всех фреймворков TypeScript и JavaScript и большинства приложений, использующих JavaScript в целом.
//TODO: TASK: Кнопка будет удваивать целое число при каждом нажатии кнопки.
// TypeScript (TS): app.component.ts   COMPONENT:
// counter = 1;
// double() {
// this.counter*=2;
// }
// HTML: app.component.html   VIEW:
// {{counter}}
// <button (click) = "double()" > double the number </button>

//TODO: One Way Data Binding (Односторонняя привязка данных)
// Вы часто будете слышать, как разработчики говорят об «one way data binding» и «two way data binding», когда речь идет о  front-end JavaScript-фреймворках. Что такое привязка данных? Привязка данных описывает поток данных от component (компонента) к view (представлению). Во всех примерах привязки событий в предыдущем уроке использовалась односторонняя привязка данных.
// Давайте посмотрим на поток данных счетчика, чтобы проанализировать, как работает односторонняя привязка данных:
// См. Рис: One Way Data Binding.png
// 1. Пользователь нажимает кнопку в view (представлении). Событие (щелчок) связано с методом "increment()", запрашивая у компонента запуск метода с тем же именем increment() {this.counter++}.
// 2. Компонент получает событие click и запускает метод increment() {this.counter++}, который обновляет counter (счетчик).
// 3. Переменная counter (счетчика) в компоненте обновляется, а затем отправляет это обновленное значение в view (представление).
// 4. view (представление) получает обновленную переменную {{counter}} (счетчика), а затем обновляет отображение, чтобы пользователь увидел появление нового числа.
// При односторонней привязке данные передаются в одном направлении. Представьте себе потолочный вентилятор. Несмотря на то, что лопасти движутся по кругу, движение по-прежнему происходит только в одном направлении.

//TODO: Two Way Data Binding (Двусторонняя привязка данных)
// Двусторонняя привязка данных — это когда поток данных между view (представлением) и component (компонентом) идет в обоих направлениях. Есть центральная «model» или variable container (переменный контейнер). Если он обновляется в view (представлении), компонент получает изменение. Если он обновляется в component (компоненте), то view (представление) получает изменение. Поток данных может идти в любом направлении. Когда был выпущен Angular 1 (AngularJS), одним из его ключевых преимуществ была врожденная способность выполнять двустороннюю привязку данных. С тех пор разработчики пришли к единому мнению, что двухстороннюю привязку данных следует использовать с осторожностью из-за высоких требований к системным ресурсам. При этом двусторонняя привязка данных по-прежнему возможна в Angular 8. Есть определенные ситуации, когда она может быть полезна при разумном использовании.
// В этом уроке мы реализуем простой виджет, который позволит вам видеть, что вы печатаете, отражаясь в представлении, когда вы печатаете это в режиме реального времени. Конечная цель состоит в том, что вы можете вводить текст в текстовое поле и видеть, что результат того, что вы набрали, сохраняется в модели, которая отображается в представлении.
// Модель — это контейнер, который содержит значение переменной. Модель доступна в component (компоненте) и связанном с ним view (представлении).

//TODO: Banana in a Box (Банан в коробке)
// Конструкция, допускающая двустороннюю привязку данных, выглядит так:
// HTML: app.component.html
{
  /* <input [(ngModel)] = "username"> */
}
// Конструкция [()] в Angular обеспечивает двустороннюю привязку данных. Некоторые разработчики называют это «бананом в коробке». На самом деле это комбинация квадратных скобок [ ], которые указывают на привязку данных из component (компонента) к view (представлению) («прямоугольник»), и круглых скобок ( ), которые включают привязку данных из view (представления) к component (компоненту) («банан»). Мы уже видели скобки в view (представлении) ранее:
// TypeScript (TS): app.component.ts
// button (click) = "increment()"
// В нашем примере <button (click) = "increment()"> (click) был примером односторонней привязки данных из view (представления) к component (компоненту). Квадратные скобки, с другой стороны, представляют поток данных от component (компонента) обратно в view (представление). Соединяя их вместе, Angular дает нам двунаправленный поток данных. «Банан в коробке».
// Модели Angular, реализованные через ngModel, не имеют ничего общего с базами данных или хранилищем на сервере. Модель в Angular временно хранит данные во внешнем приложении.

//TODO: ngModel (Angular Модель)
// Давайте посмотрим на схему двухсторонней привязки данных. Данные идут в двух направлениях. Когда вы вводите что-то в поле ввода в VIEW, он обновляет model  в COMPONENT, который затем отправляет обновленное значение model обратно в VIEW. Все это происходит почти мгновенно. Это возможно благодаря особому типу модели под названием ngModel. ngModel позволяет вам вводить поле и наблюдать, как значение этой переменной обновляется мгновенно по мере ввода.
// Вот код, который заставляет ngModel работать в view (представлении):
// HTML: app.component.html
{
  /* <input [(ngModel)]="username" placeholder="enter a username"> */
}
// См. Рис: ngModel.png
// В некотором смысле этот поток данных немного проще, чем диаграмма для односторонней привязки данных. Поиграйте с этим примером двусторонней привязки данных по предоставленной ссылке.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-two-way-data?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-two-way-data
// Angular использует конструкцию ngModel для хранения переменных, которые будут использоваться в двустороннем контексте привязки.

//TODO: ngModel Deconstructed (ngModel деконструированная)
// Давайте разберем, как на самом деле работает ngModel.
// 1. Пользователь вводит текст в поле, а затем содержимое этого поля сохраняется НЕПОСРЕДСТВЕННО в ngModel под названием «username».
// 2. Переменная «username», которая хранится в ngModel, хранится в компоненте.
// 3. view (представление), которое постоянно отслеживает изменения в ngModel, обновляет {{ username }}, чтобы оно соответствовало введенному пользователем. Все это происходит мгновенно. Модель можно рассматривать как просто контейнер, в котором хранится информация. Существует значительное количество теории о том, что это влечет за собой. О шаблонах MVC (model-view-controller) и MVVM (Model-View ViewModel) написано много. Не слишком углубляясь в теорию, мы можем просто сказать, что модель — это представление данных домена. Другими словами, во front-end модель представляет собой контейнер, в котором хранятся переменные. Когда мы печатали в поле ввода, содержимое поля ввода немедленно сохранялось в переменной username.
// Еще раз просмотрите StackBlitz:
// https://stackblitz.com/edit/angular-two-way-data?file=README.md
// View на GitHub:
// https://github.com/SoloLearn-Courses/angular-two-way-data
// ngModel содержит информацию, которую можно изменить и получить к ней доступ как в компоненте, так и в представлении.

//TODO: Two Way Data Bind Setup (Настройка двусторонней привязки данных)
// В этом разделе приведены инструкции по настройке двусторонней привязки данных на компьютере. Для целей этого курса FormsModule уже импортирован в примеры StackBlitz и GitHub. [(ngModel)] не будет работать из коробки в компоненте Angular. Чтобы это работало, мы должны предоставить поддержку для этого в компоненте. По умолчанию приложения относительно тонкие. Они включают только базовые функции, необходимые для большинства приложений. Двусторонняя привязка данных не потребуется в каждом отдельном приложении, поэтому по умолчанию ее нет в вашем проекте. Вы можете дать ему эту функциональность, импортировав модуль форм в ваш файл app.module.ts (или в любой другой модуль, в котором вы работаете). В вашем файле app.module.ts вы должны импортировать:
// TypeScript (TS): app.component.ts
// import { FormsModule } from '@angular/forms'
// А затем добавьте FormsModule к вашему импорту в app.module.ts. На приведенном ниже рисунке показано, как решаются эти две задачи.
// См. Рис: Two Way Data Bind Setup.png
// В примерах StackBlitz и GitHub мы импортировали для вас FormsModule, поэтому он уже настроен.

//TODO: Sending Hard Coded Data to a Service (Отправка жестко закодированных данных в сервис)
// Теперь, когда у нас есть представление о том, как мы можем вводить данные в текстовое поле и хранить их в модели, мы почти готовы отправить новые данные в наш массив cars. Для этого нам сначала нужно изучить, как сервис может получать данные, а не просто экспортировать данные. Давайте сделаем это сейчас. В нашем компоненте давайте добавим метод addCar(), который добавляет новый автомобиль в транспортный сервис. Этот метод может выглядеть так:
// TypeScript (TS): transport.service.ts
// addCar(car: Car){
//   this.cars.push(car);
// }
// Здесь наш метод addCar принимает автомобиль типа Car в качестве единственного аргумента. Затем он добавляет его к существующему массиву автомобилей. В нашем компоненте мы сделаем метод, который отправляет заранее собранный автомобиль в массив каждый раз, когда метод срабатывает:
// TypeScript (TS): app.component.ts
// addCar( ) {
//   const newCar: Car = {make: "Tesla", model: "X", miles: 100 };
//   this.transportationService.addCar(newCar);
// }
// Наконец, мы создадим кнопку в view (представлении), которая будет вызывать метод addCar():
// HTML: app.component.html
{
  /* <button (click)="addCar()">add Car</button> */
}
// Если вы когда-нибудь хотели новую Tesla, это ваш шанс! Мы написали код, чтобы мгновенно доставить новый к вашей двери! Вы получите автомобиль! И ВЫ получите машину!!!.... и т.д. Каждый раз, когда мы нажимаем кнопку, появляется новая Тесла.
// См. Рис: Sending Hard Coded Data to a Service.gif
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-send-static-data-to-service?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-send-static-data-to-service
// Сервисы могут отправлять и получать данные от компонентов.

//TODO: Sending Dynamic Data to a Service (Отправка динамических данных в сервис)
// Теперь мы собираемся сделать последний шаг, чтобы связать все воедино с точки зрения добавления автомобилей в наш сервис данных. В реальном мире мы редко отправляем «жестко закодированные» данные в ресурс данных! Нам нужен механизм, который позволит нам вводить ЛЮБУЮ информацию об автомобиле и обновлять ее в нашем массиве автомобилей. Мы добьемся этого сейчас. Мы можем сохранить соответствующие методы addCar как в транспортном сервисе, так и в компоненте. Единственным изменением будет сбор данных о марке, модели и пробеге нового автомобиля в 3 новых ngModels, а затем замена жестко закодированных данных нашими реальными данными. Вот и все! Начнем с компонента:
// TypeScript (TS): app.component.ts
// мы бы добавили эти переменные в наши объявления переменных:
// declarations:
// make: string;
// model: string;
// miles: number;
// А затем измените назначение переменной newCar в нашем методе addCar в компоненте, чтобы он использовал наши новые динамические переменные (марка, модель и мили)…
// TypeScript (TS): app.component.ts
// const newCar: Car = {make: this.make, model: this.model, miles: this.miles };
// Наконец, мы добавим в представление поля ввода для марки, модели и пробега.
// HTML: app.component.html
{
  /* <input [(ngModel)]="make" placeholder="make">
<input [(ngModel)]="model" placeholder="model">
<input type="number" [(ngModel)]="miles" placeholder="miles"> */
}
//И теперь код должен просто работать! Когда вы вводите марку, модель и пробег нового автомобиля и нажимаете кнопку, он отправляется в наш поток данных и обновляется в сервисе, который затем обновляет view (представление), и все наши новые автомобили появляются по мере их создания. Попробуй сам! Поэкспериментируйте с кодом и даже удалите некоторые из них и попытайтесь перестроить его самостоятельно, чтобы получить представление об этом потоке данных. Наш следующий шаг — узнать, как подключить приложение Angular к реальному BACK-END, чтобы данные могли сохраняться в базе данных! Оставайтесь в курсе.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-send-dynamic-data-to-svs?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-send-dynamic-data-to-svs
// На странице может быть сколько угодно ngModels. Это быстрый и простой способ сбора данных для отправки в наш сервер.

//TODO: Introduction (Вступление)
// Добро пожаловать в модуль Базы данных. В этом модуле мы рассмотрим причины, по которым мы используем базы данных, а также продемонстрируем два наиболее распространенных типа баз данных. Мы рассмотрим relational database (реляционную базу данных) (PostgreSQL) и non-relational database (нереляционную базу данных) (MongoDB). Реляционные базы данных хранят данные в таблицах и строках, а нереляционные базы данных хранят данные в коллекциях. В этом модуле мы будем сравнивать эти два типа баз данных. Каждый тип базы данных служит различным вариантам использования. Мы собираемся пройтись по каждому и выделить преимущества использования того или другого. Давайте начнем с вопроса, на который мы надеемся получить ответ к концу этого урока. Если бы вам нужно было хранить информацию для приложения, как бы вы это сделали?
// Существует два распространенных типа баз данных: реляционные и нереляционные.

//TODO: Volatile vs Non-volatile Storage (Энергозависимое и энергонезависимое хранилище)
// «Если бы вам нужно было хранить информацию для приложения, как бы вы это сделали?» Первым вашим побуждением здесь может быть использование переменной. Вы уже использовали переменные для хранения информации для приложения, так что это кажется логичным выбором! Однако есть одно место, где переменные терпят неудачу. Когда мы создаем приложение, мы хотим, чтобы наша информация сохранялась, то есть мы хотим, чтобы она оставалась там после перезапуска нашего приложения. При повторном запуске приложения все переменные сбрасываются. Это означает, что мы не можем использовать переменные как способ долгосрочного хранения информации. Мы можем использовать их только для временного удержания ценностей. Переменные хранятся в Volatile storage (энергозависимом хранилище) (или памяти). Нам нужно хранить нашу важную информацию в Non-volatile storage (энергонезависимом хранилище), чтобы он сохранялся даже при перезапусках или сбоях. Это дыра, которую заполняют базы данных. Они хранят информацию в Non-volatile storage (энергонезависимом хранилище), поэтому она сохраняется при перезапусках или сбоях.
// Volatile storage (Энергозависимое хранилище) не сохраняется при перезапуске (например, переменные), тогда как non-volatile storage (энергонезависимое хранилище) сохраняется при перезапуске (например, файлы, хранящиеся на жестком диске).

//TODO: Other Benefits of Modern Databases (Другие преимущества современных баз данных)
//   Скорость поиска:
// Базы данных способны очень быстро выполнять поиск в больших объемах информации. Это еще одна причина, по которой мы используем их, а не просто помещаем все наши данные в один большой файл.
//   Согласованность данных:
// Реляционные базы данных также дают нам преимущество хранения информации в согласованных форматах, что упрощает написание программ. Например, при хранении информации о пользователе в реляционной базе данных мы всегда можем хранить одни и те же значения, такие как «имя» или «электронная почта», что позволяет очень легко писать логику позже. Нереляционные базы данных позволяют вставлять любую информацию без строгого форматирования, что отлично подходит для быстрого прототипирования.
// Двумя преимуществами баз данных являются точность и совместная работа. Данные сохраняются только один раз, что исключает дублирование данных, и несколько пользователей могут одновременно обращаться к базе данных, что делает ее инструментом для совместной работы.

//TODO: Storing a User (Сохранение пользователя)
// Представьте, что мы хотим хранить информацию о пользователе. Мы хотим сохранить их имя, адрес электронной почты и возраст. Учитывая то, что вы знаете сейчас, как бы вы это сохранили? Если вы использовали какое-либо программное обеспечение для работы с электронными таблицами, вы можете подумать о сохранении информации в какой-либо электронной таблице. Где у вас есть столбцы для имени, электронной почты и возраста, а затем в каждой строке вы храните другого пользователя. Вы также можете рассмотреть объекты JavaScript как хороший способ их хранения. Хранение каждого пользователя в виде отдельного объекта с парами ключ/значение для имени, электронной почты и возраста также кажется хорошим подходом. Оказывается, эти подходы — отличный способ подумать о наших двух разных типах баз данных. Реляционные базы данных хранят информацию в виде таблицы со столбцами и строками, аналогичной электронной таблице.
// нереляционные базы данных хранят информацию в формате JSON, как показано ниже, который очень похож на объект JavaScript.
// JSON:
// {
//   "name": "dave",
//   "email": "dave@sololearn.com",
//   "age": 25
// }
// Реляционные базы данных хранят информацию в столбцах и строках, где каждая строка представляет запись. Нереляционные базы данных хранят информацию в парах key value (ключ-значение).

//TODO: The SQL (relational) Approach (SQL (реляционный) подход)
//  Tables (Таблицы):
// В реляционной базе данных, такой как postgreSQL, мы храним нашу информацию в таблицах. Каждый ресурс (или часть данных для вашего приложения, таких как пользователи, сообщения, комментарии и т.д.) обычно получает свою собственную таблицу. Например, если мы создаем приложение для социальных сетей, у нас, вероятно, будет таблица для пользователей, таблица для сообщений и таблица для комментариев.
//  Columns (Столбцы):
// В таблице есть столбцы для каждого поля информации, которую нам нужно сохранить. Для нашего пользовательского примера у нас будет столбец имени, столбец электронной почты и столбец возраста.
//  Rows (Строки):
// Каждая строка в таблице представляет одну запись в этой таблице. Например, каждая строка в нашей пользовательской таблице будет другим пользователем, содержащим имя этого пользователя, адрес электронной почты и возраст.
// См. Рис: The SQL (relational) Approach
// Реляционные базы данных состоят из таблиц, в которых столбцы определяют, какую информацию мы храним, а строки хранят эту информацию для каждой записи.

//TODO: The noSQL (non-relational) Approach (NoSQL (нереляционный) подход)
//  collections (Коллекции):
// В нереляционной базе данных мы храним нашу информацию в коллекциях. Каждый ресурс обычно получает свою собственную коллекцию. Основное различие между коллекцией и таблицей заключается в отсутствии понятия столбцов. Мы можем хранить любую информацию, которую захотим, в коллекции. Мы могли бы сохранить одного пользователя с именем и фамилией, а другого только с именем.
// { name: "james smith" }
// // or
// { firstName: "james", lastName: "smith" }
//  documents (Документы):
// Документы — это JSON-подобные объекты. Каждый документ может содержать несколько полей (пары ключ/значение), а значением поля может быть практически любой тип данных JavaScript. Ниже вы можете увидеть пример документа из документации mongoDB (база данных noSQL, на которой мы сосредоточимся).
// См. Рис: The noSQL (non-relational) Approach.png
// Каждый документ может содержать несколько полей (пары ключ/значение), а значением поля может быть практически любой тип данных JavaScript.

//TODO: Example Use Cases (Примеры использования)
// Когда использовать реляционную базу данных
// Реляционные базы данных проверены временем. SQL 48 лет! Они обеспечивают очень строгую структуру для ваших данных. Это делает их очень хорошими для больших приложений, которым необходимо масштабировать и поддерживать большой объем данных или пользователей. Строгая структура ваших данных позволяет легко поддерживать согласованность и значительно упрощает написание кода для ваших приложений. Когда использовать нереляционную базу данных Нереляционные базы данных относительно новы на сцене баз данных. Они не применяют строгую структуру к вашим данным, что может затруднить масштабирование и работу с более крупными проектами. Однако гибкость и более быстрое время настройки позволяют очень быстро повторять идеи. Нереляционные базы данных идеально подходят для небольших проектов или проверки концепций.
// Реляционные базы данных отлично подходят для больших сложных приложений, тогда как нереляционные базы данных отлично подходят для небольших проектов проверки концепции.

//TODO: What is SQL (Что такое SQL)
// В этом модуле мы обсуждали реляционные и нереляционные базы данных и то, что делает их уникальными. Вы также можете услышать, как они называются базами данных SQL и NoSQL. Но что такое SQL? SQL означает Structured Query Language (язык структурированных запросов), и это язык программирования, который мы используем для связи с базами данных SQL. Это язык запросов, состоящий из множества ключевых слов, которые позволяют нам указывать нашей базе данных, что делать с данными.
// В этом модуле мы рассмотрим PostgreSQL. Если вы хотите узнать больше о другой реляционной базе данных, посмотрите наш курс по MySQL.

//TODO: Creating Tables (Создание таблиц)
// База данных SQL состоит из нескольких таблиц. Каждая таблица должна содержать данные для одного ресурса вашей программы. Мы хотим создать таблицу для хранения наших пользовательских данных (имя, адрес электронной почты и возраст). Давайте посмотрим, как мы могли бы сделать это в SQL.
// SQL:
// CREATE TABLE users (id SERIAL, name TEXT, email VARCHAR(255), age INT);
// Давайте начнем с рассмотрения нескольких основных принципов SQL. Во-первых, каждое выражение в SQL должно заканчиваться точкой с запятой. Во-вторых, по соглашению весь синтаксис SQL должен быть прописным, а любой определяемый вами синтаксис — строчным. Это означает, что CREATE TABLE является частью языка SQL, а users — это имя, которое мы определяем.
// Как и в JavaScript, в SQL есть типы данных, которые позволяют нам определять, какие типы информации мы будем хранить в каждом столбце.

//TODO: Data Types (Типы данных)
// Давайте продолжим рассмотрение нашего примера CREATE TABLE из предыдущей части.
// SQL:
// CREATE TABLE users (id SERIAL, name TEXT, email VARCHAR(255), age INT);
// Как и в JavaScript, в SQL есть типы данных. В нашем примере создания таблицы выше мы создаем 4 столбца с типами данных SERIAL, TEXT, VARCHAR(255), INT.
// 1). Тип данных SERIAL — это целое число, которое будет автоматически увеличиваться для каждой новой добавляемой строки. Это означает, что у нас будет уникальный идентификатор для каждой строки в нашей таблице!
// 2). Тип данных TEXT просто означает, что мы храним текстовые данные или строки в этом столбце.
// 3). Тип данных VARCHAR(255) означает переменный символ и также используется для хранения текстовых данных или строк. Основное отличие состоит в том, что мы можем определить ограничение на количество сохраняемых символов (в нашем случае мы ограничиваем его до 255 символов VARCHAR (255) ).
// 4). Наконец, тип данных INT позволяет хранить целые числа. Есть много других типов данных SQL, которые мы не собираемся здесь рассматривать. Если вам нужно сохранить определенный тип информации, посмотрите, какой тип данных лучше всего подходит для вашего случая использования.
// Как и в JavaScript, в SQL есть типы данных, которые позволяют нам определять, какие типы информации мы будем хранить в каждом столбце.

//TODO: Inserting Entries (Вставка записей)
// Теперь, когда у нас есть таблица, мы хотим вставить в нее пользователя. Давайте посмотрим на фрагмент кода, который позволит нам это сделать.
// SQL:
// INSERT INTO users (name, email, age) VALUES ("james", "james@sololearn.com", 30);
// Помните, что любой синтаксис SQL написан в верхнем регистре. Здесь мы начинаем с INSERT INTO (ВСТАВИТЬ В), за которым следует users - имя таблицы, в которую мы хотим вставить. Затем мы указываем столбцы в этой таблице, которые мы хотим вставить (name, email, age). Затем мы указываем VALUES (ЗНАЧЕНИЯ), которые хотим вставить в эти столбцы. Важно отметить, что порядок здесь имеет значение. Мы указываем значения в том же порядке, в котором мы перечисляли столбцы. Вот почему мы видим сначала «james», так как мы хотим, чтобы оно было вставлено в столбец имени. После вставки записи наша таблица будет выглядеть примерно так:
// См. Рис: Inserting Entries.png
// В операторе Insert мы должны указать значения в том же порядке, в котором мы перечислили столбцы.

//TODO: Selecting Data (Выбор данных)
// Теперь, когда мы вставили строку, мы хотим иметь возможность выбирать наши строки из нашей таблицы, чтобы мы могли просматривать наши данные.
// SQL:
// SELECT id, name, email, age FROM users;
// В операторе SELECT мы сначала указываем нужные столбцы (id, name, email, age). Затем мы указываем, из какой таблицы мы хотим их получить, используя FROM. Поскольку на самом деле мы запрашиваем каждый столбец в таблице, мы можем использовать:
// SQL:
// SELECT * FROM users;
// вместо того, чтобы явно запрашивать идентификатор, имя, адрес электронной почты, возраст! Вот как могут выглядеть результаты:
// См. Рис: Selecting Data.png
// В операторе SELECT мы сначала указываем нужные столбцы (id, name, email, age). Затем мы указываем, из какой таблицы мы хотим их получить, используя FROM.

//TODO: Where Clauses (WHERE (где) пункты)
// Заявление, которое мы рассматривали ранее, собирает данные обо всех пользователях. Если мы хотим указать конкретное условие, мы можем использовать пункт WHERE!
// SQL:
// SELECT * FROM users WHERE id = 1;
// Это вернет нам данные о нашем пользователе с идентификатором 1. Мы также можем использовать пункт WHERE, чтобы указать более надежные условия. Например, если бы мы хотели получить всех пользователей старше 25 лет, мы могли бы сделать:
// SQL:
// SELECT * FROM users WHERE age > 25;
// Мы также можем связать несколько условий вместе, используя оператор AND:
// SQL:
// SELECT * FROM users WHERE age > 25 AND name = 'david';
// Предложения WHERE позволяют нам указать определенные условия, которым должны соответствовать наши строки, чтобы быть возвращенными.

//TODO: Updating Data (Обновление данных)
// Часто нам нужно изменить информацию в наших программах. Давайте посмотрим, как обновлять данные в SQL.
// SQL:
// UPDATE users SET name = 'troy', age = 35 WHERE id = 3;
// В нашем операторе обновления мы сначала указываем, какую таблицу мы хотим обновить. В нашем случае мы хотим обновить таблицу «users», поэтому мы говорим «UPDATE users». Далее мы указываем, какие столбцы мы хотели бы обновить и что мы хотим установить для них SET name = 'troy', age = 35. Наконец, мы указываем предложение WHERE, которое сообщает SQL, какую строку следует обновить. Без этого он обновит все записи. Так что будьте осторожны! Если мы хотим обновить несколько записей, мы можем сделать это, используя другое предложение WHERE:
// SQL:
// UPDATE users SET age = 42 WHERE age = 24;
// Это обновит ВСЕХ пользователей в возрасте 24 до 42 лет.
// Операторы UPDATE в SQL позволяют нам обновлять одну или несколько строк в зависимости от условия.

//TODO: Deleting Data (Удаление данных)
// Иногда данные необходимо удалить. Пользователь может их удалить, если мы можем счесть их бесполезным! Давайте посмотрим на пример.
// SQL:
// DELETE FROM users WHERE id = 3;
// Мы начинаем оператор удаления с DELETE FROM, за которым следует имя нашей таблицы (в нашем случае users). Далее очень важно указать пункт WHERE. Без указания пункта WHERE мы удалим каждую строку в нашей таблице. Если мы хотим удалить несколько записей, мы можем сделать это, используя другое предложение WHERE.
// SQL:
// DELETE FROM users WHERE name = 'david';
// Это удалит ВСЕХ пользователей с именем david. Будьте очень осторожны при использовании операторов удаления с пунктом WHERE, которые не нацелены на один конкретный идентификатор.
// Операторы DELETE позволяют нам удалить одну или несколько строк в таблице.

//TODO: noSQL (не только SQL)
//  Differences from SQL (Отличия от SQL):
// noSQL означает «не только SQL», что означает, что вы можете запрашивать его, используя несколько языков. На рынке есть несколько вариантов noSQL, но мы сосредоточимся на mongoDB. mongoDB не имеет концепции таблиц/столбцов/строк. Вместо этого мы создаем коллекции для хранения наших данных и документов внутри них.
//  Collections (Коллекции):
// Коллекции — это mongoDB, эквивалентные таблицам. Именно в них мы храним наши данные. Ключевое различие между таблицей и коллекцией заключается в том, что таблицы принудительно заполняют определенные столбцы для каждой строки. Коллекции не заботятся о том, что вы храните внутри них.
//  Documents (Документы):
// Документы выполняют ту же работу, что и строки в SQL. Например, если бы у нас была коллекция пользователей, у нас был бы один документ для каждого пользователя.
//  Fields (Поля):
// Думайте о полях как о парах ключ-значение в объекте JavaScript. Они похожи на столбцы в SQL, но основное отличие состоит в том, что поля не обязательно должны быть одинаковыми в коллекции.
// База данных NoSQL — это база данных, которая не использует SQL в качестве языка для запроса данных. У него нет понятия таблиц/столбцов/строк. Вместо этого мы создаем коллекции для хранения наших данных и документов внутри них.

//TODO: Creating & Inserting into Collections (Создание и вставка в коллекции)
// Когда мы использовали SQL, мы создавали таблицы, написав запрос CREATE TABLE. Причина, по которой мы это сделали, заключается в том, что нам нужно было определить столбцы и типы данных, которые будут содержаться в таблице. Однако в mongoDB коллекции могут содержать любые данные! В результате нам не нужно явно создавать их. Вместо этого они будут созданы автоматически. Давайте начнем с рассмотрения объекта JavaScript, который мы хотим вставить в коллекцию пользователей.
// { name: "james", email: "james@sololearn.com", age: 28 }
// Мы можем вставить объект в коллекцию с помощью оператора insertOne() .
// db.usersCollection.insertOne()
// Здесь наш оператор начинается с db.usersCollection. Вы можете спросить себя… Откуда это взялось?! Это часть магии mongoDB. Если коллекция не существует, она будет автоматически создана при первой вставке в нее. Мы следуем за нашей коллекцией пользователей с помощью .insertOne(), куда мы помещаем объект, который хотим вставить!
// db.usersCollection.insertOne({
//   name: "james",
//   email: "james@sololearn.com",
//   age: 28,
// })
// Это вставит наш исходный объект в usersCollection. Этот исходный объект теперь является документом mongoDB! Mongo также позволяет нам вставлять другие типы данных, такие как массивы! Например, мы можем вставить список любимых фруктов наших пользователей!
// db.usersCollection.insertOne({
//   name: "james",
//   email: "james@sololearn.com",
//   age: 28,
//   favoriteFruits: [ "apples", "grapes"]
// });
// В mongoDB, если коллекция не существует, она будет автоматически создана при первой вставке в нее. Мы можем вставить любой документ в коллекцию.

//TODO: Selecting Documents (Выбор документов)
// Мы только что вставили пользователя в нашу коллекцию пользователей. Как нам вернуть эти данные?
// db.usersCollection.find({ name: "james"})
// Подобно синтаксису вставки, мы начинаем с db.usersCollection, чтобы сообщить mongoDB, какую коллекцию мы запрашиваем. После этого мы делаем .find() и указываем запрос, который мы хотим найти в mongoDB. В нашем случае мы хотим найти документ с именем «james». Это вернет нам документ, который выглядит примерно так:
// {
//   _id: ObjectId("5099803df3f4948bd2f98391"),
//   name: "james",
//   email: "james@sololearn.com",
//   age: 28
// }
// Вероятно, это похоже на то, что вы ожидаете от документа, за исключением одного… Что такое _id ? Мы никогда не вставляли это?! Как мы обсуждали на уроке SQL, наличие уникального идентификатора для записей очень полезно. Настолько полезно, что mongoDB будет автоматически генерировать один для каждого документа.
// Если вы запрашиваете коллекцию MongoDB и вам нужно указать несколько условий, вы можете передать несколько пар ключ-значение в метод поиска. .find() будет использовать каждую пару ключ-значение как условие, которое должно соответствовать запросу.
// db.collectionName.find({name: "james", age: 23})

//TODO: Updating Documents (Обновление документов)
// Обновление документов в mongoDB начинается очень похоже на выбор документов. Нам нужно указать запрос, чтобы мы не обновляли все подряд. Давайте углубимся в пример:
// db.usersCollection.update(
//   { name: 'james' },
//   {
//     $set: {
//       age: 45,
//     },
//   }
// )
// Оператор обновления начинается с того, что мы указываем, какую коллекцию мы хотели бы обновить. Затем мы запускаем наш .update(). Первое, что мы должны определить, это параметр запроса. Вот как мы говорим монго, что нужно найти и обновить. В нашем случае это { name: "james" }. Далее мы говорим mongo, что нужно обновить. Мы делаем это с помощью операторов mongoDB. В mongoDB много операторов, но мы сосредоточимся только на том, который используем здесь. Мы используем $set, чтобы сообщить mongoDB, какие поля необходимо обновить и какое значение для них установить (в нашем случае возраст установлен на 45).
// При обновлении документа мы используем $set, чтобы сообщить MongoDB, какие поля необходимо обновить и какое значение для них установить.

//TODO: Deleting Documents (Удаление документов)
// Удаление документов в mongoDB просто требует условия для запроса. Мы рассмотрим пример .deleteOne(), но есть и .deleteMany(), если вам нужно удалить несколько документов.
// db.usersCollection.deleteOne({ _id: ObjectId('5099803df3f4948bd2f98391') })
// Здесь мы говорим mongoDB удалить документ с _id, который мы нашли при запросе нашего пользователя в предыдущей части. Вообще говоря, вы хотите использовать _id при удалении документов. Это делается для того, чтобы вы могли избежать случайного удаления информации. Вы можете удалить не того Джеймса!
// При удалении документа в mongoDB мы можем вызвать .deleteOne() для удаления одного документа или .deleteMany() для удаления нескольких.

//TODO: What is an ORM (Object Relational Mapping) (Что такое ОРМ (объектно-реляционное отображение))
//  ORMs:
// ORM (Object Relational Mapping) (объектно-реляционное отображение) — это метод, который позволяет вам взаимодействовать с базой данных, используя объектно-ориентированный шаблон. Часто, когда мы говорим об ORM, мы используем этот термин для описания библиотеки, реализующей объектно-реляционное отображение (отсюда и «ORM»).
//  Advantages of ORMs (Преимущества ORMs):
// ORMs сопоставляют наши записи базы данных с объектами, которые мы определяем. Это позволяет нам написать много повторно используемой логики для нашей базы данных. Это также упрощает многие наши более сложные запросы и может уменьшить раздувание нашей кодовой базы. Большинство ORM также имеют встроенную защиту от SQL-инъекций.
//  Disadvantages of ORMs (Недостатки ORMs):
// ORMs не идеальны для каждого проекта. Часто у вас не будет прямого контроля над SQL, который ORM использует под капотом. Иногда это может сделать запросы медленнее, чем если бы вы писали их вручную. ORM также более подвержены ошибкам, чем SQL. Легче случайно создать функцию, которая запрашивает базу данных 200 раз в ORM по сравнению с SQL, поскольку вы не всегда можете понять, когда функция запускает запрос. Хотя в этом модуле мы не обсуждаем NoSQL, существует множество доступных ORM NoSQL!
// ORM (Object Relational Mapping) — это метод, который позволяет вам взаимодействовать с базой данных, используя объектно-ориентированный шаблон.

//TODO: Communicating with a Database (Взаимодействие с базой данных)
// Чтобы наши программы могли хранить данные, нам нужна база данных. Это означает, что нам также нужен способ связи с этой базой данных. Если бы мы хотели обмениваться данными из TypeScript с базой данных PostgreSQL, как бы мы это сделали? Вашим первым побуждением может быть использование SQL. Что, если бы существовал способ написать SQL для запросов к базе данных на TypeScript?
// TypeScript (TS):
// db.query("SELECT * FROM users");
// Это сработает, но приведет к множеству неудобных результатов. Во-первых, любые сложные запросы будут очень длинными и раздуют нашу кодовую базу. Во-вторых, при таком подходе сложно повторно использовать код, скорее всего, мы будем писать одни и те же запросы во многих местах. Наконец, написание необработанных запросов делает нас уязвимыми для атаки SQL Injection. Мы не будем вдаваться в подробности, что это влечет за собой, но это атака, нацеленная на необработанные SQL-запросы.
// Пример атаки с внедрением SQL включает в себя поиск скрытых данных, которые затем возвращают дополнительные результаты в запрос SQL.

//TODO: Choosing an ORM (Выбор объектно-реляционного отображения)
// Большинство современных объектно-ориентированных языков имеют несколько вариантов ORM для вашего проекта. Однако в любом языке, как вы решаете, какой ORM использовать? Самое важное, на что следует обратить внимание, — какую базу данных вы используете. Не каждая ORM поддерживает все типы баз данных. Некоторые ORM также поддерживают только один конкретный экземпляр базы данных! Например, ORM может поддерживать PostgreSQL, но не может поддерживать SQLite (это другая реляционная база данных). Также важно учитывать статус ORM. Важно знать, ведется ли над ним активная работа или он устарел. Для нашего проекта нам нужен ORM TypeScript, поддерживающий Postgres. TypeORM — это ORM, который мы решили использовать, поскольку у него отличная документация и он постоянно обновляется.
// При выборе ORM для вашего проекта важно найти ту, которая поддерживает вашу базу данных и активно обновляется.

//TODO: Introduction to TypeORM (Введение в TypeORM)
// В этом модуле мы будем использовать TypeORM, чтобы продемонстрировать множество ключевых концепций ORM. Это ORM TypeScript, который часто используется в NestJS, что делает его идеальным для нашего стека. TypeORM поддерживает как SQL, так и NoSQL, но мы собираемся использовать его с PostgreSQL. TypeORM позволяет нам писать код в нескольких парадигмах, что означает, что вы можете очень легко адаптировать его для разных стилей кодирования. TypeORM имеет множество функций, и мы собираемся обсудить здесь основы. Если вы хотите погрузиться глубже после этого модуля, у них есть замечательная документация, которую можно найти на typeorm.io .
// https://typeorm.io/
// TypeORM — это ORM для TypeScript, который поддерживает как SQL, так и NoSQL.

//TODO: Installing TypeORM (Установка TypeORM)
//TODO: https://www.youtube.com/watch?v=msVhfCzFWvY
//TODO: https://www.youtube.com/watch?v=gfTFSeAKzEk
//TypeORM  — это модуль NPM, поэтому мы можем установить его с помощью интерфейса командной строки NPM. Сначала мы устанавливаем базовый модуль TypeORM:
// npm install typeorm
// Далее нам нужно установить отражающие метаданные и импортировать их в наш основной файл. Метаданные Reflect требуются TypeORM, чтобы мы могли использовать его декораторы.
// npm install reflect-metadata --save
// import 'reflect-metadata';
// // Где-то в нашем основном файле (main.ts, app.module.ts, app.controller.ts, app.service.ts)
// Наконец, установите драйвер базы данных для любого экземпляра базы данных, который вы используете. В нашем случае мы используем PostgreSQL (pg), поэтому нам нужно установить модуль pg.
// npm install pg
// Теперь все установлено, и мы готовы к погружению!
// TypeORM — это модуль npm, поэтому мы можем установить его с помощью интерфейса командной строки npm. Мы также можем установить его с помощью пряжи!

//TODO: Creating a Connection (Создание соединения)
// Теперь, когда у нас установлен TypeORM, нам нужно создать объект подключения для связи с нашей базой данных. Давайте посмотрим на шаблонный код, который позволит нам это сделать.
// TypeScript (TS):
// import { createConnection, Connection } from "typeorm";

// const connection = await createConnection({
//   type: "postgres",
//   host: "localhost",
//   port: 5432,
//   username: "vitalyvitmens",
//   password: "",
//   database: "transportation"
// });
// Здесь мы вызываем createConnection, который поступает из модуля TypeORM. Мы передаем функции объект с параметрами конфигурации, чтобы сообщить ей, как подключиться к нашей базе данных. Вам нужно будет заменить свое имя пользователя, пароль и базу данных на те, которые вы настроили, когда установили postgres/настроили базу данных для своего проекта.
// Если вы выбрали параметры установки по умолчанию для PostgreSQL, вы должны оставить хост и порт такими же, как в этом примере.

//TODO: Creating an Entity (Создание Сущности)
// Сущности (часто называемые моделями в других ORM) — это то, где мы определяем содержимое нашей таблицы для системы типов. Вот как мы сообщаем TypeORM, какие столбцы существуют в таблице и что мы можем запрашивать. Давайте рассмотрим пример сущности.
// TypeScript (TS):
// @Entity()
// export class User {
//   @PrimaryGeneratedColumn()
//   id: number;

//   @Column()
//   name: string;

//   @Column()
//   email: string;

//   @Column()
//   age: number;
// }
// Мы начинаем с того, что сообщаем TypeORM, что мы определяем сущность, предваряя наш класс декоратором @Entity. Далее мы назовем наш класс (в нашем случае User). Затем мы можем определить столбцы, которые существуют в нашей таблице, и типы данных, с которыми мы хотим, чтобы они были связаны в TypeScript. Мы используем @Column для аннотирования каждого создаваемого нами столбца. Для нашего идентификатора мы указываем, что это первичный ключ, который автоматически генерируется для нас с помощью @PrimaryGeneratedColumn() .
// Нам не нужно беспокоиться о типах данных SQL при использовании TypeORM. Он автоматически преобразует тип данных TypeScript в тип данных SQL. Однако, если мы хотим больше контролировать, какой тип данных он использует в SQL, вы можете передать дополнительные параметры декоратору @Column.

//TODO: TypeORM Repositories (Репозитории TypeORM)
// В TypeORM репозитории позволяют нам создавать объект, который позволяет нам запрашивать сущность. Рассмотрим пример создания репозитория.
// TypeScript (TS):
// const repository = getRepository(User);
// Здесь мы вызываем getRepository(), который исходит от TypeORM. Затем мы передаем объект, для которого мы хотели бы использовать репозиторий, в функцию getRepository(). В нашем случае мы хотим, чтобы репозиторий был для сущности пользователя. Мы присваиваем это переменной для будущего использования.
// Репозитории позволяют нам запрашивать одну конкретную сущность. Мы не можем запрашивать другие сущности, кроме той, которая связана с репозиторием.

//TODO: Inserting Data (Вставка данных)
// В SQL вы, вероятно, использовали оператор INSERT для вставки данных в нашу таблицу. При использовании TypeORM мы можем вставлять информацию другим способом. Мы вставляем информацию, создавая экземпляр объекта, обновляя поля, которые мы хотим установить, и сохраняя их.
// TypeScript (TS):
// const user = new User();
// user.name = "Troy";
// user.email = "troy@sololearn.com";
// user.age = 25;
// await repository.save(user);
// Здесь мы создаем экземпляр нового пользователя, как и в любом другом классе TypeScript! Затем мы меняем атрибуты пользователя на то, что мы хотим сохранить (например, user.age = 25 ). Наконец, мы ожидаем репозиторий.save(user); Это сохранит пользователя и не будет запускать код после этой строки, пока этот пользователь не будет сохранен!
// Чтобы вставить данные в TypeORM, мы создаем экземпляр объекта из нашего класса сущностей, затем устанавливаем атрибуты для наших желаемых данных и, наконец, сохраняем их с помощью репозитория.save().

//TODO: Selecting Data (Выбор данных)
// TypeORM дает нам надежный метод find(), который мы можем использовать для выбора данных на основе условий.
// TypeScript (TS):
// const results = await repository.find({where: {name: "Troy"}});
// Здесь мы вызываем метод find() в нашем пользовательском репозитории. Мы даем find() объект, указывающий, какие параметры мы хотим использовать при выборе. В нашем случае мы сообщаем find(), что хотим использовать пункт where для поиска пользователей по имени Трой. Это приведет к запуску следующего SQL.
// SQL:
// SELECT * FROM users WHERE name = "Troy";
// Это даст нам ВСЕХ пользователей с именем Троя. TypeORM предоставит нам это как массив объектов сущностей пользователя. Если нам нужен только один пользователь, мы можем вместо этого использовать findOne.
// TypeScript (TS):
// const result = await repository.findOne({where: {name: "Troy"}});
// В TypeORM мы можем вызвать метод find() в репозитории, чтобы выбрать данные из сущности.

//TODO: Updating Data (Обновление данных)
// Теперь, когда мы знаем, как вставлять и выбирать данные. Мы объединяем эти две концепции для обновления данных. Если мы используем .save() и строка уже существует, она обновит строку вместо вставки новой.
// TypeScript (TS):
// const myUser = await repository.findOne({where: {name: "Troy"}});
// myUser.email = "t@sololearn.com";
// await repository.save(myUser);
// Мы используем findOne, чтобы найти пользователя, которого хотим обновить. Затем мы меняем атрибуты объекта, который хотим обновить (в нашем случае мы обновляем электронную почту). Наконец, мы сохраняем пользователя так же, как мы сохраняем нового пользователя! TypeORM обновит его для нас!
// В TypeORM мы можем обновлять строки, используя .find() или .findOne(), чтобы найти строки, которые мы хотим обновить, затем изменить атрибуты в TypeScript, а затем сохранить запись с помощью .save().

//TODO: Deleting Data (Удаление данных)
// Чтобы удалить строку в TypeORM, нам нужно сначала использовать .find() или .findOne(), чтобы найти строку, которую мы хотим удалить. Далее мы можем передать идентификатор в .delete()
// TypeScript (TS):
// const myUser = await repository.findOne({where: {name: "Troy"}});
// await repository.delete(myUser.id);
// Мы используем findOne, чтобы найти пользователя, которого хотим удалить. Затем мы передаем атрибут идентификатора пользователя в .delete(). Мы можем передать .delete() один идентификатор или массив идентификаторов, если мы хотим удалить нескольких пользователей. Мы также можем передать ему другие условия, если мы хотим удалить всех пользователей с именем «Troy», например, мы могли бы это сделать.
// TypeScript (TS):
// await repository.delete({name: "Troy"});
// Мы можем использовать .delete() для удаления строк в TypeORM. Мы передаем ему идентификатор, массив идентификаторов или объект, указывающий, по каким условиям удалять.

//TODO: Reviewing Data's Long Journey (Обзор долгого пути данных)
// NestJS — это тип сервера веб-приложений. Этот модуль расскажет вам, что такое NestJS и как он работает. Когда вы закончите, вы поймете, как работают серверы веб-приложений и как вы можете создать их, не выходя из собственного дома! В Модуле 2 мы говорили о долгом пути, который данные проходят от back-end (серверной части) к front-end. В реальной жизни эти данные часто перемещаются из серверной части в течение секунд или даже миллисекунд. Однако в нашем исследовании данных мы медленно движемся к back-end (серверной части), которая будет в центре внимания этого модуля. К тому времени, когда вы закончите с этим модулем, вы поймете, как данные передаются из базы данных через сервер NestJS, а затем передаются в наш front-end Angular.
// На приведенной ниже диаграмме back-end (серверная часть) состоит из сервер веб-приложений и базы данных.
// Нашей базой данных в этом курсе будет база данных PostgreSQL, а нашим сервером веб-приложений будет NestJS. Мы объясним, как работает NestJS, по мере развития уроков в этом модуле.
// См. Рис: Reviewing Data's Long Journey.png
// NestJS — это сервер веб-приложений. Его работа заключается в обработке запросов от front-end и доставке ответов на основе доступных инструментов.

//TODO: Handling Requests (Обработка запросов)
// В первом модуле мы использовали аналогию с кухней, чтобы показать, как работают полностековые приложения. Давайте расширим эту аналогию и визуализируем, что происходит внутри контроллера веб-приложения. В нашей аналогии с кухней от front-end поступает запрос на еду. Сервер веб-приложений получает запрос. Если запрос действителен, сервер отправляет ответ обратно во front-end. Предположим, что внутри сервера есть повара быстрого приготовления, которые получают запросы на еду. Эти повара быстрого приготовления в контексте сервера называются контроллерами.
// задача Контроллера состоит в том, чтобы получить request (запрос) и response (отправить) ответ. Контроллеры могут обращаться к холодильнику для получения данных (базы данных), но на фундаментальном уровне простейшие контроллеры могут отправлять базовый ответ прямо из контроллера, не касаясь базы данных. Сначала мы изучим простой контроллер, а затем постепенно создадим контроллеры, которые будут делать больше, чем просто выдавать текст. На данный момент мы хотим попасть по веб-адресу, полученному нашим сервером, и вывести HELLO WORLD! Как только мы это сделаем, мы создадим наш первый ответ сервера. Это захватывающе, так что пристегнитесь. Мы погружаемся в back-end сейчас.
// Контроллер внутри сервера веб-приложений подобен повару на кухне. Когда он получает запрос, его задача состоит в том, чтобы доставить ответ на этот запрос, подобно повару, отвечающему «спагетти», когда его просят приготовить макароны.

//TODO: Routes (Маршруты)
// Чтобы лучше понять, как наши контроллеры выполняют свою работу, мы рассмотрим routes (маршруты), requests (запросы) и ответы (responses). Когда вы посещаете https://www.sololearn.com, вы делаете запрос к ROOT route (корневому маршруту) этого веб-сайта. Что такое root (корень)? Root (Корень) — это, по сути, домашняя страница. Он представлен простой косой чертой в URL-адресе.
// См. Рис: Routes.png
// Destination (Целевые) URL-адреса на веб-сайтах называются ROUTES (МАРШРУТЫ). Route (Маршрут) — это просто URL-адрес, который вы посещаете в определенном домене. Здесь sololearn — это домен, а маршрут, который мы посещаем, — это корневой маршрут. Думайте о домене как о всей кухне, и каждый маршрут ведет вас к другому повару. Вы ходите к разным поварам за разными вещами. В этом случае корень маршрут будет служить домашней страницей. Но такой маршрут, как https://www.sololearn.com/fries, доставит нам картофель фри. Это другой маршрут. https://www.sololearn.com/soup доставил бы нам суп. Мы идем разными путями с разными целями. Однако, пожалуйста, не пытайтесь заказать картофель фри или суп по любому из этих адресов. Эта информация просто для демонстрационных целей.
// Корневой маршрут веб-сайта обычно является домашней страницей.

//TODO: Routes Continued (Маршруты Продолжение)
// Веб-сайты обычно имеют несколько маршрутов, предназначенных для разных страниц и действий пользователя. На некоторых сайтах десятки и даже сотни маршрутов. Маршрутизация может быть сложной, но в этих примерах мы будем использовать один маршрут для обработки каждого типа запроса. Когда мы говорим о маршрутах на каком-либо веб-сайте, мы обычно имеем в виду ту часть, которая следует за доменом.
// Примеры:
// https://www.sololearn.com/cats …..будет называться маршрутом «/ cats».
// https://www.sololearn.com/dogs …..будет называться маршрутом «/ dogs».
// https://www.sololearn.com/stores/manage ….. будет называться маршрутом « /stores/manage».
// Маршрут — это набор слов, часто разделенных косой чертой, который указывает на определенный контроллер на сервере веб-приложений. Этот контроллер обработает этот запрос соответствующим образом.

//TODO: GET vs POST (ПОЛУЧИТЬ против ОТПРАВИТЬ)
// В этом модуле мы узнаем о двух разных типах веб-маршрутов:
// маршрутах GET и маршрутах POST.
// - Маршруты GET обычно предназначены для получения данных с сервера.
// - Маршруты POST обычно предназначены для ОТПРАВКИ данных на сервер.
// В нашей аналогии с кухней ПОЛУЧЕНИЕ рамена (японское блюдо с пшеничной лапшой) отличается от ОТПРАВКИ партии рамена на кухню, чтобы они могли расширить свое меню. Проще говоря, маршрут GET получает данные для вас, а маршрут POST отправляет данные для вас.
// Эта диаграмма иллюстрирует концепцию.
// См. Рис: GET vs POST.png
// Подумайте о GET как о fetching (получении) чего-либо, а о POST как о sending (отправке) чего-либо.

//TODO: Get vs Post Requests (Получить и отправить запросы)
// front-end может отправить запрос GET на сервер, который подключается к GET route (маршруту).
// front-end также может отправить запрос POST на сервер, который подключается к POST route (маршруту).
// На сервере мы собираемся настроить различные routes (маршруты). Некоторые routes (маршруты) будут GET routes (маршрутами), а другие routes (маршруты) будут POST routes (маршрутами). GET и POST — это разные типы маршрутов, поэтому они могут иметь одно и то же имя, но сервер будет распознавать их как разные, потому что это разные типы.
// См. Рис: Get vs Post Requests.png
// HTTP-глаголы «GET» и «POST» являются производными от соответствующих английских глаголов, от которых они были получены. «Получить» связано с извлечением чего-либо из ресурса, а «Отправить» — с размещением чего-либо на месте. Когда вы «отправляете» посылку, вы отправляете ее получателю, где «получение» посылки означает, что вы получаете посылку.

//TODO: What is NestJS (Что такое NestJS)
//TODO: https://www.youtube.com/watch?v=abdgy72csaA
// Теперь, когда мы понимаем основы GET, POST и маршрутов, мы можем поговорить о приложении, которое позволит нам применить все эти знания. Дамы и господа, представляем NestJS. NestJS — это тип сервера веб-приложений, созданный с помощью Node.js, который использует TypeScript в качестве основного языка.
// Node.js — это технология, позволяющая запускать JavaScript вне браузера, что дает ему возможность создавать серверы и интерфейсы командной строки. Node.js можно установить, посетив этот веб-сайт: https://nodejs.org/en/.
// Запустите установщики, чтобы установить Node.js на свой компьютер. Теперь нам нужно установить NestJS. Посетите https://docs.nestjs.com/
// и следуйте инструкциям на странице. Теперь, когда Node.js и NestJS установлены, вы можете запустить в своем терминале команду создания шаблонов, подобную следующей.
// nest new cars
// Скаффолдинг в разработке программного обеспечения — это процесс запуска команды, которая очень быстро создает для вас целую кучу вещей, которые сразу же готовы к использованию. Приведенная выше команда создает совершенно новый сервер веб-приложений с именем «cars», а затем, набрав в терминале yarn start или npm run start , вы получите сервер, работающий на порту localhost:3000 на вашем компьютере. Мы рассмотрим localhost в следующей части этого урока. Мы выполнили всю эту подготовительную работу, создав для вас сервер и зафиксировав код на GitHub. Если вы просмотрите этот код, вы увидите базовую настройку проекта простейшего из возможных серверов NestJS, и он работает. Посмотреть проект на GitHub
// Скаффолдинг — это термин, используемый для описания процесса, в котором вы можете ввести одну строку кода, а интерфейс командной строки создаст для вас целый шаблонный проект или функцию. Это как блины "просто добавь воды". Вам не нужно знать, как это работает, и команда поможет вам быстро начать работу. Angular также использует строительные леса.

//TODO: Running a Server Locally (Локальный запуск сервера)
// Когда вы устанавливаете сервер веб-приложений локально, например NestJS, он будет работать на порту 3000 на вашем компьютере. Это означает, что на вашем компьютере есть место, называемое портом, которое вы можете посетить, чтобы увидеть, как работает сервер. Когда вы заходите на такой веб-сайт, как       www.sololearn.com, вы посещаете сервер SoloLearn. Вы можете запустить «сервер» прямо на своем ноутбуке, который в чем-то похож. Сервер, который вы запускаете на своем ноутбуке, предназначен только для тестирования ваших приложений. Для просмотра внешним миром на ваш компьютер необходимо установить специальное программное обеспечение, чтобы сделать его общедоступным сервером. Это не относится к вам; как новичок, сервер, который вы создадите на своем компьютере, будет именно для вас.
// Когда вы посещаете локальный сервер NestJS на своем компьютере, вы посещаете адрес, который выглядит следующим образом: http://localhost:3000/ Не пытайтесь попасть по этому адресу со своего телефона; это применимо только тогда, когда вы находитесь на своем компьютере и у вас работает локальный сервер. Разработчики используют подобные локальные серверы для проверки своей работы перед ее загрузкой или развертыванием в Интернете. Таким образом, вы можете тестировать вещи и вносить изменения во время строительства, не выполняя все эти строительные работы в общественном месте.
// Когда вы запускаете сервер локально, большую часть времени вы запускаете этот сервер в пространстве под названием «localhost», которое просто относится к адресу вашего персонального компьютера.

//TODO: Anatomy of a NestJS Server (Анатомия сервера NestJS)
// Прежде чем мы углубимся в наше приложение NestJS и начнем что-то делать, давайте посмотрим на нашу файловую структуру NestJS. Когда мы построили наш сервер, мы получили базовый сервер веб-приложений, готовый к использованию. Он имеет контроллер, модуль и службу. Подождите... это выглядит почти так же, как файловая структура Angular. Что ж, это не случайно. NestJS использует TypeScript, и команда NestJS приняла решение сделать файловую структуру похожей на Angular, чтобы разработчики Angular могли ее легко понять.
// Так рождаются «стеки»: набор инструментов, которые легко взаимодействуют друг с другом, неизбежно будет называться «стеком» сообществом разработчиков. Следовательно, стек TypeScript с Angular и NestJS теперь кажется вещью, даже если только косвенно.
// См. Рис: Anatomy of a NestJS Server.jpg
// Глядя на эту файловую структуру, мы видим контроллер, который обрабатывает веб-трафик, службу для предоставления данных этому контроллеру и модуль, который работает за кулисами, чтобы убедиться, что служба и контроллер имеют необходимые вспомогательные элементы, чтобы работать.
// Давайте быстро посмотрим, что делает контроллер. Мы видим некоторый код, который выглядит так:
// TypeScript (TS):
// @Get()

// getHello(): string {

//     return this.appService.getHello();
// }
// По сути, это дает запрос «GET» по умолчанию (когда кто-то посещает домашнюю страницу веб-сайта) и возвращает результат функции getHello appService, которая просто возвращает строку «Hello». Итак, у нас есть контроллер, вызывающий службу для получения данных, как в Angular. Не стесняйтесь просматривать файлы в репозитории GitHub, чтобы увидеть, как работает пример NestJS «Hello World»: Посмотреть проект на GitHub:
// https://github.com/SoloLearn-Courses/nest_init
// NestJS и Angular используют сервисы практически одинаково, и файловая структура в целом очень похожа. Основное отличие состоит в том, что в Angular компоненты вызывают сервисы, а в NestJS контроллеры вызывают сервисы.

//TODO: How NestJS Responds to Requests (Как NestJS отвечает на запросы)
// Мы собираемся увидеть, как NestJS обрабатывает простой запрос GET к корневому маршруту. Если вы понимаете это последнее предложение, вы должны гордиться собой… это означает, что вы учитесь. Давайте рассмотрим наш код init «инициализации» NestJS отсюда:
// См. Рис: How NestJS Responds to Requests.png
// AppContoller в NestJS похож на файл app.component.ts в Angular. Это код по умолчанию, который запускается в приложении, когда мы запускаем приложение после его формирования. Это наша отправная точка. Где-то в этом коде скрывается маршрут GET. Вы видите это? Быстро, не читайте следующую строку, вернитесь назад и посмотрите на код и посмотрите, сможете ли вы найти маршрут GET и его ответ. ОСТОРОЖНО, СПОЙЛЕРЫ! Итак, вот ответ: маршрут GET начинается в строке 8.
// это то, что мы называем декоратором, что просто означает, что это наш способ сообщить NestJS, что следующая функция должна вернуть ответ на запрос GET. В строке 10 мы выдаем этот ответ. Обратите внимание, что шаблонный код по умолчанию использует службу. Это немного причудливо, для этого нам не нужен сервис, в этом случае для простого ответа мы могли бы просто использовать это как наш код для строки 10:
// TypeScript (TS):
// return "Hello World";
// Суть в том, что этот код запускается, когда мы попадаем на наш сервер. Когда мы нажимаем http://localhost:3000, мы видим ответ «Hello World!».
// См. Рис: How NestJS Responds to Requests_2.png
// Ответы сервера могут быть строками, целыми числами, JSON и всеми основными типами данных TypeScript.

//TODO: Return Types on Routes (Типы возврата на маршрутах)
// Давайте снова посмотрим на наш код из нашего кода инициализации NestJS отсюда:
// https://github.com/SoloLearn-Courses/nest_init/blob/master/src/app.controller.ts
// обратите внимание на строку 9:
// TypeScript (TS):
// getHello( ): string {
// См. Рис: Return Types on Routes.png
// getHello() — это функция. Он имеет возвращаемое значение. Все в этом выглядит как обычная функция JavaScript, за исключением двоеточия после имени метода и строки слова. Вот еще одна особенность TypeScript, которую мы сейчас изучим в процессе изучения NestJS: типы возвращаемых функций. Да, мои дорогие друзья, в Typescript есть возможность статического ввода ТИПА ВОЗВРАТА функции. getHello(): string означает, что функция getHello ДОЛЖНА возвращать строковое значение. Если это не так, код не будет компилироваться. getHello(): number  означает, что метод getHello должен вернуть число. getHello(): boolean  означало бы, что должно быть возвращено логическое значение. Вы получаете картину.
// Добавление возвращаемых типов к маршрутам обеспечивает структуру и согласованность наших маршрутов, чтобы вы, как программист, и другие разработчики, работающие с этой кодовой базой, могли следовать единым шаблонам в отношении обработки данных в приложении.

//TODO: Scaffold Cars Route (Путь строительных лесов)
// Ранее мы рассмотрели этот внутренний код:
// https://github.com/SoloLearn-Courses/nest_init/
// и мы рассмотрели контроллер, который возвращал ответ, когда пользователи посещали root route (корневой маршрут) веб-сайта. Это здорово, но что, если мы захотим создать еще один route (маршрут)? В идеале мы хотели бы создать route (маршрут), по которому вы могли бы GET (ПОЛУЧИТЬ) автомобили, который возвращал бы массив автомобилей в формате JSON, который наш front-end использовал бы для отображения всех автомобилей, поступающих из back-end. У нас есть новый репозиторий кода, который иллюстрирует это:
// https://github.com/SoloLearn-Courses/nest_controller
// В NestJS мы можем построить новый маршрут, просто выполнив это в терминале:
// nest generate route cars
// Это добавляет новую папку:
// См. Рис: Scaffold Cars Route.png
// И вставляет другую поддержку в базу кода, которая позволяет нам теперь иметь доступ к новому маршруту GET с именем /cars.
// Когда вы начинаете работать с NestJS, вы можете использовать скаффолдер для создания своего приложения и создания новых маршрутов, не полностью понимая все детали того, как эти вещи работают под капотом. По мере того, как вы растете как разработчик, любопытство, скорее всего, заставит вас копаться под капотом, чтобы раскрыть множество поддерживающих структур кода, благодаря которым все работает. На данный момент «это просто работает!», и это отличное место для начала. Теперь у нас новый маршрут.

//TODO: View a Scaffolded Route (Просмотр построенного маршрута)
// В предыдущем уроке мы создали новый route cars, выполнив команду Nest generate Route cars, которая создала папку с файлами для поддержки GET - route /cars. Глядя на созданный route GET для cars, он выглядит так:
// См. Рис: View a Scaffolded Route.jpg
// Этот route с именем findAll() является одним из многих routes, созданных генератором Nest. Очень важно понимать контекст работы routes в любой папке веб-приложения на основе Node.js. Внутри ресурса "cars" route @Get() или @Get('/') представляет собой функцию, которая принимает аргумент. Аргумент, который он принимает, становится sub-route (подмаршрутом) того route (маршрута), в котором вы находитесь. Если sub-route (подмаршрут) не указан, по умолчанию используется root route (корневой маршрут) папки, в которой вы находитесь.
// Примеры: простой маршрут @Get() в /students по умолчанию будет иметь адрес http://www.yourserver.com/students простой маршрут @Get() в /buildings по умолчанию будет иметь адрес http://www.yourserver.com/buildings простой маршрут @Get() в /recipes по умолчанию будет http://www.yourserver.com/recipes … и так далее. Имя папки, в которой вы находитесь, является префиксом. Часть внутри круглых скобок @Get() — это то, что нужно добавить в конец этого префикса. Итак: @Get("models") в выделенном контроллере автомобилей приведет вас к http://www.yourserver.com/cars/models.
// То, что возвращается в любом из этих маршрутов, — это то, что будет отображаться в браузере, когда пользователь нажимает на этот маршрут в браузере. Здесь маршрут просто возвращает строку, в которой говорится, что «это в конечном итоге вернет коллекцию автомобилей». Просмотрите маршрут GET для автомобилей по умолчанию на GitHub.
// https://github.com/SoloLearn-Courses/nest_controller/blob/master/src/cars/cars.controller.ts
// Маршрут GET принимает один аргумент: строку, представляющую остальную часть маршрута GET после префикса. Префикс — это имя того контроллера, в котором вы находитесь.

// TODO: Get All Cars (Получить все автомобили)
// /cars route, который просто возвращает простую строку, скучен и совершенно бесполезен. Вернем реальный массив автомобилей в формате JSON! В нашем предыдущем примере кода в предыдущей части урока у нас был маршрут GET cars, который выглядел следующим образом:
// См. Рис: Get All Cars.png
// декоратор @Req сообщает NestJS, что мы ожидаем объект запроса, который мы называем request (запросом), который имеет тип Request. Давайте изменим тип возвращаемого значения на это:
//TypeScript (TS):
// findAll(@Req() request: Request): object {...
// Обратите внимание, что вместо возвращаемого типа строки у нас есть объект в качестве возвращаемого типа. Это позволит разместить объект или даже массив объектов. Теперь мы можем сделать что-то вроде этого:
//TypeScript (TS):
// @Get()
// findAll(@Req() request: Request): object {
//   return [{make: 'honda', model: 'accord'},
//            {make: 'subaru', model: 'outback'},
//            {make: 'fiat', model: '123 spider'}];
// }
// Если мы выберем наш маршрут /cars сейчас, мы получим это в окне браузера:
// См. Рис: Get All Cars_2.png
// ТИП ОТВЕТА маршрута очень типично JSON в современной архитектуре сервера веб-приложений. Здесь мы просто сделали тип ответа object, но он также может быть object [ ], что буквально обозначает «массив объектов». Помните, мы создавали массивы с помощью TypeScript? Поскольку массив строк имеет такой тип: string[], отсюда следует, что массив объектов может быть типизирован следующим образом: [] object

//TODO: Nested Routes (Вложенные маршруты)
// В Интернете не все маршруты имеют одно слово после домена. В Интернете часто можно увидеть URL -адреса с более чем одним разделом после домена. Например, вы можете увидеть маршрут, который выглядит так:
// https://www.sololearn.com/cars/engines В этом случае двигатели вложены в маршрут автомобилей. Мы называем это (shockingly)… nested route. Вот как в NestJS в файле контроллера, таком как контроллер автомобилей, мы создаем nested route под названием «showcase» (витрина) внутри автомобилей: добавьте еще один раздел в файл маршрута и поместите имя вложенного маршрута в объявление функции для этого маршрута:
// См. Рис: Nested Routes.png
// Затем, если мы зайдем на наш локальный сервер по этому адресу, http://localhost:3000/cars/showcase, мы увидим маршрут демонстрации автомобилей:
// См. Рис: Nested Routes_2.png
// Вот код на GitHub для изучения.
// https://github.com/SoloLearn-Courses/cars_sub_route
// Короче говоря, вложенные маршруты создаются путем объединения маршрутов с «/» между каждым словом в маршруте. Такой маршрут: www.sololearn.com/quizzes/english/typescript может выглядеть в контроллере QUIZZES следующим образом: помните, что слово 'quizzes' неявно присутствует в этом маршруте, потому что этот маршрут находится в контроллере тестов:
// TypeScript (TS):
// @Get('/english/typescript')
// Думайте о вложенном маршруте как о «подмаршруте», который находится под родителем. Вложенные маршруты могут идти глубоко. У вас может быть такой маршрут:
// http://www.mydomain.com/countries/usa/states/colorado/cities/denver .
// Вложенные маршруты очень распространены в Интернете.

//TODO: Wildcard Routes (Подстановочные маршруты)
// Иногда определенные маршруты содержат segment (сегменты), которые могут меняться в зависимости от изменяющихся данных. Допустим, у нас есть база данных с несколькими автомобилями:
// См. Рис: Wildcard Routes.png
// Чтобы ПОЛУЧИТЬ автомобиль из базы данных, мы должны вызвать маршрут, который выглядит следующим образом: http://www.sololearn.com/cars/6, который вернет следующие данные:
//TypeScript (TS):
// {id: 6, make: chevy, model: impala, name: Curtis}
// Но если мы позвоним по адресу http://www.sololearn.com/cars/5, мы получим:
//TypeScript (TS):
// {id: 5, make: ford, model: mustang, name: Spirit}
// ПОСЛЕДНИЙ СЕГМЕНТ URL-адреса называется подстановочным знаком. Накорми его 5, и ты получишь ford. Накорми его 6, и ты получишь chevy. Накорми его 12 и получишь toyota. Откуда серверная часть знает, как обращаться с «переменной» в маршруте? Мы используем этот синтаксис в маршруте:
// См. Рис: Wildcard Routes_2.png
// Игнорируйте возвращаемое значение здесь … позже в этом курсе мы не будем hard code (жестко кодировать) возвращаемое значение; мы будем искать его в базе данных на основе переданного идентификатора. Здесь мы жестко кодируем ответ только для того, чтобы показать некоторые возвращенные образцы данных. Здесь важно отметить, что передаваемый «id» является переменной. Позже мы зафиксируем переданный идентификатор и используем это значение для поиска нужного автомобиля в базе данных. Наш маршрут, по сути, представляет собой метод под названием « findOne() ». Имя findOne - это просто имя, которое я выбрал; оно не особенное. NestJS просто нужно имя для функции, поэтому это имя может быть любым, которое надлежащим образом описывает, что делает функция. Маршрут с подстановочными знаками с несколькими уровнями вложенности может выглядеть так:
//TypeScript (TS):
// @Get('gamers/alliances/:country/:region/:city')
// Такой маршрут не очень распространен, но мы предоставляем этот пример, чтобы показать вам, как может выглядеть несколько уровней вложенности.
// Маршруты с подстановочными знаками являются ключом к поиску определенных записей в базе данных.

//TODO: Intro to Web APIs (Введение в веб-API)
// Если вы хотите быть крутым со всеми своими друзьями-разработчиками, отличный способ сделать это — начать обсуждать RESTful API. По крайней мере, они будут знать, что вы что-то понимаете в развитии и, возможно, сможете посидеть за крутым детским столом за обедом. А если серьезно, API RESTful лежат в основе веб-коммуникаций. ОТДЫХ — глубокая и сложная тема, но в этом уроке мы демистифицируем ее, чтобы вы могли знать достаточно, чтобы быть опасным. Начнем с ОТДЫХА. REST — это просто протокол, который определяет, как веб-технологии должны взаимодействовать друг с другом. Помните, когда мы изучали HTTP? Что ж, REST использует HTTP-глаголы и определенные соглашения о том, как записываются URL-адреса, как часть своего процесса. API означает интерфейс прикладного программирования. API — это как меню в нашем ресторане. Если вы хотите чего-то определенного, вы должны попросить об этом определенным образом. Меню дает вам инструкции, как заказать именно то, что вы хотите, и если вы попросите об этом правильно, вы получите это. Таким образом, REST — это соглашение о том, как компьютеры общаются друг с другом в Интернете. API похож на меню конкретных адресов, которые вы используете для получения информации с веб-сайта.
// См. Рис: Intro to Web APIs.png
// API — это способ взаимодействия с серверной частью с использованием URL-адресов, соответствующих определенным шаблонам.

//TODO: RESTful Routes (REST-маршруты)
// REST определяет определенные стандартные способы взаимодействия с серверной частью. Существуют определенные шаблоны URL, которые обычно используются для CRUD серверной части. CRUD означает записи: CREATE, READ, UPDATE и DELETE. В нашем случае это может быть способ создания, чтения, обновления и удаления автомобилей в нашей базе данных. Здесь мы покажем упрощенную версию этих правил RESTful API. Мы будем ставить перед каждым вызовом HTTP-глагол (GET или POST) для каждого метода. ВНИМАНИЕ: Не пренебрегайте этими правилами. Когда я впервые узнал о RESTful API и маршрутизации, я прочитал одну главу в книге по программированию около 10 раз, прежде чем понял ее. Я постараюсь облегчить вам задачу, упростив ее.
// ВАМ НЕ НУЖНО ЗАПОМИНАТЬ эти правила. Это здесь, чтобы показать вам тот факт, что эти правила существуют. Мы будем предоставлять «шпаргалку» к этим правилам на протяжении оставшейся части курса, чтобы вы могли использовать ее в качестве руководства при написании маршрутов.
// GET /cars => получает список автомобилей
// POST /cars => создает новый автомобиль на основе пакета данных, который вы ему отправили
// GET /cars/:id => получает один автомобиль на основе идентификатора, который вы отправили как подстановочный знак
// POST /cars/:id => обновляет автомобиль на основе набора данных для обновления автомобиля
// POST /cars/:id/delete => удаляет автомобиль
// Существуют и другие глаголы HTTP, такие как PUT и DELETE, но поскольку веб-страницы понимают только GET и POST мы используем эти глаголы для простоты.

//TODO: Intro to Building NEST Routes (Введение в построение маршрутов NEST)
// Наконец-то мы готовы начать сборку нашего сервера. В этом уроке мы собираемся собрать весь наш сервер. Единственное, что мы пока не будем делать, это подключать его к нашей базе данных. Мы собираемся «жестко закодировать» все ответы на ресурс CRUD о наших автомобилях. Помните, что CRUD означает «создавать», «читать», «обновлять» и «удалять» ресурсы на серверной части. Когда мы закончим, у нас будут маршруты, которые:
// 1. Create a new car (Create) (Создать новый автомобиль (Создать))
// 2. Retrieve all cars (Read) (Получить все автомобили (Чтение))
// 3. Retrieve one car (also Read) (Получить один автомобиль (также прочитать))
// 4. Update one car (Update) (Обновить один автомобиль (Обновить))
// 5. Delete a car (Destroy) (Удалить автомобиль (Уничтожить))
// Давайте сделаем это!
// Способность CRUD ресурса является основополагающим навыком в любом приложении с полным стеком.

//TODO: Making a GET ALL Resource (Создание ресурса GET ALL)
// Мы уже сделали и жестко закодировали наш маршрут «GET /cars» ранее, поэтому мы рассмотрим его здесь. Код для этого находится здесь, на GitHub
// https://github.com/SoloLearn-Courses/nest_cars_json/blob/master/src/cars/cars.controller.ts
// И вот код для обзора:
// См. Рис: Making a GET ALL Resource.png
// Помните, что это корневой маршрут для автомобилей, и вот наша шпаргалка: GET /cars => получает список автомобилей
// POST /cars => создает новый автомобиль на основе пакета данных, который вы отправили,
// GET /cars/:id => получает один автомобиль на основе идентификатора, который вы отправили в качестве подстановочного знака.
// POST /cars/:id => обновляет автомобиль на основе пакета данных для обновления car
// POST /cars/:id/delete => удаляет автомобиль
// GET /cars — это корневой путь к папке cars. Он возвращает коллекцию автомобилей.

//TODO: Making a POST Resource (Создание POST-ресурса)
// Давайте создадим маршрут, который принимает пакет данных, который в конечном итоге будет вставлен в базу данных. Это будет другой маршрут. Он должен принять то, что мы называем телом данных. Подумайте об этом… если вы хотите добавить новый автомобиль в список автомобилей, вам нужно больше, чем просто марка автомобиля, верно? Нужна как минимум марка, модель, а в нашем случае пробег. У автомобилей есть идентификатор, но база данных в конечном итоге автоматически присвоит идентификатор автомобилю. Так что нам просто нужно принять марку, модель и пробег. Это тело всегда будет иметь форму объекта JavaScript, отправленного из front-end. Создадим маршрут для получения данных:
// См. Рис: Making a POST Resource.png
// В методе create у нас есть @Body декоратор, который позволяет нам объявить переменную с любым именем, которое мы хотим, чтобы она служила контейнером для данных. Мы выбрали carParams в качестве этого контейнера. При создании сервера веб-приложений ТЕЛО POST-запроса представляет собой набор данных, поступающих от пользователя. Эти данные фиксируются декоратором @Body. Метод create является асинхронным, что означает, что метод является асинхронным . Асинхронный / ожидающий — это конструкция JavaScript, позволяющая создавать «асинхронные» методы (методы, ожидающие завершения процесса перед возвратом результата). В этом случае нам не нужно ничего ждать, потому что мы возвращаем строку, но когда мы полностью доработаем этот метод, ему нужно будет дождаться завершения запроса к базе данных, прежде чем он вернет значение. Вот почему мы используем асинхронность в методе пост - create.
// Маршрут примет параметры автомобиля, а затем вернет строку, которая говорит: «Я получил ваш post запрос! Вы хотите создать ________». (Затем он вставляет марку из параметров Body). Это подтверждает, что наш маршрут ПОЛУЧИЛ данные, а также подтверждает, что в данных есть то, что мы ожидаем, с точки зрения производителя. Если make присутствует, то мы можем пока предположить, что объект является допустимым объектом. В этом репозитории GitHub есть код, в котором вы можете проверить наш маршрут POST.
// https://github.com/SoloLearn-Courses/nest_cars_post_route
// Запрос POST к такому ресурсу, как /cars, создаст новый автомобиль. Помните, что он должен иметь пакет данных, прикрепленный к POST от front-end, который становится частью тела при получении NestJS.

//TODO: Making an EDIT Resource (Создание ресурса EDIT)
// Ресурс редактирования (или update) также включает запрос POST, потому что вам нужно отправить пакет данных, чтобы сообщить нам, какой автомобиль нужно обновить и что должно повлечь за собой обновление. Давайте посмотрим на нашу шпаргалку, чтобы увидеть, как написать этот маршрут:
// GET /cars => получает список автомобилей
// POST /cars => создает новый автомобиль на основе пакета данных, который вы ему отправили
// GET /cars/:id => получает один автомобиль на основе идентификатора, который вы отправили в виде подстановочного знака
// POST /cars/:id => обновляет автомобиль на основе пакета данных для обновления автомобиля
// POST /cars/:id/delete => удаляет автомобиль
// Нам нужен Маршрут POST, который выглядит следующим образом:
// POST /cars/:id
// Итак, вот оно:
// См. Рис: Making an EDIT Resource.png
// это почти идентично нашему маршруту создания, за исключением того, что мы добавили новый аргумент в функцию маршрута. Мы используем декоратор @Param(), который мы импортировали, и мы назвали его «params», но на самом деле это может быть что угодно. Изучите красные метки на диаграмме выше, начиная с :id, чтобы проследить поток параметра, который мы передаем через URL-адрес. Мы делаем запрос POST к маршруту, который выглядит так:
// 5 — это наш :id при передаче в эту функцию. Любые подстановочные знаки, переданные через URL-адрес, сохраняются в параметрах (первое подчеркнутое значение красного цвета). Затем в любом месте метода мы можем вызвать params, точку, а затем значение, которое мы хотим вызвать, в данном случае это идентификатор. Откуда он знает, что он называется id? Потому что именно так мы назвали его в @Post(':id'). Наконец, мы возвращаем строку, которая показывает название марки автомобиля И идентификатор автомобиля, который мы будем обновлять. Вот полный код GitHub.
// https://github.com/SoloLearn-Courses/nest_cars_update
// Маршруты обновления и создания должны быть POST-запросами, потому что у них есть Body, пакет данных, содержащий информацию, необходимую для создания и обновления записей соответственно.

//TODO: Finishing All of Our Routes (Завершение всех наших маршрутов)
// Теперь мы увидели достаточно маршрутов, чтобы завершить остальные маршруты. Мы выполнили все маршруты из нашей шпаргалки и поместили маршруты в наш контроллер NestJS. Единственный оставшийся маршрут — это наш маршрут DELETE. Нам нужно только принять идентификатор, чтобы удалить что-то из базы данных (пакет данных не требуется). Вам не нужна никакая информация, чтобы удалить автомобиль. Марка, модель и пробег не имеют значения. Все, что нужно базе данных, — это идентификатор для идентификации записи, которую необходимо удалить.
// См. Рис: Finishing All of Our Routes.png
// Мы добавили репозиторий GitHub со всеми необходимыми маршрутами, поэтому инфраструктура для всех наших маршрутов к автомобилям CRUD теперь завершена. https://github.com/SoloLearn-Courses/nest_cars_all_routes
// В частности, ссылка ниже является прямой ссылкой на контроллер. Мы поместили нашу шпаргалку в контроллер для вашего удобства. https://github.com/SoloLearn-Courses/nest_cars_all_routes/blob/master/src/cars/cars.controller.ts
// Вероятно, вы не запомните всю маршрутизацию, даже прочитав ее несколько раз. Это нормально. Наиболее важным является понимание концепции маршрутов получения и отправки и концепции запросов получения и отправки. Остальное постепенно впитается со временем и использованием.

//TODO: Creating and Populating a Database (Создание и заполнение базы данных)
// В «data's long journey» (долгом путешествии данных) мы, наконец, достигли самого глубокого уровня данных в нашем стеке: database (базы данных). В нашем терминале мы просто создадим базу данных PostgreSQL под названием «transportation» (транспорт). Затем внутри PostgreSQL мы создаем таблицу cars и заполняем ее тремя автомобилями. Создание таблиц и их заполнение было рассмотрено в предыдущем разделе, поэтому мы просто размещаем здесь все команды для вашего удобства. Вот команды, написанные по порядку:
// createdb transportation
// psql // gets you into the psql command line
// \c transportation

// CREATE TABLE cars
// (id SERIAL, make TEXT, model TEXT, miles INT);

// INSERT into cars values
// (DEFAULT, 'subaru', 'outback', 3420);
// INSERT into cars values
// (DEFAULT, 'honda', 'passport', 27);
// INSERT into cars values
// (DEFAULT, 'volvo', 'XC40', 33000);

// select * from cars;
// И вот как это выглядит, когда мы делаем это в терминале:
// См. Рис: Creating and Populating a Database.png
// Теперь у нас есть база данных автомобилей с 3 автомобилями.
// Наша база данных — это наш самый глубокий уровень хранения данных.

//TODO: TypeORM Intro.jpg (TypeORM Введение)
// Наконец-то мы подошли к тому моменту в нашем курсе, когда мы можем начать взаимодействовать с нашей базой данных из нашей серверной части NestJS. Чтобы взаимодействовать с нашей базой данных из NestJS, мы будем использовать ORM с именем TypeORM. Как мы узнали из предыдущего модуля, ORM (Object Relational Mapping) означает «реляционное сопоставление объектов». Это клей между сервером и базой данных. Зачем нам ОРМ? Разве сервер веб-приложений не может напрямую общаться с базой данных? Что ж, может, но цель ORM — сделать серверные части более гибкими, выступая в качестве «универсального переводчика» между сервером и базой данных.
// ORM говорят с сервером на одном языке: на языке ORM. Но они говорят на МНОГИХ языках с разными базами данных. Это означает, что вы пишете один язык в своей серверной части, язык ORM, а затем ORM с его многоязычными возможностями ПЕРЕВОДИТ язык ORM во все типы баз данных, которые он поддерживает.
// TypeORM Intro.jpg
// Это означает, что вы можете переключить базу данных с базы данных PostgreSQL на базу данных MySQL на бэкэнде, и вам не нужно будет трогать запросы к базе данных на вашем сервере NestJS, потому что ваш ORM сделает перевод за вас.
// ORM - это, по сути, многоязычный коммуникатор базы данных.

//TODO: Get All Route (Получить весь маршрут)
// Команда NestJS проделала большую работу, предоставив примеры TypeORM, готовые для использования в вашем проекте. У них есть хороший пример кода SQL в Github здесь:
// https://github.com/nestjs/nest/tree/master/sample/05-sql-typeorm
// Мы взяли этот пример и адаптировали его к нашей транспортной базе данных PostgreSQL. Наш репозиторий начальных файлов находится здесь:
// https://github.com/SoloLearn-Courses/nest_typeorm-postgres
// Клонирование вышеуказанного репозитория (nest_typeorm-postgres) и выполнение указаний в ReadMe приведет вас к запуску сервера, который появиться в
// http://localhost:3000
// У нас нет «root» (корневого) route (маршрута), так как этот сервер является только API. Помните, что API (application programming interface) означает «интерфейс прикладного программирования», и это похоже на меню в ресторане. Что мы хотим? Нам нужен список автомобилей. Что ж, запустим route (маршрут). Если мы выберем route (маршрут) /cars, то получим следующее:
// См. Рис: Get All Route.jpg
// Это работает! Но почему это работает? Ну, во-первых, в нашей настройке TypeORM мы сказали:
// 1. Мы ищем базу данных PostgreSQL
// 2. Наша база данных PostgreSQL называется transportation
// 3. В нашей transportation базе данных есть таблица с именем «cars» столбцы с id, make, model и miles В следующей части этого урока мы проанализируем, КАК мы сообщаем TypeORM об этих трех вещах.
// ORM обычно требуют всего несколько ключевых фрагментов данных, таких как те три пункта выше, чтобы закрепиться в вашей базе данных и начать ее использовать. Это как смесь для блинов "просто добавь воды".

//TODO: TypeORM : Connecting with PostgreSQL (TypeORM: подключение к PostgreSQL)
//TODO: https://www.youtube.com/watch?v=msVhfCzFWvY
//TODO: https://www.youtube.com/watch?v=gfTFSeAKzEk
// Мы определили эти три вещи как ключ к помощи TypeORM в подключении к нашей существующей базе данных PostgreSQL. Первым шагом было «сообщить TypeORM, что мы ищем базу данных PostgreSQL». В нашем файле app.module.ts мы видим следующие настройки:
// https://github.com/SoloLearn-Courses/nest_typeorm-postgres/blob/master/src/app.module.ts
// Сверху вниз мы должны:
// 1. Сообщить ему, что «тип» — «postgres» в строке 9.
// 2. Сообщить ему, что порт — 5432 в строке 11. , Порт по умолчанию для postgres на вашем компьютере должен быть 5432. Если нет, вы можете войти в командную строку postgres, набрав psql и введите следующую команду:
// см. Рис: TypeORM Connecting with PostgreSQL.png
// \conninfo
// Что даст ответ примерно так:
// You are connected to database "transportation" as user "p2873541" via socket in "/tmp" at port "5432".
// 3. Сообщите ему, что имя пользователя такое же, как ваше имя пользователя postgres.
// 4. Сообщите ему, что база данных называется «transportation».
// Файл app.module в NestJS, как и в Angular, имеет некоторые свойства конфигурации, влияющие на все приложение.

//TODO: TypeORM : Connect with the Cars Table (TypeORM: связь с таблицей автомобилей)
// Далее нам нужно сообщить TypeORM, что мы подключаемся к таблице cars в транспортной базе данных. Если вы посмотрите на верхнюю часть файла app.module.ts, вы увидите, что мы импортируем нечто, называемое Cars entity:
// https://github.com/SoloLearn-Courses/nest_typeorm-postgres/blob/master/src/app.module.ts
// TypeScript (TS):
// import { Cars } from './car/cars.entity';
// Этот файл отображает все поля базы данных, которые находятся в нашей таблице cars в нашей базе данных:
// См. Рис: TypeORM Connect with the Cars Table.png
// «entity» в TypeORM похожа на схему базы данных. Он отображает все поля, которые нам нужны для связи с нашими базовыми таблицами.

//TODO: The Car Service (Автосервис)
// Наконец, с точки зрения нашей настройки TypeORM, мы должны взглянуть на наш Car Service.
// https://github.com/SoloLearn-Courses/nest_typeorm-postgres/blob/master/src/car/car.service.ts
// См. Рис: The Car Service.png
// Car Service, как и любой сервис в Angular, является мостом между контроллером и источниками данных. Не пугайтесь, если вы не понимаете всего, что находится в этом файле. Мы направим вас к частям, которые вам нужно знать, чтобы перемещаться по файлам, и познакомим вас только с тем, что вам нужно знать в любой момент времени, чтобы быть продуктивным. В этом случае служба импортирует нечто, называемое репозиторием, из исходного кода TypeORM. Репозиторий - является основным мозгом машины запросов к базе данных в NestJS. У него есть все «волшебные» методы для запросов к базе данных. Наш репозиторий здесь относится к типу репозитория, что означает, что он наследует все классные методы репозитория, и мы можем использовать их для запросов к базе данных. В репозитории есть такие методы, как find(), findOne(), create(), insert(),  update() и т.д. В нашем /cars route, мы просто вызываем find() и получаем всю нашу коллекцию автомобилей. Под капотом, поскольку мы сказали ему, что подключены к PostgreSQL, он строит запрос примерно так: «SELECT * from cars;» и отправив этот запрос в PostgreSQL. Давайте сосредоточимся на том, что возвращают наши асинхронные методы. Эти методы возвращают стандартное Promise (обещание) Javascript. Возвращаемый тип Promise (обещания) — это тип Cars[] для метода findAll в строке 13, но тип Cars в строке 17. Здесь Cars представляет ответ базы данных для одного автомобиля (во множественном числе, но на самом деле это «model»). для одного ответа автомобиля из базы данных, поэтому мы используем Cars[] для коллекции и Cars для одного ответа автомобиля.
// Сервисы в NestJS при работе с TypeORM имеют методы, которые могут возвращать promises типа, связанного с конкретной сущностью TypeORM.

//TODO: Controller FindOne Method (Метод FindOne контроллера)
// В нашем текущем контроллере уже есть метод findOne. Давайте рассмотрим код контроллера. car.controller.ts
// https://github.com/SoloLearn-Courses/nest_typeorm-postgres/blob/master/src/car/car.controller.ts
// TypeScript (TS):
// @Get("/:id")
// findOne(@Param() param): Promise<Cars[]> {
//   return this.CarService.findOne(param.id);
// }
// Метод GET /cars/:id принимает идентификатор. Двоеточие говорит нам, что это значение переменной. Помните, что префикс «/cars/» к этому методу уже включен, так как мы находимся в контроллере cars. Метод findOne (это метод, связанный с маршрутом GET cars/:id ) вызывает декоратор @Param() со связанной с ним локальной переменной param. ВАЖНО: «param» — это просто то, что мы решили назвать объектом параметра. Эта переменная является локальной переменной метода и может называться как угодно. Если бы он назывался « scooby », то в строке 16 мы бы написали findOne( scooby .id). @Param(), однако, является декоратором и ключевым словом и всегда будет одним и тем же.
// Затем мы вызываем метод findOne CarService с параметром param.id (переменная :id из маршрута). Затем CarService выполняет остальную работу. Это будет рассмотрено в следующей части.
// Помните, что контроллер — это первая точка ответа, когда от внешнего интерфейса поступает запрос GET или POST.

// TODO: Service FindOne Method (Сервис FindOne Метод)
// Контроллер передал входящий идентификатор методу findOne() в сервисе: car.service.ts
// https://github.com/SoloLearn-Courses/nest_typeorm-postgres/blob/master/src/car/car.service.ts
// TypeScript (TS):
// async findOne(id: number): Promise<Cars> {
//   return this.carsRepository.findOne(id);
// }
// Принимаем id от контроллера. carsRepository вызывает свой собственный метод findOne, который принимает идентификатор и использует свою многоязычность для связи с базовой базой данных (в данном случае это Postgres), получения автомобиля и отправки его обратно контроллеру. Вы, наверное, заметили, что многие из этих методов возвращают промисы. Хотя промисы являются важной частью JavaScript, понимание того, как они работают в этих экземплярах, не имеет решающего значения для того, чтобы все это приложение работало.
// Однако важно понимать поток данных здесь. Контроллер получает id, передает id сервису, которая вызывает репозиторий, вызывает базу данных, которая получает элемент и возвращает его обратно контроллеру, который возвращает JSON во front-end. Долгая дорога данных завершена, когда все это произошло.
// Помните: в репозитории есть все методы, которые нам нужны для связи с нашей базой данных. Вы можете просмотреть наш пример репозитория здесь: https://github.com/SoloLearn-Courses/nest_typeorm-postgres/blob/master/repository.ts Этот файл содержит все методы, которые нам понадобятся для полного CRUD любого ресурса, например автомобилей. или лапша рамен.

//TODO: Client and Server Together (Клиент и сервер вместе)
// Мы достигли момента истины. Все, что нам нужно установить, это возможность отправить запрос GET из Angular (в правой части диаграммы), NestJS получит запрос, получит данные из базы данных, вернет их в NestJS, а затем отправит эти данные обратно в наш Angular front-end.
// См. Рис: Client and Server Together.jpg
// Для этого нам нужно одновременно запустить «client» (Angular) и «server» (NestJS) на нашем компьютере: Angular работает на своем порту по умолчанию, который является портом 4200, а NestJS работает на своем порту по умолчанию, который равен 3000. Мы можем рассматривать наш компьютер как одну большую «sandbox» (песочницу) или испытательный стенд, где мы имитируем то, что произойдет в реальном мире, когда эти приложения будут жить и использоваться потребителями. В реальном мире", где-то будет работать облако, а клиентом будет веб-браузер, ваш мобильный телефон, планшет или любое другое устройство, ориентированное на потребителя.
// «сserver» и «client» — это универсальные вычислительные термины, которые относятся к месту, откуда подаются данные, и к потребителю этих данных.

//TODO: Data's Journey Complete (Путешествие данных завершено)
// Раньше наш клиент (Angular) жёстко прописывал свои данные в сервисе для получения автомобилей. Насколько это скучно? Нам больше не нужно жестко кодировать наши данные. Теперь мы подключим наш front-end Angular к нашему back-end NestJS, отправив XHR ( XML/HTTP-запрос) из Angular в наш back-end NestJS, чтобы получить данные об автомобиле. Давайте изменим наш service Angular, чтобы сделать настоящий XHR для нашей серверной части вместо жесткого кодирования данных. В качестве примера мы воскресим наш старый код StackBlitz, но этот код обычно будет жить в приложении Angular на вашем компьютере.
// https://stackblitz.com/edit/angular-send-dynamic-data-to-svs?file=README.md
// Вот выше наш пример service на StackBlitz, «old» (старом) способе жесткого кодирования данных. Раньше в нашей транспортной службе были:
// TypeScript (TS):
// getCars() {
//   return this.cars;
// }
// Давайте изменим это на:
// TypeScript (TS):
// getCars(): Observable {
//   return this.http.get('/cars/');
// }
// Что это делает? Вместо того, чтобы возвращать жестко закодированное значение, мы возвращаем Observable, представляющий собой поток данных. Если вы знакомы с промисами JavaScript, Observable похож на промис. По сути, это асинхронные данные, а это означает, что, поскольку они должны перемещаться по сети, они не поступают мгновенно, поэтому мы просто «держим дверь открытой» и ждем, пока данные вернутся после того, как мы их запросили. Наконец, все, что нам нужно сделать, это добавить эти два заголовка в начало файла:
// TypeScript (TS):
// import { HttpClient} from '@angular/common/http';
// import { Observable } from 'rxjs';
// Эти две строки импортируют нашу способность использовать XHR и Observables соответственно. Наконец, если мы сейчас обновим нашу страницу Angular, мы получим: Теперь наши данные поступают из нашей базы данных в Angular. Полный путь данных завершен .
// См. Рис: Data's Journey Complete.jpg
// Наличие кода сервера, отдельного от кода клиента, называется «несвязанным приложением» и на сегодняшний день является наиболее распространенным способом доставки данных в сегодняшнем быстро развивающемся цифровом мире, поскольку существует множество различных «front-ends», которые потребляют back-end данные. В следующем модуле мы соберем реально работающее приложение для полетов, где мы будем использовать запросы GET и POST для подключения внешнего интерфейса к внутреннему.

//TODO: Overview (Обзор)
// Поздравляем, теперь у вас достаточно основы для создания полнофункционального приложения с использованием Angular. В этом модуле мы создадим full stack application (полнофункциональное приложение) под названием TSFlights. Попутно мы будем изучать некоторые новые концепции, такие как маршрутизация Angular, и познакомим вас с некоторыми второстепенными предметами, такими как таблицы стилей SCSS, так что есть еще новый контент для изучения. Тем не менее, большинство базовых навыков, необходимых для создания приложения, уже изучены.
// См. Рис: Overview_2.jpg
// Подводя итог нашему стеку технологий, мы будем использовать Angular для нашего front-end, SCSS для наших таблиц стилей (SCSS — это расширенный набор CSS), NestJS для нашего back-end и PostgreSQL для базы данных. Что хорошего в разработке полного стека с открытым исходным кодом, так это то, что многие из этих элементов взаимозаменяемы. Со временем вы можете заменить базу данных PostgreSQL базой данных MySQL, и приложение все равно будет работать прекрасно. Вы даже можете заменить интерфейс Angular другим фреймворком JavaScript, например Vue.js, и серверная часть даже не заметит разницы. Вот что значит создать несвязанное приложение. Каждая часть в чем-то автономна.
// Возможно, вы помните, что в предыдущем модуле мы упоминали, что «decoupled app» (несвязанное приложение) — это приложение, в котором front-end и the back-end разделены. В этом модуле мы создадим отдельное приложение.

//TODO: Upgrading Angular (Обновление Angular)
// Когда этот курс был написан, Google выпускал новую версию Angular каждые шесть месяцев или около того. Начало курса было написано с использованием Angular 8, но Angular 9 был выпущен как раз в тот момент, когда мы создавали этот последний модуль. Не бойтесь. Версии Angular, начиная с Angular 4 или около того, имели очень небольшие изменения в основном синтаксисе фреймворка. Большинство изменений от версии к версии на данный момент включают в себя дополнительные функции, расширенные функции, улучшения основного механизма рендеринга и устаревание некоторых функций по пути. Поскольку Angular 9 почти идентичен Angular 8 с точки зрения основного синтаксиса, мы создали наши примеры репозитория GitHub, используя Angular 9. Функциональность и поведение практически одинаковы.
// Чтобы начать использовать последнюю версию Angular в терминале вашего компьютера, просто введите:
// ng update
// Это обновит Angular до последней версии. В нашем случае это теперь стало Angular 9. Любые новые проекты, запущенные после этого момента, будут автоматически использовать версию 9, но все СТАРЫЕ версии Angular вплоть до Angular 2 по-прежнему будут работать в нашей системе.
// Вы всегда можете проверить версию любого проекта Angular, проверив файл package.json, который находится в репозитории. В категории «зависимости» есть запись «@angular/common». В нашем репозитории эта запись выглядит так: "@angular/common": "~9.0.2", что означает, что мы используем версию 9.0.2.

//TODO: Scaffolding a New Angular App (Создание нового приложения Angular)
// Теперь, когда мы обновили Angular, мы можем создать новое приложение Angular.
// ng new TSFlightsApp
// Команда «ng new» создает для нас новый проект Angular, а затем нам предоставляется несколько вариантов выбора. Мы запечатлели эти варианты на изображении ниже. Мы сказали «да» маршрутизации Angular и использовали клавиши со стрелками на клавиатуре, чтобы выбрать «SCSS» в качестве формата таблицы стилей.
// См. Рис: Scaffolding a New Angular App.jpg
// Routing (Маршрутизация) позволяет нам иметь более одной страницы в нашем приложении Angular и переходить на каждую из этих страниц, щелкая ссылки, созданные в формате, который работает с маршрутизатором Angular. Маршруты мы рассмотрим на следующем уроке.
// SCSS — это способ написания CSS, который позволяет вам писать вложенные стили CSS, использовать переменные, называемые миксинами, и множество других интересных функций. Об этом мы тоже поговорим на следующем уроке.
// Возможность создать новое приложение Angular с помощью команды ng new — одна из самых полезных функций Angular CLI (интерфейс командной строки).

//TODO: Project Resources (Ресурсы проекта)
// Давайте на минутку изучим ресурсы проекта, которые помогут вам в этом последнем путешествии по созданию приложения или проверке наших файлов, когда мы создаем это приложение. Вы можете выполнить этот проект самостоятельно или просто следить за ним, просматривая код в каждой итерации. StackBlitz — это место, где вы сможете увидеть каждую итерацию интерфейса в Angular. Поскольку это онлайн-ресурс с ограничениями безопасности, мы не сможем привязать его к реальному бэкенду, но мы будем смоделировать функциональность, которую предоставляет нам бэкэнд. Если вы следите за новостями на своем телефоне, вы сможете просматривать ресурсы в StackBlitz и изменять код, чтобы экспериментировать с новыми вещами. Гитхаб здесь у нас будут полные репозитории как для нашего front-end, так и для нашего back-end. Здесь будет жить полный исходный код как для front-end, так и для back-end.
// StackBlitz — отличный способ запуска кода Angular в Интернете, и теперь он используется командой Google Angular в качестве предпочтительной онлайн-игровой площадки Angular в официальной документации Angular.

//TODO: Single Page Apps (Одностраничные приложения)
// Angular routing (маршрутизация) основана на single page app (SPA)(одностраничном приложении) (SPA) концепции. Когда Интернет был впервые создан, большинство веб-сайтов состояло из нескольких отдельных HTML-страниц. Обычный pattern (шаблон) заключался в том, что каждая страница имела свой собственный верхний и нижний колонтитулы и многие другие общие элементы, общие со всеми другими страницами сайта. Это было невероятно неэффективно, потому что было МНОГО дублированного контента. Каждый раз, когда вы создавали страницу, вы создавали клон предыдущей страницы и просто меняли «основной контент» страницы на что-то другое. Страница «о нас» на самом деле была клоном страницы «свяжитесь с нами» с заменой среднего содержимого или основного содержимого. Это упростило для поисковых систем идентификацию различных страниц в Интернете, но часть неэффективности была связана с тем, что каждая новая страница должна была «re-load» один и тот же header and footer (верхний и нижний колонтитулы) и другой общий контент снова и снова.
// Одностраничные приложения коренным образом изменили эту парадигму. В одностраничном приложении обычно есть только ОДНА страница на веб-сайте. Вот и все. Затем платформа загружает настроенные «sub pages» (подстраницы) или «partials» (частицы) в назначенные разделы на странице, которые должны иметь переменное содержимое. Это делает одностраничные приложения очень быстрыми.
// См. Рис: Single Page Apps.jpg
// Gmail был первым в мире крупномасштабным одностраничным приложением. Если у вас есть Gmail, загрузите его и нажмите любую ссылку в приложении Gmail (прочитайте отдельное электронное письмо, перейдите на вкладку «социальные сети» или «обновления» и т. д.). Вы заметите, что на самом деле он никогда не загружает новую страницу. Содержимое этих разделов заменяется новым содержимым, соответствующим тому, на что вы нажали. Это классический пример одностраничного приложения.

//TODO: Making New Routes (Создание новых маршрутов)
// Наше приложение будет очень простым. У нас будет всего две страницы: «home» и «admin». Создадим «home» маршрут. Как вы помните, в Angular мы можем построить home component, выполнив:
// ng generate component home
// или
// ng g c home
// Мы сделаем то же самое для нашего admin component, выполнив:
// ng g c admin
// Теперь нам нужно перейти к нашему файлу src/app/app-routing.module.ts и добавить routes для наших вновь созданных компонентов.
// См. Рис: Making New Routes.jpg
// Массив routes должен быть массивом objects, где каждый object имеет ключ «path», значением которого является имя link (ссылки), и ключ «component», значением которого является actual component, на который вы ссылаетесь. Приведенный выше код сообщает нашему маршрутизатору, что у нас есть ссылки «home» и «admin», которые ведут к HomeComponent и AdminComponent соответственно. Попробуйте на StackBlitz
// https://stackblitz.com/edit/angular-new-routes?file=README.md
// При создании маршрутов «path» может быть каким угодно. По соглашению большинство людей выбирают имя ссылки, полностью или частично отражающее имя компонента. Но если вы хотите, ссылка «home» может быть названа «dashboard»     (панель инструментов) или любым другим псевдонимом, который лучше соответствует названию или духу любой данной страницы.

//TODO: Making a Nav Bar (Создание панели навигации)
// «path» в каждом из routes (маршрутов), которые мы создали на прошлом уроке, — это имя ссылки, по которой пользователь будет нажимать, чтобы посетить каждую «page». Помните, что на самом деле у нас есть только one page (одна страница), и Angular динамически загружает содержимое каждой из наших sub pages (подстраниц) в single page app (одностраничное приложение). Теперь мы перейдем к app.component.html и добавим «nav bar» над выходом нашего маршрутизатора, чтобы у нас были ссылки, ведущие на две наши соответствующие страницы. «nav bar» ниже — это простой раздел внутри тегов div. Это позволяет нашему маршрутизатору узнать, что у нас есть ссылки «home» и «admin», которые будут вести к HomeComponent и AdminComponents соответственно.
// Крайне важно, чтобы панель навигации не существовала в тегах router-outlet. Ссылки в верхней части страницы на панели навигации не могут быть частью страницы, которая изменяется при нажатии на ссылку, иначе меню исчезнет, ​​как только мы нажмем на ссылку. Другими словами, меню должно быть независимым от меняющейся части страницы. Давайте рассмотрим код ниже. Тег привязки ( <a> ), использует routerLink атрибут с точки зрения href. Атрибут routerLink заставляет эти ссылки работать с маршрутизатором Angular. Раздел router-outlet в нижней части кода подобен «контейнеру», в котором подстраницы появляются при нажатии на любую ссылку с атрибутом routerLink. Когда вы нажимаете «дом» или «администратор», компоненты «дом» и «администратор» соответственно отображаются как подстраницы в router-outlet. На этих страницах написано «домашняя работа» и «админ работает» соответственно, так как это страницы по умолчанию, которые были созданы, когда мы их формировали.
// HTML:
{
  /* <div>
  <a routerLink="home"> home </a>
  <a routerLink="admin"> admin </a>
</div>
<router-outlet></router-outlet> */
}
// Попробуйте на StackBlitz
// https://stackblitz.com/github/SoloLearn-Courses/angular-navigation-bar?file=README.md
// Посмотреть на GitHub
// https://github.com/SoloLearn-Courses/angular-navigation-bar/blob/master/src/app/app.component.html
// Любая панель навигации, которую вы создаете в Angular, должна существовать вне компонента router-outlet. В следующей части этого урока более подробно рассказывается о router-outlet и routerLink .

//TODO: Using routerLink (Использование routerLink)
// Давайте посмотрим на нашу страницу app.component.html. Вверху мы создаем ссылки на подстраницы, используя атрибут routerLink в теге a. Атрибут routerLink используется вместо href, чтобы ссылки работали с маршрутизатором Angular. Наконец, в нижней части страницы (или там, где мы хотим, чтобы подстраницы отображались) мы используем компонент Angular router-outlet. Этот компонент похож на «box» или iframe, который загружает каждую страницу в наше single page app. Это НЕ iframe, но функциональность может выглядеть несколько похожей с точки зрения концепции.
// См. Рис: Using routerLink.jpg
// С добавлением этих нескольких строк кода в наш html-файл у нас теперь есть работающее single page app!
// Попробуйте на StackBlitz
// https://stackblitz.com/edit/angular-navigation-bar?file=README.md
// Посмотреть на GitHub
// https://github.com/SoloLearn-Courses/angular-navigation-bar
// В Angular router-outlet — это компонент, который будет отображать результат любого текущего маршрута.

//TODO: Creating the Service (Создание службы)
// Итак, теперь, когда у нас есть страница администратора и домашняя страница, мы можем начать размещать на главной странице некоторую актуальную информацию о рейсах. Мы добавим flights service:
// ng g service flights
// или:
// ng g s flights
// который создает для нас файл flights.service.ts.
// Затем мы добавляем эту строку в начало home.component.ts.
// TypeScript (TS):
// import { FlightsService } from './flights.service';
// и измените файл home.component.ts следующим образом:
// См. Рис: Creating the Service.jpg
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-flights-service?file=README.md
// View на GitHub:
// https://github.com/SoloLearn-Courses/angular-flights-service
// Помните, что служба обычно используется в качестве шлюза для общих данных в приложении.

//TODO: Making a Flight Model (Создание летной модели)
// Наконец-то мы подошли к тому моменту, когда нам нужно решить, как выглядят наши фактические полетные данные. У нас есть макет, так что давайте посмотрим на него.
// См. Рис: Making a Flight Model.jpg
// Судя по макету, рейсу нужны города «из», «куда», номер рейса, время отправления, время прибытия и логическое значение, чтобы указать, является ли это беспосадочным рейсом. Мы можем сделать вот такую ​​модель и вставить ее в файл flight.model.ts:
// TypeScript (TS):
// export interface Flight
//     { origin: string;
//      destination: string;
//      flightNumber: number;
//      depart: Date;
//      arrive: Date;
//      nonstop: boolean };
// Обратите внимание, что мы используем тип Date для двух наших полей. Тип даты? Это существует. Он встроен в TypeScript. Объект JavaScript Date по своей сути является встроенным типом TypeScript. Еще одна замечательная особенность TypeScript... способность переменной содержать явное значение даты. Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-flight-model?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-flight-model
// Еще один способ просмотреть «model» в TypeScript — это что-то вроде чертежа. «model» airplane имеет форму настоящего airplane. Это не реальная вещь, но это план для реальной вещи. «model» для полета не является реальным полетом, но имеет форму полета: пункт отправления, пункт назначения, номер рейса и т.д.

//TODO: Making Our Service Methods (Создание наших Service методов)
// Давайте теперь заполним наш service всеми методами, которые нам понадобятся. Эти методы скоро будут использоваться для связи с нашей back-end:
// См. Рис: Making Our Service Methods.jpg
// Здесь мы используем фиктивные полеты: Массив flights: Flight[] для имитации двух простых полетов, просто чтобы дать нашему service что-то, что нужно вернуть для front-end, чтобы мы могли его стилизовать с CSS. Настоящие методы получения, отправки и удаления будут в конечном итоге связываться с нашим back-end.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-flights-service-methods?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-flights-service-methods
// Наш service похож на автобусный или железнодорожный вокзал. Он служит центром передачи данных.

//TODO: Populating the View (Заполнение представления)
// Наконец, теперь мы можем зацикливаться на наших рейсах, поступающих из нашего сервиса, реализуя простой *ngFor в view (представлении). Это дает нам немного данных о полете, которые мы можем использовать для повторения, чтобы мы могли организовать данные.
// См. Рис: Populating the View_1.jpg
// Класс CSS, который мы применили, делает очень простую работу по правильному выравниванию содержимого каждой строки с помощью flexbox. Flexbox — это набор инструментов, встроенных в CSS3, которые упрощают верстку. Полное погружение в flexbox выходит за рамки этого курса, но посмотрите, сможете ли вы понять, что этот CSS делает в коде.
// См. Рис: Populating the View_2.jpg
// А вот как это выглядит в view (представлении):
// См. Рис: Populating the View_3.jpg
// Если вам интересно узнать о Flexbox, удалите стили из живого кода на StackBlitz и посмотрите, что получится. Это хороший практический способ увидеть, как эти элементы объединяются.
// Кроме того, продолжайте читать. Если вам интересно, как мы можем исправить эти длинные даты, есть быстрое исправление, которое предоставляет Angular, и оно состоит всего из 5 символов. Мы рассмотрим это на следующем уроке. Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-flights-populated-view?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-flights-populated-view
// Flexbox и CSS grid — это две популярные структуры компоновки, встроенные в стандартный CSS и поддерживаемые во всех браузерах. Мы не будем использовать сетку CSS в этом проекте, но это еще один инструмент, который существует для вас, если вам нравится изучать инструменты визуального макета.
// Смотри, ты идешь!

//TODO: Pipes (каналы)
// Теперь обратимся к тому факту, что при просмотре времени полета никто не может и не хочет читать «2020-02-25T23:18:21.932Z». Это необработанная дата JavaScript. Нам нужен процесс для анализа даты в удобочитаемых терминах. Это наше текущее представление: к счастью, в Angular есть так называемые Pipes (каналы), которые могут преобразовывать данные в view (представлении) из одного формата в другой. В программировании pipes — это процессы, которые принимают значение и преобразуют это значение во что-то другое. Строго говоря, pipes принимают выходные данные одной функции, а затем передают их на вход другой. Но с точки зрения непрофессионала данные по pipes (каналам) ПРЕОБРАЗОВАЮТСЯ. Это все, что вам нужно знать, чтобы использовать встроенные Pipes Angular. Вы можете написать Pipe, используя | key.
// См. Рис: Pipes.jpg.jpg
// Прямо сейчас код времени вылета рейса в представлении выглядит так:
// HTML:
{
  /* <div class="departs"> {{flight.depart }}</div> */
}
// Мы можем взять значение Flight.depart и передать его в формат даты следующим образом:
// HTML:
{
  /* <div class="departs"> {{flight.depart | date }}</div> */
}
// И затем, волшебным образом, наши даты теперь выглядят так в представлении:
// См. Рис: Pipes.jpg_2.jpg
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-flights-pipes?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-flights-pipes
// Angular имеет несколько встроенных каналов. Есть валютная воронка, где {{ total | currency }} выведет что-то вроде этого: $4.00, где "total" будет число 4, строчная черта чем преобразует строки в нижний регистр, процентная черта и так далее. Angular даже позволяет создавать собственные pipes.

//TODO: Structure (Состав)
// Наконец-то мы подошли к тому моменту, когда начнем создавать некоторую визуальную структуру для нашего приложения. Картинка стоит тысячи слов, поэтому мы постепенно добавим в приложение некоторую структуру SCSS и поговорим об этом. Мы предполагаем, что если вы проходите этот курс, у вас есть базовые знания CSS, поэтому мы не будем учить CSS, но обсудим, как Angular использует CSS в контексте SCSS. Первое, что мы собираемся сделать, это добавить красивое фоновое изображение горы и заголовок. У Angular есть главный или «корневой» файл SCSS (src/styles.scss), который применяется ко всем компонентам в приложении. Поскольку фон и заголовок будут общими для всех страниц, мы поместим их в эту корневую таблицу стилей. Вот мобильное (телефонное) представление приложения:
// См. Рис: Structure.jpg
// Примечание. Фоновое изображение горы было предоставлено веб-сайтом Unsplash, где вы можете скачать изображения бесплатно и без лицензионных отчислений, не беспокоясь о нарушении авторских прав. Фото гор предоставлено Марко Бономо.
// См. Рис: Structure_2.jpg
// Если вы клонируете репозиторий GitHub на компьютер, обязательно проверьте ветку с именем «step1». 
// Попробуйте на StackBlitz:
// https://stackblitz.com/github/SoloLearn-Courses/TSFlights1/tree/step1?file
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/TSFlights1/tree/step1
// SCSS — это superset (надмножество) CSS. Это позволяет использовать специальные вещи, такие как nested styles and mixins (вложенные стили и примеси), которые по сути являются переменными в CSS.

//TODO: Blocking the Header (Блокировка заголовка)
// В header (заголовке) мы создадим div для logo (логотипа), а затем еще один div для links (ссылок). Затем мы воспользуемся свойством flexbox justify-content: space-between, чтобы поле с логотипом и поле со ссылкой «float» (плавали) влево и вправо соответственно. Поскольку и поле с логотипом, и поле со ссылкой находятся внутри заголовка, SCSS позволяет нам вложить эти два стиля в стиль заголовка. См. изображение ниже: 
// См. Рис: Blocking the Header.jpg
// Вот результат: 
// См. Рис: Blocking the Header_2.jpg
// Обратите внимание, что сейчас мы обвели пунктирной линией поле ссылки. Иногда я делаю это, когда блокирую элементы, просто чтобы увидеть, сколько места они занимают. Позже, когда интервал правильный, я удаляю границу. Мы также использовали align-self: flex-start и align-self: flex-end, чтобы выровнять поле с логотипом и поле ссылки по началу и концу соответственно. В этом случае, поскольку направление flex — строка (горизонтально), flex-start почти как float:left, а flex-end почти как float:right. Это не floats (поплавки), и во многих отношениях они очень разные, но они одинаково размещают объекты на соответствующих концах контейнера. 
// Попробуйте на StackBlitz:
// https://stackblitz.com/github/SoloLearn-Courses/TSFlights1/tree/step2?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/TSFlights1/blob/step2/src/styles.scss
// Nested (Вложенные) стили — это особенность SCSS. Они экономят место, потому что уменьшают количество повторений при объявлении стилей CSS. Это одно из огромных преимуществ SCSS. Вложенные стили также легче читать из-за их иерархического отступа.

//TODO: Finishing the Header (Завершение заголовка)
// Вот готовый заголовок. 
// См. Рис: Finishing the Header.jpg
// Обратите внимание на html-структуру заголовка: 
// См. Рис: Finishing the Header_2.jpg
// обратите внимание на тот факт, что ссылки, которые раньше были буквой «а», теперь являются кнопками. routerLink работает как с кнопками, так и с тегами привязки. («a» означает якорь в HTML). 
// Попробуйте на StackBlitz:
// https://stackblitz.com/github/SoloLearn-Courses/TSFlights1/tree/step3?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/TSFlights1/tree/step3
// Атрибут routerLink обычно зарезервирован для тегов привязки и кнопок, но он может применяться к любому допустимому элементу html, если вы хотите создать ссылку, которая запускает страницу, зарегистрированную с помощью маршрутизатора Angular.

//TODO: Media Queries (Медиа-запросы)
// В наш последний пример кода StackBlitz на предыдущем уроке было включено еще одно свойство CSS, которое мы еще не обсуждали: media query (медиа-запросы). Медиа-запрос — это специальное правило, которое применяется только к определенным условиям, при которых просматривается веб-страница. Например, есть медиа-запросы для форматирования страницы, которые применяются ТОЛЬКО, если вы просматриваете предварительный просмотр. Существуют также медиа-запросы, которые применяются только в том случае, если ваш экран меньше определенного количества пикселей. Почему это важно? Что ж, ширина устройства вашего телефона может составлять всего 480 пикселей, в то время как полная ширина настольного устройства обычно превышает 1200 пикселей. Мы используем медиа-запросы, чтобы сказать браузеру: «Эй, если тебе действительно не хватает места, используй этот специальный набор правил CSS, когда дела идут плохо».
// На полнофункциональном веб-сайте обычно есть три или более медиа-запросов для разных размеров устройств, которые определяют стили для мобильных устройств, планшетов и компьютеров соответственно. В нашей демонстрации я заметил, что логотип обрезается в окне StackBlitz из-за небольшой ширины экрана, поэтому я написал этот медиа-запрос внутри .logo_box:
// См. Рис: Media Queries.jpg
// @media screen и max-width : 497px означает «Если мы находятся на экране, а размер экрана составляет 497 пикселей и менее, используйте эти вложенные стили для поля logo_box. " Обратите внимание, что они применяются ТОЛЬКО к элементу logo_box и ни к чему другому на странице. 
// Попробуйте на StackBlitz:
// https://stackblitz.com/github/SoloLearn-Courses/TSFlights1/tree/step3?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/TSFlights1/blob/step3/src/styles.scss
// Медиа-запросы помогают определить, как стили CSS должны вести себя при изменении размера экрана. Вот почему вы часто будете видеть три полосы или то, что мы называем «гамбургер-меню», в качестве меню на адаптивных веб-сайтах, когда вы просматриваете их на телефоне, а не на настольном компьютере или ноутбуке.

//TODO: Making the Flights Panel (Создание панели полетов)
// Теперь мы создадим стили, которые видны только на домашнем компоненте. Для этого мы используем файл home.component.scss. Мы добавили div, который назвали «flight_pane». Это будет белое поле, содержащее данные о рейсе. Мы также добавили медиа-запрос в нашу панель Flight_pane, чтобы она «привязывалась» к полноэкранному режиму, когда экран браузера становится меньше 481 пикселя. Обратите внимание, что мы использовали максимальную ширину как правило, но вы также можете использовать минимальную ширину в качестве правила медиа-запроса. max-width применяется ко всему ДО этой максимальной ширины. min-width применяется ко всему, ПО КРАЙНЕЙ МЕРЕ, этой минимальной ширины и выше. 
// См. Рис: Making the Flights Panel.jpg
// … и вот результат: 
// См. Рис: Making the Flights Panel_2.jpg
// Попробуйте на StackBlitz:
// https://stackblitz.com/github/SoloLearn-Courses/TSFlights1/tree/step4?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/TSFlights1/blob/step4/src/app/home/home.component.scss
// Правила для любого заданного медиа-запроса зависят от дизайнера. Если вы главный программист и дизайнер, то вам решать, как должны выглядеть страницы на телефоне, планшете или полноэкранном устройстве.

//TODO: Finishing the Flights Page (Завершение страницы рейсов)
// Я потратил время, чтобы конкретизировать стиль на странице рейсов. Делая страницу адаптивной для мобильных устройств, я обнаружил, что дата отправления даже в формате даты с использованием канала даты Angular была слишком длинной. Итак, я зашел в документацию Angular и нашел формат канала даты под названием «shortDate». Статья документации Angular, в которой рассматриваются все параметры DatePipe, находится здесь. 
// https://angular.io/api/common/DatePipe
// Я очень откровенен в отношении процесса создания здесь, потому что умение иметь проблему, а затем решать эту проблему путем чтения документации — это ключевой навык разработчика. В любом случае, вот изменение формата даты, чтобы дата соответствовала нашей новой, более свежей странице рейсов с большим стилем:
// HTML:
{/* <div class="departs cell"> 
  {{flight.depart | date : 'shortDate' }}
</div> */}
// Канал даты сам по себе дал нам 25 февраля 2020 года, тогда как конвейер даты с форматом shortDate дал нам 2/25/20, что лучше соответствует нашим требованиям при использовании небольшого экрана. Конечно, на странице с реальными рейсами будет масса информации, включая выбор между перелетом в одну сторону и туда и обратно, фактическое время дня в часах или минутах, связанное с вылетом и прибытием, варианты оплаты и многое другое. Цель этого проекта — просто продвинуть вас достаточно далеко в плане понимания основ TypeScript и Angular, чтобы вы могли рискнуть позже и создать что-то свое. Вот как выглядит наша страница сейчас:
// См. Рис: Finishing the Flights Page.jpg
// Мы также изменили ввод в форме, чтобы использовать меню выбора. Причины этого практические; у нас еще нет базы данных, полной городов, поэтому предоставление тестовым пользователям нескольких предопределенных городов гарантирует, что они будут запрашивать только те города, которые есть в нашей системе прямо сейчас. 
// Попробуйте на StackBlitz:
// https://stackblitz.com/github/SoloLearn-Courses/TSFlights1/tree/step5?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/TSFlights1/blob/step5/src/app/home/home.component.scss
// Вывод определенных pipes (каналов) можно изменить с помощью параметров «format». Даты могут быть отформатированы дюжиной различных способов. Валютная цепочка может быть отформатирована для сотен различных валют со всего мира. Просмотрите документацию по pipes Angular для получения дополнительной информации: https://angular.io/api/common#pipes .

//TODO: The Database (База данных)
// Теперь у нас достаточно front-end, и если бы мы могли получать данные из back-end, мы могли бы фактически увидеть «реальные» полеты, совершающие долгий путь данных из базы данных через сервер NestJS в наш Angular front-end. Сейчас мы построим этот pipeline (канал). Первое, что мы сделаем, это создадим нашу базу данных. Мы собираемся сохранить нашу базу данных «transportation», которую мы начали в предыдущем модуле. Прямо сейчас в этой базе данных есть только таблица с именем «cars». Мы добавим таблицу с названием «flights». Наша модель полета из нашего Angular front-end напоминает нам обо всех полях, которые нам понадобятся. Помните, что ввод psql в терминал на вашем компьютере приведет вас к командной строке psql. Оттуда вы можете выполнить следующие шаги:
// \c transportation
// CREATE TABLE flights (id SERIAL, 
// origin VARCHAR(20), 
// destination VARCHAR(20), 
// flightNumber INT, 
// depart TIMESTAMP WITH TIME ZONE,
// arrive TIMESTAMP WITH TIME ZONE, 
// nonstop BOOLEAN);
// Примечание. Заглавные буквы необязательны в синтаксисе создания таблицы. Я просто использую их здесь, чтобы различать имена столбцов и типы столбцов. После того, как мы создали таблицу, она может выглядеть так: 
// См. Рис: The Database.jpg
// Многих новых разработчиков удивляет, когда они обнаруживают, что время, особенно время в международном масштабе, является одной из самых сложных областей программирования. Ради нашего приложения мы используем очень простое вымышленное время для времени отправления и посадки без учета часовых поясов, летнего времени, штатов, которые не учитывают летнее время и т.д. Чтобы создать новый объект даты в JavaScript, вы можете использовать Date объект. Чтобы получить дату прямо сейчас, откройте терминал JavaScript или используйте ссылку на игровую площадку, указанную ниже, чтобы поэкспериментировать с датами. Попробуй сам:
// https://www.sololearn.com/learning/1092/3426/7812/1
// JS:
// // the current date can be obtained by calling new Date()
// const currentDate = new Date(); 
// console.log("time now: \n" + currentDate + "\n");


// // you can pass the Date method a string to create
// // a specific date for a specific time: present, future , or past
// const futureDate = new Date("2030-10-10");
// console.log("future date:" + "\n" + futureDate+ "\n");


// // you can make the date you pass into the Date function longer by adding time of day in a 24 hour format
// const futureDetailedDate = new Date("2030-10-10T09:00:00");
// console.log("future date with specific time:" + "\n" +futureDetailedDate);
// В PostgreSQL TIMESTAMP WITH TIME ZONE соответствует объекту даты/времени в JavaScript. Вы можете взять объект Date() в JavaScript (например, const currentDate = new Date()), который даст вам и напрямую поместит это значение в Базу данных PostgreSQL.

//TODO: Create a NestJS Server (Создайте сервер NestJS)
// Теперь мы настроим наш сервер NestJS с TypeORM для взаимодействия с нашей базой данных. Мы настроим сервер для полетов CRUD (создание, чтение, обновление и удаление) в нашей системе. Это повторение процесса, который мы делали ранее в этом курсе. Ранее мы настроили папку автомобиля с контроллером, модулем, сервисом и сущностью. Мы сделаем то же самое для рейсов. 
// Для обзора: 
// controller — это то, что на самом деле взаимодействует с внешним миром… другими приложениями, такими как Angular, которые хотят взаимодействовать с нашим сервером NestJS посредством нашего API. Контроллер содержит API endpoints (конечные точки API).
// Сервис содержит такие методы, как findAll(), findOne(), delete() и т.д., которые взаимодействуют с TypeORM (наша ORM — это то, что взаимодействует с базой данных). 
// entity (Сущность) помогает определить форму нашей таблицы базы данных , с которой мы общаемся; в данном случае "flights". 
// module (Модуль) обеспечивает поддержку сервиса и контроллера. Когда мы все это настроим, добавим несколько рейсов в нашу базу данных и зайдем на localhost:3002/flights на нашем компьютере, мы получим JSON-коллекцию всех наших рейсов, находящихся в настоящее время в системе: 
// См. Рис: Create a NestJS Server.jpg
// Вот ссылка на ветку GitHub. в котором есть весь код для каждого из этих четырех файлов. Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/nest_flights/tree/step1/src/flights
// Как правило, в NestJS мы используем службу для связи с TypeORM, которая затем взаимодействует с базой данных. Когда служба получает ответ, она отправляет эти данные контроллеру. Затем контроллер подключается к конечным точкам API, которые взаимодействуют с нашим интерфейсом.

//TODO: Connecting Our Angular Front-End (Подключение нашего интерфейса Angular)
// Теперь, когда наш NestJS API правильно извлекает рейсы из базы данных через ORM, мы можем перенести эти рейсы в Angular, и впервые данные будут полностью перетекать из нашей базы данных в наше внешнее приложение Angular TS Flights. В настоящее время в Angular мы имитируем несколько полетов в нашем FlightContoller: 
// См. Рис: Connecting Our Angular Front-End.jpg
// мы преобразуем его в Observable, который делает вызов API к нашему бэкенду NestJS, работающему на порту 3002. Затем мы удалим весь блок кода и вместо этого вытащим в данных службы полетов с observable. Итак, мы изменим ЭТО:
// TypeScript (TS):
// getFlights() {
//   return this.flights;
// }
// к этому:
// TypeScript (TS):
// getFlights(): Observable<any> {
//   return this.http.get('http://localhost:3002/flights/');
// }
// Обратите внимание на двоеточие после getFlights() и перед словом Observable. Это означает, что этот метод возвращает Observable. В двух словах, то, что мы здесь делаем, — это замена жестко закодированного массива рейсов на Observable, который представляет собой поток данных, поступающий из серверной части. Код пока не будет работать, потому что нам нужно настроить представление, чтобы подписаться на поток данных, поступающих от observable. Мы сделаем это в следующей части. Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/TSFlights1/blob/step6/src/app/flights.service.ts
// Observable — это поток данных. Мы можем subscribe (подписаться) на observable, чтобы использовать содержащиеся в ней данные.

//TODO: Subscribing to Observables (Подписка на наблюдаемые)
// Теперь, когда наше приложение Angular правильно извлекает данные, мы должны исправить view (представление), чтобы представление могло получать данные, поступающие от службы, которая больше не является «hard coded». В нашем сервисе метод getFlights() сервиса Flights теперь выглядит так:
// TypeScript (TS):
// getFlights(): Observable<any> {
//   return this.http.get('http://localhost:3002/flights/');
// }
// Это означает, что когда наше представление инициализировано, нам нужно начать подписываться на поток входящих данных. А пока давайте подпишемся на наш Observable таким образом в нашем файле home.component.ts. Во-первых, мы добавляем «OnInit» к нашему импорту Angular в верхней части home.component.ts:
// TypeScript (TS):
// import { Component, OnInit } from '@angular/core';
// Затем мы модифицируем home.component.ts следующим образом: 
// См. Рис: Subscribing to Observables.jpg
// ngOnInit() — это метод, который вызывается при первом запуске компонента. Следуйте номерам на диаграмме, чтобы соответствовать следующему алгоритму: 
// 1. Сделайте так, чтобы класс компонента реализовал метод OnInit, чтобы мы могли его использовать. Затем 
// 2. Используйте метод ngOnInit для вызова метода getFlights () из FlightService. Этот метод возвращает Observable, так что получите Observable и
// 3. Подпишитесь на него. Когда подписка будет завершена (то есть, когда данные поступят), затем 
// 4. Назначьте все, что вы получите от Observable, переменной this.flights.
// После того, как мы все это сделали, нам вообще не нужно менять наше представление… оно ищет множество полетов типа Flight, и теперь они его получили. В представлении наши полеты теперь работают. Данные выглядят одинаково, но мы знаем, что все наши данные поступают из базы данных, и это большая победа.
// См. Рис: Subscribing to Observables_2.jpg
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/TSFlights1/blob/step7/src/app/home/home.component.ts
// Есть несколько разных способов использовать Observables в Angular. Использование .subscribe() — один из самых простых способов, когда вы только начинаете учиться. Позже мы пойдем другим путем.
