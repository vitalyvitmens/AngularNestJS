//TODO: Angular + NestJS (Угловой + ГнездышкоJS)
// Погрузитесь в TypeScript, влиятельный язык для веб-разработки. Узнайте, как Angular и NestJS объединяются для создания крупномасштабных приложений JavaScript.

//TODO: SETUP ANGULAR ON YOUR LOCAL SYSTEM:
// node -v //чтобы проверить наличие установленного nodeJS
// npm -v //чтобы проверить наличие установленного менеджера пакетов npm

// npm install -g @angular/cli //чтобы УСТАНОВИТЬ Angular CLI
// ng new my-app //создать свой проект с любым названием, в данном случае my-app, выбрать css и нажать enter, на ответы отвечаем: N
// cd my-app //перейдите в папку рабочей области
// ng serve --open //запускаем localhost:4200, на ответы отвечаем: N
//TODO: Если localhost:4200 не запустился:
// Открываем под админом CMD/PowerShell и выполняем две команды:
//   net stop winnat
// а затем:
//   net start winnat
//TODO: Давайте сделаем Angular-сервис. Angular может сгенерировать сервис для вас с помощью простой команды, поэтому вам не нужно помнить, как построить базовую структуру. Для этого мы используем эту команду в компьютерном терминале:
//    cd my-app
//    ng generate service transportation
// Это создает пустой сервис в приложении Angular.

//TODO: Welcome to Full Stack Web Development (Добро пожаловать в веб-разработку с полным стеком)
// Поздравляем! Вы сделали большой шаг к тому, чтобы стать Full Stack разработчиком!
// В дополнение к прохождению этого курса не забудьте воспользоваться всей поддержкой обучения, доступной вам на SoloLearn, включая ежедневные советы, практики «Попробуйте сами», задачи тренера по коду, игровую площадку для кода и участие в нашем замечательном сообществе учащихся. Мы рады услышать от вас, поэтому, пожалуйста, оставляйте комментарии и отзывы, когда вы учитесь с нами.

//TODO: Overview (Обзор)
// Добро пожаловать на курс Full Stack TypeScript! В этом курсе вы будете создавать динамический интерфейсный веб-сайт и веб-приложения, которые работают вместе, и вы будете создавать все, используя TypeScript! Вы будете создавать вымышленный веб-сайт под названием «TS Flights», который имеет два основных интерфейса: один позволяет вводить рейсы самолетов в панель администратора, а другой позволяет искать рейсы. Мы создали предварительный просмотр, который позволит вам увидеть весь код как на передней, так и на внутренней стороне, а также рабочую модель готового веб-сайта, чтобы вы могли видеть, что вы будете создавать.
// См. Рис: Overview.jpg
// Не пугайтесь! Мы научим вас летать с TypeScript шаг за шагом.

//TODO: The Concept of Web Stacks (Концепция веб-стеков)
// Часто вы услышите, как программисты ссылаются на различные стеки в веб-разработке. За последние несколько лет мы наблюдаем распространение многих стеков, в том числе:
// • MEAN (Mongo, Express, Angular и Node)
// • LAMP (Linux, Apache, MySQL и PHP)
// • Python-Django
// • Ruby on Rails
// • .NET
// и скоро. Важно понимать, что эти стеки постоянно изобретаются, заново изобретаются, повторяются и смешиваются с другими стеками. Стек MEAN превратился в PEAN или NEAP .
// stack, когда некоторые разработчики начали возвращаться к использованию Postgresql вместо Mongo для ресурса базы данных, связанного с этим конкретным стеком. Стек — это не технический термин. Это расплывчатый термин, который может быть очень изменчивым, а иногда даже субъективным. Однако важно уметь сформулировать, с какими стеками вы чувствуете себя наиболее комфортно, когда станете разработчиком полного стека. Этот курс будет сосредоточен на обучении вас общим принципам полной веб-разработки с использованием относительно нового стека: стека на основе TypeScript с использованием Angular и NestJS. Эти навыки можно будет перенести в другие стеки, которые вы изучите в будущем.
// Стек TypeScript с использованием Angular и NestJS — один из новейших стеков в веб-разработке.

//TODO: Front-End vs Back-End (Фронт-энд против бэк-энда)
// Мы будем использовать аналогию с кухней, чтобы проиллюстрировать, как front-end и back-end взаимодействуют друг с другом. Изучите это изображение:
// См. Рис: Front-End vs Back-End_1.png
// В полнофункциональной веб-разработке холодильник можно рассматривать как БАЗУ ДАННЫХ или набор ресурсов данных, кухню — как WEB APPLICATION SERVER (СЕРВЕР ВЕБ-ПРИЛОЖЕНИЙ), а столовую — как набор технологий, который содержит в основном HTML, FRONT-END JAVASCRIPT, CSS и images (изображения).
// См. Рис: Front-End vs Back-End_2.png
// Для нашей аналогии базы данных и сервер веб-приложений являются частью серверной части. HTML CSS и интерфейсный JavaScript являются частью внешнего интерфейса.
// JavaScript и TypeScript можно использовать ОБА в front and the back-end of the stack.

//TODO: The Front-End (Интерфейс)
// В веб-разработке front-end (интерфейс) — это то, что видит пользователь. Экран, на который вы сейчас смотрите, — это внешний интерфейс приложения, будь то на телефоне, планшете или компьютере. Интерфейс в основном состоит из изображений, текста и виджетов, с которыми взаимодействует пользователь. Если для этих элементов требуется база данных, закулисная логика, процесс входа/аутентификации, отслеживание аналитики, общение с другими пользователями и другие подобные вещи, то интерфейсу нужен сервер. Однако не для всех интерфейсных приложений требуется серверная часть. Когда всемирная паутина впервые стала популярной в середине 1990-х годов, многие веб-сайты не имели серверной части. Простая HTML-страница с изображениями, текстом, контактной информацией и ссылкой на электронную почту не обязательно требует серверной части!
// Если вы создадите простой файл HTML на своем компьютере прямо сейчас, вы создадите то, что мы называем static web application (статическим веб-приложением). Это статическое приложение будет интерфейсом. В Интернете есть ресурсы, такие как Firebase, где вы можете разместить свои простые статические HTML-страницы почти мгновенно и бесплатно.
// Мир технологий стал очень специализированным. Многие разработчики специализируются только на front-end или back-end веб-разработке.

//TODO: The Back-End (Бэк-Энд)
// Серверная часть — это место, где живут как сервер веб-приложений, так и база данных. Есть множество других элементов, которые находятся внутри внутреннего пространства, таких как балансировщики нагрузки, сервисные работники, почтовые серверы и так далее. Однако в этом курсе мы сосредоточимся в первую очередь на сервере веб-приложений и базе данных.
// Наш сервер TS Flights будет иметь следующие основные обязанности:
// • Обработка запросов от внешнего интерфейса на информацию
// • Создание, чтение, обновление и удаление полетов самолетов в системе
// • Отправка информации обратно во внешний интерфейс в формате JSON (JavaScript Object Notation) (Java Сценарий Объекта Обозначения).
// Основной обязанностью серверной части является обработка данных, тогда как основной обязанностью внешней части является отображение данных и обработка взаимодействия с пользователем. Внешние интерфейсы также обрабатывают данные, но тяжелые манипуляции с данными, как правило, относятся к области серверных.
// Мы используем аббревиатуру CRUD (Create, Read, Update and Delete) для описания процессов создания, чтения, обновления и удаления данных.

//TODO: JavaScript and TypeScript throughout the Stack (JavaScript и TypeScript во всем стеке)
// JavaScript стал популярным полнофункциональным инструментом в 2009 году после выпуска NodeJS. До выпуска NodeJS JavaScript рассматривался в первую очередь как инструмент только для front-end, используемый для создания виджетов, действий пользователя на странице, манипулирования DOM (структурой веб-страницы) и других задач только для front-end. После выпуска NodeJS JavaScript стал рассматриваться как отличный инструмент для создания как back-ends так и front-ends одинаково. TypeScript был выпущен Microsoft в 2012 году, потому что многие разработчики JavaScript выразили желание иметь более структурированные и четкие типы данных, особенно для использования в крупномасштабных приложениях. TypeScript имеет некоторые функции, такие как статическая типизация переменных и интерфейсы, которые присутствуют в уважаемых устаревших языках, таких как Java и C#.
// TypeScript — это надмножество JavaScript. Это означает, что TypeScript переносится в JavaScript. Он буквально транслируется в код JavaScript при компиляции и перед запуском. TypeScript переводится в JavaScript. Это важная концепция, которую нужно помнить! Таким образом, после выпуска NestJS имело логическое значение, что TypeScript можно было использовать во всем стеке веб-приложений, как это было с JavaScript.
// Одним из создателей Typescript был сотрудник Microsoft Андерс Хейлсберг, создатель C#.

//TODO: XHR (XML/HTTP Request)
// Следующей концепцией, которую необходимо понять, является is the request / response nature of full stack applications (характер запроса/ответа приложений с полным стеком). В ресторане заказ еды исходит из столовой или от front-end. Клиент делает запрос на кухню. В веб-приложениях это обычно происходит в форме  XML/HTTP Request (запроса) или XHR. Давайте разберем этот термин: XML/HTTP Request. Хотя сам термин уже показывает свой возраст (мы не так часто используем XML для отправки данных через Интернет; вместо этого в большинстве случаев теперь используется JSON), вторая часть этого термина, HTTP, является критически важной. HTTP означает HyperTextTransfer Protocol (протокол передачи гипертекста).
// и является основой всего общения в сети. Думайте о HTTP как о способе, с помощью которого все веб-технологии должны взаимодействовать друг с другом.
// Вы можете проанализировать XHR любого веб-сайта на вкладке сети браузера в инструментах разработчика Chrome.

//TODO: The Request / Response Cycle (Цикл запроса/ответа)
// В нашей аналогии после того, как клиент делает запрос, его получает кухня или сервер веб-приложений. Затем сервер веб-приложений анализирует запрос и решает, может ли он выполнить этот заказ. Если заказ может быть выполнен, то кухонный персонал обращается к базе данных (к холодильнику), извлекает данные (еду), подготавливает данные (в формате JSON), а затем отправляет данные обратно клиенту (делает красивым отображение на странице).
// См. Рис: The Request & Response Cycle.png
// Это представляет собой очень простой цикл request/response (запрос/ответ). Запрос отправляется на сервер веб-приложений, анализируется и либо отклоняется NO (error or redirect (ошибка или перенаправление)), либо принимается (YES).

//TODO: HTTP Error Codes (Коды ошибок HTTP)
// Да, XML/HTTP Request (запросы) могут быть отклонены сервером! В случае отклонения сервер веб-приложений отправляет HTTP response (ответ) обратно клиенту (front-end). Возможные коды состояния ошибки HTTP:
// • 404 (не найдено)
// • 403 (запрещено)
// • 401 (не авторизовано)
// • 500 (внутренняя ошибка сервера)
// • 503 (служба недоступна)
// Существует множество других кодов состояния HTTP, и они обычно делятся на категории. по первой цифре кода состояния.
// Сервер и клиент — очень распространенные термины в вычислительной технике. «server» в разработке полного стека обычно относится к серверу веб-приложений, а клиент — к любому устройству, взаимодействующему с сервером в front-end. Обычными клиентами являются ноутбуки и настольные компьютеры, мобильные телефоны, системы GPS в автомобилях, устройства с голосовым управлением, такие как Amazon Alexa, Siri и Google Home, игровые приставки, смарт-часы и все остальное, что подключается к серверной части.

//TODO: HTTP Success Codes (HTTP-коды успеха)
// Все коды уровня 200, как правило, являются положительными кодами состояния:
// • 200 (ok)
// • 201 (created (создано))
// • 202 (accepted (принято)) и т. д.
// Напротив, коды уровня 400 обычно указывают на проблему с самим запросом, а статус уровня 500 коды обычно указывают на ошибку на сервере. Если первоначальный запрос был принят сервером веб-приложений и необходимо получить данные, связанные с запросом, сервер веб-приложений затем запрашивает базу данных или базы данных, чтобы получить информацию, необходимую для отправки обратно пользователю.
// База данных отправляет результат запроса обратно на сервер веб-приложений, а затем сервер веб-приложений обычно форматирует данные в формат, который будет отправлен обратно в front-end. JSON (JavaScript Object Notation) (Java Сценарий Объекта Обозначения) — это очень распространенный формат, который в настоящее время используется для отправки данных клиентам (front-end).
// Коды уровня 200 — положительные, коды уровня 400 — проблемы, а коды уровня 500 — ошибки.

//TODO: The Angular / NEST flow (Угловой / NEST поток)
// Подводя итог, мы будем использовать TypeScript, надмножество JavaScript, для создания полнофункционального приложения под названием TS Flights, которое позволит пользователям искать рейсы самолетов. В приложении также будет страница, которая позволит вам, как администратору, вводить новые рейсы, чтобы отображаться в будущих поисках.
// На фронтенде мы будем использовать Angular. На бэкенде мы будем использовать NestJS.
// Для чего-то вроде поиска рейса или добавления нового рейса в базу данных наше внешнее приложение Angular будет делать запросы к нашему серверному NestJS, используя XHR. Если запрос отклонен, он вернет отрицательный код состояния HTTP обратно в Angular. Если запрос будет принят, он приступит к выполнению той работы, для которой был отправлен... которая может включать получение всех рейсов из Нью-Йорка в Париж или что-то в этом роде. Если запрос был принят и включает вызов базы данных, NestJS сделает запрос к нашей базе данных, получит результат и, если этот запрос к базе данных будет успешным, вернет ответ JSON нашему приложению Angular с кодом состояния уровня 200.
// Затем наше приложение Angular будет использовать HTML и CSS, чтобы сделать ответ красивым, чтобы наши пользователи могли видеть все рейсы в Париж на своем телефоне или компьютере. С помощью этого потока вы должны увидеть, что пользователь инициирует процесс на клиенте, запрос возвращается на сервер, выполняет свою работу, а затем возвращается обратно к клиенту для завершения процесса.
// Request/response cycles (Циклы запроса/ответа) могут быть невероятно сложными, но этот очень простой flow (поток) — начало понимания залпов между front and the back end.

//TODO: Introduction to Angular (Введение в Ангуляр)
// Angular — это front-end (интерфейсный) JavaScript-фреймворк.
// Фреймворк — это набор связанных библиотек, разработанных для определенного языка программирования. Фреймворки provide (предоставляют) conventions (соглашения), которые поддерживают определенные действия. Front-end (интерфейсная) среда обычно имеет определенные соглашения относительно того, как обрабатывается HTML, как создаются формы, как обрабатываются интерактивные элементы на веб-странице, как переменные интерполируются внутри HTML-представлений и т.д. AngularJS или Angular 1.x были первыми. итерация фреймворка Angular. С выходом Angular 2, Angular был полностью переработан с использованием TypeScript и компонентной архитектуры. Хотя архитектура на основе компонентов была доступна в более поздних выпусках Angular 1.x, компоненты теперь являются самой основой Angular 2 и всех последующих выпусков после версии 2 . вариант 3). Angular 8 был выпущен в 2019 году, и этому посвящен этот курс.
// Важно знать, что когда разработчики говорят Angular, они имеют в виду Angular версии 2 и выше. AngularJS относится только к версии 1 Angular.

//TODO: Strings in TypeScript (Строки в TypeScript)
// AngularJS использовал Javascript в качестве основного языка. Angular начал использовать TypeScript, начиная с Angular 2. С тех пор TypeScript стал основным языком Angular. Давайте рассмотрим некоторые основы TypeScript. Переменные в TypeScript могут быть statically typed (статически типизированы). Статически типизированные переменные всегда должны сохранять тип данных, с которого они начинаются. Например, когда переменная статически типизирована как строка, эта переменная не может содержать данные какого-либо другого типа. TypeScript использует ключевые слова JavaScript var, let и const для инициализации переменных. Он также использует двоеточие после имени переменной для обозначения типа.
// Javascript (JS):
// let name = 'Fred'
// TypeScript (TS):
// let name: string = 'Fred'
// Основываясь на этом соглашении, мы могли бы инициализировать строку shoesColor в TypeScript как таковую:
// TypeScript (TS):
// let shoeColor: string = 'blue'
// console.log(shoeColor)
// Возможно изменение значений переменных с течением времени:
// shoeColor = 'red'
// console.log(shoeColor)
// Теперь "shoeColor" имеет значение красного цвета. Обратите внимание, что после того, как переменная была введена, вам не нужно снова объявлять тип при изменении значения переменной.
// TypeScript не требует от вас статической типизации ввода переменных. Обычный синтаксис Javascript БУДЕТ работать в TypeScript. Однако по соглашению большинство программистов вводят статическую типизацию переменных в TypeScript, потому что это помогает обеспечить структуру и предотвратить ошибки программиста.

//TODO: Numbers in TypeScript (Числа в TypeScript)
// Другой тип данных TypeScript — числовой тип данных. Мы можем инициализировать числовую переменную seatCount в TypeScript следующим образом:
// TypeScript (TS):
// let seatCount: number = 42
// TypeScript не определяет между целыми числами и числами с плавающей запятой или десятичными числами, как другие языки, когда дело доходит до набора текста. Инициализация десятичного числа аналогична инициализации целого числа:
// TypeScript (TS):
// let registrationPercentage: number = 92.87
// Обратите внимание, что RegistrationPercentage всегда должен иметь числовой тип. Если бы вы попытались переназначить RegistrationPercentage строковому значению в другой строке этой программы, программа не скомпилировалась бы, и ваш текстовый редактор, скорее всего, выдал бы ошибку.
// TypeScript (TS):
// registrationPercentage = 'Ninety Two'
// ВЫЗЫВАЕТ ОШИБКУ, потому что RegistrationPercentage статически типизирован как число.
// Typescript включает в себя все методы, которые вы привыкли использовать в JavaScript. Например, строковые методы, такие как parseInt() и parseFloat(), которые возвращают числа, также будут работать в TypeScript.

//TODO: Booleans in TypeScript (Логические значения в TypeScript)
// Логические значения либо истинны, либо ложны. В TypeScript вы можете объявить и статически ввести переменную, не инициализируя ее значением. Например:
// TypeScript (TS):
// let isRegistered: boolean
// Однако если вы попытаетесь использовать isRegistered на этом этапе программы, вы получите сообщение об ошибке. Некоторые программисты объявляют переменные и вводят их без инициализации, потому что значение переменной в начале программы совершенно неизвестно. Позже вы можете назначить его.
// TypeScript (TS):
// isRegistered = false;
// console.log(isRegistered); // false
// Логические значения всегда возвращают истинные или ложные значения. Эти значения не являются строками, на самом деле они являются собственным типом данных.

//TODO: Enums in TypeScript (Перечисления в TypeScript)
// Значения Enum в Typescript представляют собой наборы констант. Думайте об Enum как о типе фиксированного массива вещей, которые вы используете в качестве ссылки, например, дни недели, штаты в США и т.д. Количество элементов никогда не меняется во время выполнения программы и порядок элементов. тоже не меняется. Давайте создадим перечисление с именем spiceLevel:
// TypeScript (TS):
// enum spiceLevel {
//   NONE = "no spice",
//   LOW = "barely spicy",
//   MEDIUM = "medium spicy",
//   HIGH = "hot"
// }

// console.log(spiceLevel.MEDIUM) // outputs "medium spicy"
// Современные интегрированные среды разработки (IDE), такие как Visual Studio Code, помогают заполнять значения перечисления и другие конструкции кода с помощью автозаполнения. Перечисления помогают гарантировать согласованность всех часто используемых констант в вашей программе. Это помогает избежать опечаток и общих ошибок.

//TODO: The 'any' Type in TypeScript (Тип «любой» в TypeScript)
// Наконец, мы рассмотрим any (любой) тип данных.
// Тип any (любой) по сути является подстановочным знаком. Он может держать что угодно. Мы можем объявить any тип данных в TypeScript следующим образом:
// TypeScript (TS):
// let userData: any
// userData теперь будет контейнером, который может содержать данные любого типа. Однако после инициализации userData он выводит тип из переданного ему значения.
// let userData: any
// TypeScript (TS):
// userData = 22
// console.log(userData + 2) // logs 24

// userData = "free";
// console.log(userData + "man") // logs "freeman"
// Обратите внимание, что с любым типом данных, даже если тип выводится при присвоении, вы можете повторно присвоить переменной другой тип данных, и он все равно будет работать. С какой стати вам вообще нужен тип any? Что ж, в определенных ситуациях, например при получении пользовательских данных с сервера, вы можете принимать переменные данные, которые предположительно могут относиться к любому типу данных.
// Любые типы не только вмещают данные из любого источника, но и сигнализируют другим разработчикам о том, что эта конкретная переменная имеет неизвестный тип и что с данными следует обращаться осторожно.

//TODO: Custom Types (Пользовательские типы)
// Если вы на минуту подумали, что TypeScript ограничен числовыми, строковыми, логическими и другими знакомыми типами, то у нас есть для вас приятный сюрприз! В TypeScript вы можете создавать свои СОБСТВЕННЫЕ типы и использовать их так же, как и примитивные типы, такие как числа и строки. Один из способов сделать это — создать interface. Interface в TypeScript — это структура данных, которая определяет форму данных. Давайте посмотрим на это в действии:
// TypeScript (TS):
// interface Order {
//   customerName: string,
//   itemNumbers: number[],
//   isComplete: boolean
// }
// Ключевое слово interface используется для инициализации интерфейса, который показывает нам ФОРМУ поступающих данных. Думайте об интерфейсе как о фабричной пресс-форме. Этот интерфейс используется для штамповки типов Order для store (хранилища). Теперь давайте воспользуемся интерфейсом Order для ввода переменной:
// TypeScript (TS):
// let order1: Order;
// order1 = {
//   customerName: "Abiye",
//   itemNumbers: [123, 44, 232],
//   isComplete: false
// }
// Проанализируем переменную order1 (заказ1). Он имеет тип Order (Заказ), поэтому он должен иметь 3 поля:
// - первое поле: строка "Abiye"
// - второе поле: массив целых чисел [123, 44, 232]
// - третье поле — логическое значение false
// Он ДОЛЖЕН иметь каждое из этих полей для выполнения контракта интерфейса. Попробуйте опустить одно из полей в order1 (например, удалите имя клиента). Вы получите ошибку, потому что контракт не выполнен.
// Контракт интерфейса — это просто список полей в этом интерфейсе, которые нужны любой переменной, если она хочет использовать этот тип. Все обычные поля в интерфейсе должны быть реализованы в любой переменной, которая использует этот тип.

//TODO: Optional Fields in Interfaces (Необязательные поля в интерфейсах)
// Мы можем использовать необязательные поля в интерфейсе в TypeScript. Необязательные поля не являются частью строгого контракта интерфейса. Вы можете опустить их при создании экземпляра этого интерфейса.
// TypeScript (TS):
// interface Order {
//   customerName: string,
//   itemNumbers: number[],
//   isComplete?: boolean
// }
// Обратите внимание на вопросительный знак после isComplete? (завершено?) означает, что мы можем опустить это значение, и код все равно скомпилируется. Это полезно для полей в интерфейсе, которые не являются обязательными.
// TypeScript (TS):
// let order1: Order;
// order1 = {
//   customerName: "Abiye",
//   itemNumbers: [123, 44, 232]
// }
// Order1 (заказ1) теперь имеет только 2 поля, и он все еще компилируется, потому что isComplete является необязательным полем.
// Необязательные поля полезны при получении данных из базы данных или вызове API, когда некоторые поля могут отсутствовать или быть неполными.

//TODO: Angular Files (Угловые файлы)
// До этого момента мы создавали простые файлы TypeScript, которые запускаются в любой среде, в которой работает TypeScript. Однако с этого момента мы будем писать ВЕСЬ наш TypeScript на Angular! В Angular каждый component имеет как минимум 4 файла, которые гармонично работают вместе. Эти файлы внутри папки выглядят примерно так:
// См. Рис: AngularFiles_1.png
// Здесь нас будут интересовать только два файла:
// - файл app.component.ts, который мы назовем component
// - файл app.component.html, который мы назовем component view (вид).
// component - это место, где объявляются и изменяются переменные.
// view (вид) - HTML-файл, который получает переменные от компонента и отображает их. Мы создали пример «hello world», чтобы показать вам, как эти файлы взаимодействуют друг с другом.
// COMPONENT (СОСТАВНАЯ ЧАСТЬ):
// TypeScript (TS):
// name = "Star student";
// VIEW (ВИД):
// HTML:
// Hello, {{name}}!
// Result (Результат):
// См. Рис: AngularFiles_2.png
// мы установили этот код в StackBlitz, онлайн-редакторе Angular, который позволяет запускать код на вашем телефоне! В StackBlitz файлы находятся слева, код — посередине, а небольшой браузер — справа. Вы можете просмотреть и/или отредактировать код и увидеть результат в течение нескольких секунд. Попробуйте на StackBlitz
// https://stackblitz.com/edit/angular-starter-example?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-starter-example
// Двойные фигурные скобки вокруг {{name}} демонстрируют то, что мы называем интерполяцией. Интерполяция — это вставка переменного содержимого из компонента в представление.

//TODO: SETUP ANGULAR ON YOUR LOCAL SYSTEM:
// node -v //чтобы проверить наличие установленного nodeJS
// npm -v //чтобы проверить наличие установленного менеджера пакетов npm

// npm install -g @angular/cli //чтобы УСТАНОВИТЬ Angular CLI
// ng new my-app //создать свой проект с любым названием, в данном случае my-app, выбрать css и нажать enter, на ответы отвечаем: N
// cd my-app //перейдите в папку рабочей области
// ng serve --open //запускаем localhost:4200, на ответы отвечаем: N
//TODO: Если localhost:4200 не запустился:
// Открываем под админом CMD/PowerShell и выполняем две команды:
//   net stop winnat
// а затем:
//   net start winnat
//TODO: Давайте сделаем Angular-сервис. Angular может сгенерировать сервис для вас с помощью простой команды, поэтому вам не нужно помнить, как построить базовую структуру. Для этого мы используем эту команду в компьютерном терминале:
//    cd my-app
//    ng generate service transportation
// Это создает пустой сервис в приложении Angular.

//TODO: Parts of a Component (Части компонента)
// См. Рис: Parts of a Component.png
// На нашей диаграмме ниже у нас есть 4 части компонента, представленные четырьмя разноцветными стрелками. Красный раздел — это раздел импорта. Оранжевая стрелка указывает на код, автоматически сгенерированный Angular; нам не нужно трогать эту часть, если мы не хотим ее изменить. Синяя стрелка указывает на то, где объявлены переменные класса. Наконец, зеленая стрелка указывает на то, где объявлены переменные метода. Переменные класса принадлежат всему классу, но переменные метода применяются только в каждом методе (или «функции»), в котором они находятся.
// Попробуйте в StackBlitz View:
// https://stackblitz.com/edit/angular-class-vs-method-variables-intro?file=README.md
// на GitHub:
// https://github.com/SoloLearn-Courses/angular-class-vs-method-variables-intro
// Совет для профессионалов: в объектно-ориентированном программировании функции которые является частью класса называются методы. Компоненты — это классы, поэтому мы называем функции внутри них тоже методами.

//TODO: Class vs Method Variables (Класс против переменных метода)
// Давайте добавим некоторый код в наш метод speak(), чтобы увидеть, как переменные экземпляра и переменные метода выглядят на практике:
// См. Рис: Class vs Method Variables.png
// префикс и имя переменных являются переменными класса. Они принадлежат классу. Внутри метода speak(), если мы хотим вызвать членов класса, мы должны использовать ключевое слово (this). Также обратите внимание, что внутри метода speak() мы используем ключевое слово const для объявления переменной sentence (предложение). Внутри методов вы должны использовать ключевое слово, такое как var, let или const, для объявления переменных. Мы выбрали const, потому что ключевые слова const объявляют значение, которое является константой и не изменится.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-class-vs-method-variables?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-class-vs-method-variables

//TODO: Iterating through String Arrays (Итерация по массивам строк)
// С Angular, отмеченным в коде как ng, мы можем использовать команду *ngFor в файле HTML (представление) для перебора массивов, объявленных в компоненте. Учитывая этот массив в компоненте Angular:
// TypeScript (TS):
// colors: string[] = ['red', 'blue', 'green', 'purple'];
// Мы можем перебирать цвета в сопроводительном HTML-файле в Angular следующим образом:
// HTML:
{
  /* <div *ngFor='let color of colors'> 
  {{ color }} 
</div> */
}
// Результат в вашем браузере будет выглядеть следующим образом:
// red (красный)
// blue (синий)
// green (зеленый)
// purple (фиолетовый)
// Где каждый из цветов, красный, синий, зеленый и т.д. заключен в div. *ngFor по существу создает цикл, в котором html-тег, объявленный внутри циклов, повторяется столько раз, сколько элементов в вызываемом массиве.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-ngfor-looping?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-ngfor-looping
// *ngFor — это структурная директива. Структурные директивы изменяют HTML в соответствии с переменными данными, с которыми они связаны.

//TODO: Iterating with Indices (Итерация с индексами)
// Иногда полезно при переборе массива иметь доступ к индексу в каждой итерации цикла. Вот как мы это делаем в Angular:
// HTML:
{
  /* <div *ngFor='let fruit of fruits; let i=index'>
   Fruit {{ i }} is {{ fruit }} 
</div> */
}
// Результат в вашем браузере будет выглядеть следующим образом:
// Fruit 0 is apple
// Fruit 1 is orange
// Fruit 2 is pear (груша)
// Fruit 3 is peach (персик)
// Обратите внимание, что наша переменная-итератор называется i. Эта переменная может называться как угодно; мы просто использовали букву i из-за условности. Ключевое слово index нельзя изменить. Angular знает, что index — это индекс каждой итерации, когда мы перебираем массив.
// Попробуйте на StackBlitzL:
// https://stackblitz.com/edit/angular-indices?file
// Посмотреть на Github:
// https://github.com/SoloLearn-Courses/angular-indices
// Индексы во время итерации полезны при повторении списков вещей, таких как элементы корзины покупок, которые связаны с идентификаторами базы данных из серверной части. Мы вернемся к этому позже в курсе! Подожди!

//TODO: Iterating through Custom Types (Перебор пользовательских типов)
// Теперь мы соединим то, что вы узнали об интерфейсах, с нашим механизмом циклов *ngFor. Давайте создадим интерфейс для автомобиля и поместим его в отдельный файл с именем car.ts ( .ts — это расширение файлов TypeScript) .
// TypeScript (TS):
// export interface Car {
//   make: string;
//   model: string;
//   miles: number;
// }
// Теперь, когда у нас есть интерфейс Car, мы можем импортировать этот интерфейс в наш компонент как таковой:
// TypeScript (TS):
// import { Car } from './car';
// Теперь мы можем создать 3 объекта типа Car:
// TypeScript (TS):
// subaru: Car = {make: 'Subaru', model: 'Outback', miles: 58232};
// honda: Car = {make: 'Honda', model: 'Accord', miles: 39393};
// bmw: Car = {make: 'BMW', model: 'X3', miles: 4400};
// cars:Car[ ] = [this.subaru, this.honda, this.bmw];
// И, наконец, мы можем просмотреть все наши автомобили в файле HTML:
{
  /* <div *ngFor="let car of cars">
   {{car.make}} {{car.model}}  with a mileage of {{car.miles}}
</div> */
}
// Вот наш вывод:
// Subaru Outback with a mileage of 58232
// Honda Accord with a mileage of 39393
// BMW X3 with a mileage of 4400
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-loop-thru-custom-type?file=src%2Fapp%2Fapp.component.ts
// Когда вы перебираете пользовательский тип, например Car в данном случае, вы должны использовать точечную нотацию (car.make, car.model, car.miles и т.д.) для доступа к элементам этого объекта, поскольку интерфейсы состоят из различных полей, похожие на объект JavaScript.

//TODO: Data's Long Journey (Долгий путь данных)
// На предыдущем уроке мы создали список типов автомобилей в компоненте для циклического просмотра. Это нормально для локальных данных, которые жестко закодированы в компоненте, но в реальных бизнес-примерах данные проходят очень долгий путь, прежде чем они, наконец, достигают нашего представления. Используя нашу предыдущую аналогию с рестораном из Модуля 1, давайте посмотрим на долгий путь, который данные проделывают в реальном мире, прежде чем они попадут к нам:
// См. Рис: Data's Long Journey.png
// по мере того, как мы углубляемся в стек в этом курсе, мы будем продолжать перемещать данные возвращаться все дальше и дальше в стеке, пока мы, наконец, не получим его из базы данных. Наш следующий шаг — переместить данные из компонента в нечто, называемое сервисом, которые мы рассмотрим очень скоро в следующих частях этого урока. Упрощенный типичный поток данных от конца к началу будет выглядеть следующим образом:
// 1. Data retrieved from database query (Данные, полученные из запроса к базе данных)
// 2. Data routed through server (Данные, маршрутизируемые через сервер)
// 3. Data reaches service (Данные достигают службы)
// 4. Data reaches component (Данные достигают компонента)
// 5. Data reaches view (Данные достигают представления)
// Базы данных чаще всего являются местом, где хранятся данные для веб-приложений. Мы в конце концов доберемся туда. Оставайтесь вовлеченными!

//TODO: Introduction to Angular Services (Введение в сервисы Angular)
// Сервисы — это специальные файлы в Angular, которые используются для управления данными. Обычно они извлекают данные из XHR (помните запросы XML/HTTP из Модуля 1?), но они также могут хранить данные самостоятельно. Помните нашу диаграмму о долгом путешествии данных? На данный момент мы не проходим весь путь до базы данных, чтобы получить данные. Мы собираемся просто отправить данные обратно в службу и оставить их там на данный момент. На этой диаграмме показан простой поток между компонентом, службой с данными и представлением HTML.
// См. Рис: Introduction to Angular Services.png
// 1. Компонент cars вызывает транспортную службу (service), которая содержит список автомобилей
// 2. Транспортная служба (service) возвращает список автомобилей компоненту cars
// 3. Представление (view) cars получает список автомобилей и перебирает их, используя *ngFor
// Служба похожа на brain (мозг) в приложении Angular, который либо возвращает данные из самой службы, либо данные, полученные из внешнего источника (external source). Его можно рассматривать как «data manager».

//TODO: Generating an Angular Service (Создание службы Angular)
// Давайте сделаем Angular-сервис. Angular может сгенерировать сервис для вас с помощью простой команды, поэтому вам не нужно помнить, как построить базовую структуру. Для этого мы используем эту команду в компьютерном терминале:
//TODO:    cd my-app
//TODO:    ng generate service transportation
// Это создает пустой сервис в приложении Angular.
// TypeScript (TS):
// import { Injectable } from '@angular/core';
// @Injectable({
//   providedIn: 'root'
// })
// export class TransportationService {
//   constructor() { }
// }
// Нас будут интересовать только две части этой службы:
// 1. Верхняя часть файла, в которой находятся импортированные данные. Сюда мы будем импортировать файлы, которые будет использовать сервис.
// 2. Тело класса, где говорится об экспорте класса TransportationService.
// Тело класса заключено в фигурные скобки после слова TransportationService.
// Методы в теле класса службы используются для экспорта данных из службы.

//TODO: Import Interface into a Service (Импорт интерфейса в сервис)
// Наш транспортный сервис будет содержать множество типов автомобилей. Для этого нам нужно импортировать наш автомобильный интерфейс, который мы создали ранее. Мы узнали, что верхняя часть файла — это место, куда мы импортируем вещи. Мы можем добавить эту строку в верхнюю часть транспортного сервиса:
// TypeScript (TS):
// import { Car } from './car';
// Это позволяет нам использовать тип Car для создания массива Cars. Наш транспортный сервис теперь ИМПОРТИРУЕТ интерфейс из файла car.ts. Вот связь между этими двумя файлами:
// См. Рис: Import Interface into a Service.png
// файл car.ts ЭКСПОРТИРУЕТ интерфейс, а транспортная служба ИМПОРТИРУЕТ тот же самый интерфейс для использования. Теперь это позволит нам создать массив типов автомобилей в нашем сервисе.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-service-imports-interface?file
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-service-imports-interface
// Функциональность импорта/экспорта, которую мы видим в Angular, получена из NodeJS. Эта же система импорта/экспорта встречается почти во всех интерфейсных JavaScript-фреймворках, поскольку большинство этих фреймворков построены с использованием Node.

//TODO: Recreating Car Array in a Service (Воссоздание массива автомобилей в сервисе)
// Теперь, когда мы импортировали ресурс автомобиля, мы можем создать массив типов автомобилей в нашем транспортном сервисе. Последнее, что нам нужно сделать после этого, — это создать метод getCars() для экспорта данных об автомобиле из службы. Вот готовый service:
// TypeScript (TS):
// import { Injectable } from '@angular/core';
// import { Car } from './car';

//  @Injectable({
//   providedIn: 'root'
//  })
//  export class TransportationService {
//   // NEW CODE
//   subaru: Car = {make: 'Subaru', model: 'Outback', miles: 58232};
//   honda: Car = {make: 'Honda', model: 'Accord', miles: 39393};
//   bmw: Car = {make: 'BMW', model: 'X3', miles: 4400};

//   cars:Car[] = [this.subaru, this.honda, this.bmw];

//   constructor() { }

//   // NEW CODE
//   getCars() {
//     return this.cars;
//   }
//  }
// Теперь этот сервис готов к использованию нашим компонентом.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-service-completed?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-service-completed
// Службы экспортируют методы, которые позже будут вызываться компонентами Angular, использующими службу. Один сервис может использоваться несколькими компонентами.

//TODO: Dependency Injection (Внедрение зависимости)
// Теперь, когда наш сервис фактически экспортирует данные, наш компонент должен их загрузить. В Angular мы используем нечто, называемое внедрением зависимостей, для переноса сервиса в компонент. Теперь этот сервис готов к использованию нашим компонентом. Вот как это выглядит:
// См. Рис: Dependency Injection.png
// Dependency injection (Внедрение зависимостей) — распространенный шаблон проектирования в объектно-ориентированном программировании.
// Думайте о внедрении зависимостей, как об установке погодного приложения на свой телефон. Каждый телефон, на котором установлено приложение погоды, получает одно и то же приложение. Его можно установить на несколько телефонов, и каждый телефон, который нажимает кнопку «получить погоду» для города, получит одну и ту же погоду. Служба погоды является центральной службой, предоставляющей данные всем, кто на нее подписан. Это то, что служба делает посредством внедрения зависимостей. Обычно он предоставляет данные всем своим подписчикам вместе с другими функциями.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-service-dependency-injection?file
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-service-dependency-injection
// Обратите внимание, как мы создаем частную переменную с именем transportService, имеющую тип TransportationService. transportService (со строчной буквой t) — это переменная, а TransportationService (с прописной буквой T) — это тип. Эти два соглашения об именах называются camelCase и PascalCase соответственно. Использование camelCase для переменных класса и PascalCase для имен классов и интерфейсов является соглашением, встречающимся во всем Angular.

//TODO: Event Binding (Привязка событий)
// До этого момента мы в основном считывали данные в Angular и выводили их на экран. Что, если бы мы действительно захотели изменить какие-то данные или отреагировать на пользовательские события? Вот где в игру вступает привязка событий Angular. События на основе браузера в Angular обычно привязаны к методам в соответствующих компонентах. Вот пример кнопки, которая вызывает оповещение.
// HTML: app.component.html
{
  /* <button (click)="saySomething()"> Say Something </button> */
}
// TypeScript (TS): app.component.ts
// saySomething() {
//   alert('good day.');
// }
// Давайте разберем этот код.
// HTML:
{
  /* <button (click) = "saySomething()" > Say Something </button> */
}
// Здесь мы вставили обработчик нажатия на кнопку, который срабатывает всякий раз, когда происходит событие нажатия. Это запускает метод "saySomething()" в компоненте. В Angular скобки вокруг обработчика событий в теге html обозначают то, что мы называем event binding (привязкой события). В этом случае «click» заключен в круглые скобки (click), что связывает это событие с методом, переданным в кавычках, то есть «saySomething()». В Интернете происходит много других типов событий: click (щелчок), change (изменение), mouseover (наведение мыши), hover (наведение), dragover (перетаскивание), etc (и т.д.) — все это примеры событий, которые являются результатом действий пользователя. Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-simple-event?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-simple-event
// Обратите внимание, что вы должны использовать () после saySomething() для запуска метода в соответствующем файле app.component.ts. Это связано с тем, что Angular не только привязывает действие к событию, но и запускает событие при нажатии, аналогично в контексте выполнения собственному методу вызова JavaScript. () после метода символизирует запуск события после нажатия этой кнопки.

//TODO: Making a Counter (Создание счетчика)
// Наше следующее упражнение — это пример использования событий щелчка для увеличения счетчика. Когда вы нажимаете на кнопку, счетчик увеличивается.
// Как вы понимаете, нам нужна кнопка с событием клика в представлении, которое привязано к соответствующему методу в компоненте: app.component.html.
// HTML: app.component.html
{
  /* <div class="container">
  <div class="number-display">
    {{counter}}
  </div>
    <button (click)="increment()"> increment </button>
 </div> 
</div> */
}
// TypeScript (TS): app.component.ts
// counter = 0;
// increment() {
//   this.counter++;
// }
// В представлении HTML внутри тега <button> находится метод (щелчок). Это отправляет команду компоненту для запуска метода increment(). Центром функциональности здесь является переменная counter. При нажатии кнопки counter увеличивается. Результат отображается в представлении, потому что {{ counter }} всегда будет содержать обновленное значение переменной counter по мере его увеличения с помощью кликов.
// Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-counter-increment?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-counter-increment
// События дополнительно демонстрируют тесную связь между файлами представления и компонентами.

//TODO: Event Updating a String (Событие, обновляющее строку)
// Попробуем другое упражнение: мы хотим обновить строку событием. В этом примере каждый раз, когда мы нажимаем кнопку, к существующей строке будет добавляться еще несколько слов. Строка будет начинаться со слов «Please», и каждый раз, когда мы нажимаем на кнопку, в конец строки будут добавляться слова «...Пошёл Ты»:
// HTML: app.component.html
{
  /* <div class="display">
  {{phrase}}
</div>
<button (click)="update()"> click me </button> */
}
// TypeScript (TS): app.component.ts
// phrase = "Please";
// update() {
//   this.phrase+=" ...Пошёл Ты";
// }
// Опять же, у нас есть кнопка, связанная с методом, который срабатывает в компоненте. Компонент имеет переменную под названием «phrase», которая начинается всего с двух слов: «Please». Однако каждый раз, когда вы нажимаете кнопку, запускается метод update(), и знак += в этом выражении заставляет компонент добавлять « ...Пошёл Ты» в конец предыдущей фразы. В результате фраза становится все длиннее, длиннее и длиннее каждый раз, когда мы нажимаем кнопку. Это лучше видно в действии! Либо посетите код StackBlitz в режиме онлайн, либо просмотрите на GitHub, чтобы увидеть, как это работает. Попробуйте на StackBlitz:
// https://stackblitz.com/edit/angular-event-update-string?file=README.md
// Посмотреть на GitHub:
// https://github.com/SoloLearn-Courses/angular-counter-increment
// События являются основной частью любого проекта Angular. На самом деле, события действительно являются ключевыми для всех фреймворков TypeScript и JavaScript и большинства приложений, использующих JavaScript в целом.

//TODO: TASK: Кнопка будет удваивать целое число при каждом нажатии кнопки.
// TypeScript (TS): app.component.ts   COMPONENT:
// counter = 1;
// double() {
// this.counter*=2;
// }
// HTML: app.component.html   VIEW:
// {{counter}}
// <button (click) = "double()" > double the number </button>
